(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[0],{

/***/ "./node_modules/@babylonjs/core/Materials/shaderMaterial.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Materials/shaderMaterial.js ***!
  \******************************************************************/
/*! exports provided: ShaderMaterial */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ShaderMaterial\", function() { return ShaderMaterial; });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\n/* harmony import */ var _Misc_decorators__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Misc/decorators */ \"./node_modules/@babylonjs/core/Misc/decorators.js\");\n/* harmony import */ var _Maths_math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Maths/math */ \"./node_modules/@babylonjs/core/Maths/math.js\");\n/* harmony import */ var _Meshes_buffer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Meshes/buffer */ \"./node_modules/@babylonjs/core/Meshes/buffer.js\");\n/* harmony import */ var _Materials_Textures_texture__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Materials/Textures/texture */ \"./node_modules/@babylonjs/core/Materials/Textures/texture.js\");\n/* harmony import */ var _materialHelper__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./materialHelper */ \"./node_modules/@babylonjs/core/Materials/materialHelper.js\");\n/* harmony import */ var _effect__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./effect */ \"./node_modules/@babylonjs/core/Materials/effect.js\");\n/* harmony import */ var _material__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./material */ \"./node_modules/@babylonjs/core/Materials/material.js\");\n/* harmony import */ var _Misc_typeStore__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../Misc/typeStore */ \"./node_modules/@babylonjs/core/Misc/typeStore.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * The ShaderMaterial object has the necessary methods to pass data from your scene to the Vertex and Fragment Shaders and returns a material that can be applied to any mesh.\r\n *\r\n * This returned material effects how the mesh will look based on the code in the shaders.\r\n *\r\n * @see http://doc.babylonjs.com/how_to/shader_material\r\n */\r\nvar ShaderMaterial = /** @class */ (function (_super) {\r\n    tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"](ShaderMaterial, _super);\r\n    /**\r\n     * Instantiate a new shader material.\r\n     * The ShaderMaterial object has the necessary methods to pass data from your scene to the Vertex and Fragment Shaders and returns a material that can be applied to any mesh.\r\n     * This returned material effects how the mesh will look based on the code in the shaders.\r\n     * @see http://doc.babylonjs.com/how_to/shader_material\r\n     * @param name Define the name of the material in the scene\r\n     * @param scene Define the scene the material belongs to\r\n     * @param shaderPath Defines  the route to the shader code in one of three ways:\r\n     *     - object - { vertex: \"custom\", fragment: \"custom\" }, used with Effect.ShadersStore[\"customVertexShader\"] and Effect.ShadersStore[\"customFragmentShader\"]\r\n     *     - object - { vertexElement: \"vertexShaderCode\", fragmentElement: \"fragmentShaderCode\" }, used with shader code in <script> tags\r\n     *     - string - \"./COMMON_NAME\", used with external files COMMON_NAME.vertex.fx and COMMON_NAME.fragment.fx in index.html folder.\r\n     * @param options Define the options used to create the shader\r\n     */\r\n    function ShaderMaterial(name, scene, shaderPath, options) {\r\n        if (options === void 0) { options = {}; }\r\n        var _this = _super.call(this, name, scene) || this;\r\n        _this._textures = {};\r\n        _this._textureArrays = {};\r\n        _this._floats = {};\r\n        _this._ints = {};\r\n        _this._floatsArrays = {};\r\n        _this._colors3 = {};\r\n        _this._colors3Arrays = {};\r\n        _this._colors4 = {};\r\n        _this._vectors2 = {};\r\n        _this._vectors3 = {};\r\n        _this._vectors4 = {};\r\n        _this._matrices = {};\r\n        _this._matrices3x3 = {};\r\n        _this._matrices2x2 = {};\r\n        _this._vectors2Arrays = {};\r\n        _this._vectors3Arrays = {};\r\n        _this._cachedWorldViewMatrix = new _Maths_math__WEBPACK_IMPORTED_MODULE_2__[\"Matrix\"]();\r\n        _this._shaderPath = shaderPath;\r\n        _this._options = tslib__WEBPACK_IMPORTED_MODULE_0__[\"__assign\"]({ needAlphaBlending: false, needAlphaTesting: false, attributes: [\"position\", \"normal\", \"uv\"], uniforms: [\"worldViewProjection\"], uniformBuffers: [], samplers: [], defines: [] }, options);\r\n        return _this;\r\n    }\r\n    Object.defineProperty(ShaderMaterial.prototype, \"options\", {\r\n        /**\r\n         * Gets the options used to compile the shader.\r\n         * They can be modified to trigger a new compilation\r\n         */\r\n        get: function () {\r\n            return this._options;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Gets the current class name of the material e.g. \"ShaderMaterial\"\r\n     * Mainly use in serialization.\r\n     * @returns the class name\r\n     */\r\n    ShaderMaterial.prototype.getClassName = function () {\r\n        return \"ShaderMaterial\";\r\n    };\r\n    /**\r\n     * Specifies if the material will require alpha blending\r\n     * @returns a boolean specifying if alpha blending is needed\r\n     */\r\n    ShaderMaterial.prototype.needAlphaBlending = function () {\r\n        return (this.alpha < 1.0) || this._options.needAlphaBlending;\r\n    };\r\n    /**\r\n     * Specifies if this material should be rendered in alpha test mode\r\n     * @returns a boolean specifying if an alpha test is needed.\r\n     */\r\n    ShaderMaterial.prototype.needAlphaTesting = function () {\r\n        return this._options.needAlphaTesting;\r\n    };\r\n    ShaderMaterial.prototype._checkUniform = function (uniformName) {\r\n        if (this._options.uniforms.indexOf(uniformName) === -1) {\r\n            this._options.uniforms.push(uniformName);\r\n        }\r\n    };\r\n    /**\r\n     * Set a texture in the shader.\r\n     * @param name Define the name of the uniform samplers as defined in the shader\r\n     * @param texture Define the texture to bind to this sampler\r\n     * @return the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    ShaderMaterial.prototype.setTexture = function (name, texture) {\r\n        if (this._options.samplers.indexOf(name) === -1) {\r\n            this._options.samplers.push(name);\r\n        }\r\n        this._textures[name] = texture;\r\n        return this;\r\n    };\r\n    /**\r\n     * Set a texture array in the shader.\r\n     * @param name Define the name of the uniform sampler array as defined in the shader\r\n     * @param textures Define the list of textures to bind to this sampler\r\n     * @return the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    ShaderMaterial.prototype.setTextureArray = function (name, textures) {\r\n        if (this._options.samplers.indexOf(name) === -1) {\r\n            this._options.samplers.push(name);\r\n        }\r\n        this._checkUniform(name);\r\n        this._textureArrays[name] = textures;\r\n        return this;\r\n    };\r\n    /**\r\n     * Set a float in the shader.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @return the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    ShaderMaterial.prototype.setFloat = function (name, value) {\r\n        this._checkUniform(name);\r\n        this._floats[name] = value;\r\n        return this;\r\n    };\r\n    /**\r\n     * Set a int in the shader.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @return the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    ShaderMaterial.prototype.setInt = function (name, value) {\r\n        this._checkUniform(name);\r\n        this._ints[name] = value;\r\n        return this;\r\n    };\r\n    /**\r\n     * Set an array of floats in the shader.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @return the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    ShaderMaterial.prototype.setFloats = function (name, value) {\r\n        this._checkUniform(name);\r\n        this._floatsArrays[name] = value;\r\n        return this;\r\n    };\r\n    /**\r\n     * Set a vec3 in the shader from a Color3.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @return the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    ShaderMaterial.prototype.setColor3 = function (name, value) {\r\n        this._checkUniform(name);\r\n        this._colors3[name] = value;\r\n        return this;\r\n    };\r\n    /**\r\n     * Set a vec3 array in the shader from a Color3 array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @return the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    ShaderMaterial.prototype.setColor3Array = function (name, value) {\r\n        this._checkUniform(name);\r\n        this._colors3Arrays[name] = value.reduce(function (arr, color) {\r\n            color.toArray(arr, arr.length);\r\n            return arr;\r\n        }, []);\r\n        return this;\r\n    };\r\n    /**\r\n     * Set a vec4 in the shader from a Color4.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @return the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    ShaderMaterial.prototype.setColor4 = function (name, value) {\r\n        this._checkUniform(name);\r\n        this._colors4[name] = value;\r\n        return this;\r\n    };\r\n    /**\r\n     * Set a vec2 in the shader from a Vector2.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @return the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    ShaderMaterial.prototype.setVector2 = function (name, value) {\r\n        this._checkUniform(name);\r\n        this._vectors2[name] = value;\r\n        return this;\r\n    };\r\n    /**\r\n     * Set a vec3 in the shader from a Vector3.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @return the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    ShaderMaterial.prototype.setVector3 = function (name, value) {\r\n        this._checkUniform(name);\r\n        this._vectors3[name] = value;\r\n        return this;\r\n    };\r\n    /**\r\n     * Set a vec4 in the shader from a Vector4.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @return the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    ShaderMaterial.prototype.setVector4 = function (name, value) {\r\n        this._checkUniform(name);\r\n        this._vectors4[name] = value;\r\n        return this;\r\n    };\r\n    /**\r\n     * Set a mat4 in the shader from a Matrix.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @return the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    ShaderMaterial.prototype.setMatrix = function (name, value) {\r\n        this._checkUniform(name);\r\n        this._matrices[name] = value;\r\n        return this;\r\n    };\r\n    /**\r\n     * Set a mat3 in the shader from a Float32Array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @return the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    ShaderMaterial.prototype.setMatrix3x3 = function (name, value) {\r\n        this._checkUniform(name);\r\n        this._matrices3x3[name] = value;\r\n        return this;\r\n    };\r\n    /**\r\n     * Set a mat2 in the shader from a Float32Array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @return the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    ShaderMaterial.prototype.setMatrix2x2 = function (name, value) {\r\n        this._checkUniform(name);\r\n        this._matrices2x2[name] = value;\r\n        return this;\r\n    };\r\n    /**\r\n     * Set a vec2 array in the shader from a number array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @return the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    ShaderMaterial.prototype.setArray2 = function (name, value) {\r\n        this._checkUniform(name);\r\n        this._vectors2Arrays[name] = value;\r\n        return this;\r\n    };\r\n    /**\r\n     * Set a vec3 array in the shader from a number array.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @return the material itself allowing \"fluent\" like uniform updates\r\n     */\r\n    ShaderMaterial.prototype.setArray3 = function (name, value) {\r\n        this._checkUniform(name);\r\n        this._vectors3Arrays[name] = value;\r\n        return this;\r\n    };\r\n    ShaderMaterial.prototype._checkCache = function (mesh, useInstances) {\r\n        if (!mesh) {\r\n            return true;\r\n        }\r\n        if (this._effect && (this._effect.defines.indexOf(\"#define INSTANCES\") !== -1) !== useInstances) {\r\n            return false;\r\n        }\r\n        return false;\r\n    };\r\n    /**\r\n     * Specifies that the submesh is ready to be used\r\n     * @param mesh defines the mesh to check\r\n     * @param subMesh defines which submesh to check\r\n     * @param useInstances specifies that instances should be used\r\n     * @returns a boolean indicating that the submesh is ready or not\r\n     */\r\n    ShaderMaterial.prototype.isReadyForSubMesh = function (mesh, subMesh, useInstances) {\r\n        return this.isReady(mesh, useInstances);\r\n    };\r\n    /**\r\n     * Checks if the material is ready to render the requested mesh\r\n     * @param mesh Define the mesh to render\r\n     * @param useInstances Define whether or not the material is used with instances\r\n     * @returns true if ready, otherwise false\r\n     */\r\n    ShaderMaterial.prototype.isReady = function (mesh, useInstances) {\r\n        var scene = this.getScene();\r\n        var engine = scene.getEngine();\r\n        if (!this.checkReadyOnEveryCall) {\r\n            if (this._renderId === scene.getRenderId()) {\r\n                if (this._checkCache(mesh, useInstances)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        // Instances\r\n        var defines = [];\r\n        var attribs = [];\r\n        var fallbacks = new _effect__WEBPACK_IMPORTED_MODULE_6__[\"EffectFallbacks\"]();\r\n        for (var index = 0; index < this._options.defines.length; index++) {\r\n            defines.push(this._options.defines[index]);\r\n        }\r\n        for (var index = 0; index < this._options.attributes.length; index++) {\r\n            attribs.push(this._options.attributes[index]);\r\n        }\r\n        if (mesh && mesh.isVerticesDataPresent(_Meshes_buffer__WEBPACK_IMPORTED_MODULE_3__[\"VertexBuffer\"].ColorKind)) {\r\n            attribs.push(_Meshes_buffer__WEBPACK_IMPORTED_MODULE_3__[\"VertexBuffer\"].ColorKind);\r\n            defines.push(\"#define VERTEXCOLOR\");\r\n        }\r\n        if (useInstances) {\r\n            defines.push(\"#define INSTANCES\");\r\n            _materialHelper__WEBPACK_IMPORTED_MODULE_5__[\"MaterialHelper\"].PrepareAttributesForInstances(attribs, defines);\r\n        }\r\n        // Bones\r\n        if (mesh && mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {\r\n            attribs.push(_Meshes_buffer__WEBPACK_IMPORTED_MODULE_3__[\"VertexBuffer\"].MatricesIndicesKind);\r\n            attribs.push(_Meshes_buffer__WEBPACK_IMPORTED_MODULE_3__[\"VertexBuffer\"].MatricesWeightsKind);\r\n            if (mesh.numBoneInfluencers > 4) {\r\n                attribs.push(_Meshes_buffer__WEBPACK_IMPORTED_MODULE_3__[\"VertexBuffer\"].MatricesIndicesExtraKind);\r\n                attribs.push(_Meshes_buffer__WEBPACK_IMPORTED_MODULE_3__[\"VertexBuffer\"].MatricesWeightsExtraKind);\r\n            }\r\n            var skeleton = mesh.skeleton;\r\n            defines.push(\"#define NUM_BONE_INFLUENCERS \" + mesh.numBoneInfluencers);\r\n            fallbacks.addCPUSkinningFallback(0, mesh);\r\n            if (skeleton.isUsingTextureForMatrices) {\r\n                defines.push(\"#define BONETEXTURE\");\r\n                if (this._options.uniforms.indexOf(\"boneTextureWidth\") === -1) {\r\n                    this._options.uniforms.push(\"boneTextureWidth\");\r\n                }\r\n                if (this._options.samplers.indexOf(\"boneSampler\") === -1) {\r\n                    this._options.samplers.push(\"boneSampler\");\r\n                }\r\n            }\r\n            else {\r\n                defines.push(\"#define BonesPerMesh \" + (skeleton.bones.length + 1));\r\n                if (this._options.uniforms.indexOf(\"mBones\") === -1) {\r\n                    this._options.uniforms.push(\"mBones\");\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            defines.push(\"#define NUM_BONE_INFLUENCERS 0\");\r\n        }\r\n        // Textures\r\n        for (var name in this._textures) {\r\n            if (!this._textures[name].isReady()) {\r\n                return false;\r\n            }\r\n        }\r\n        // Alpha test\r\n        if (mesh && this._shouldTurnAlphaTestOn(mesh)) {\r\n            defines.push(\"#define ALPHATEST\");\r\n        }\r\n        var previousEffect = this._effect;\r\n        var join = defines.join(\"\\n\");\r\n        this._effect = engine.createEffect(this._shaderPath, {\r\n            attributes: attribs,\r\n            uniformsNames: this._options.uniforms,\r\n            uniformBuffersNames: this._options.uniformBuffers,\r\n            samplers: this._options.samplers,\r\n            defines: join,\r\n            fallbacks: fallbacks,\r\n            onCompiled: this.onCompiled,\r\n            onError: this.onError\r\n        }, engine);\r\n        if (!this._effect.isReady()) {\r\n            return false;\r\n        }\r\n        if (previousEffect !== this._effect) {\r\n            scene.resetCachedMaterial();\r\n        }\r\n        this._renderId = scene.getRenderId();\r\n        return true;\r\n    };\r\n    /**\r\n     * Binds the world matrix to the material\r\n     * @param world defines the world transformation matrix\r\n     */\r\n    ShaderMaterial.prototype.bindOnlyWorldMatrix = function (world) {\r\n        var scene = this.getScene();\r\n        if (!this._effect) {\r\n            return;\r\n        }\r\n        if (this._options.uniforms.indexOf(\"world\") !== -1) {\r\n            this._effect.setMatrix(\"world\", world);\r\n        }\r\n        if (this._options.uniforms.indexOf(\"worldView\") !== -1) {\r\n            world.multiplyToRef(scene.getViewMatrix(), this._cachedWorldViewMatrix);\r\n            this._effect.setMatrix(\"worldView\", this._cachedWorldViewMatrix);\r\n        }\r\n        if (this._options.uniforms.indexOf(\"worldViewProjection\") !== -1) {\r\n            this._effect.setMatrix(\"worldViewProjection\", world.multiply(scene.getTransformMatrix()));\r\n        }\r\n    };\r\n    /**\r\n     * Binds the material to the mesh\r\n     * @param world defines the world transformation matrix\r\n     * @param mesh defines the mesh to bind the material to\r\n     */\r\n    ShaderMaterial.prototype.bind = function (world, mesh) {\r\n        // Std values\r\n        this.bindOnlyWorldMatrix(world);\r\n        if (this._effect && this.getScene().getCachedMaterial() !== this) {\r\n            if (this._options.uniforms.indexOf(\"view\") !== -1) {\r\n                this._effect.setMatrix(\"view\", this.getScene().getViewMatrix());\r\n            }\r\n            if (this._options.uniforms.indexOf(\"projection\") !== -1) {\r\n                this._effect.setMatrix(\"projection\", this.getScene().getProjectionMatrix());\r\n            }\r\n            if (this._options.uniforms.indexOf(\"viewProjection\") !== -1) {\r\n                this._effect.setMatrix(\"viewProjection\", this.getScene().getTransformMatrix());\r\n            }\r\n            // Bones\r\n            _materialHelper__WEBPACK_IMPORTED_MODULE_5__[\"MaterialHelper\"].BindBonesParameters(mesh, this._effect);\r\n            var name;\r\n            // Texture\r\n            for (name in this._textures) {\r\n                this._effect.setTexture(name, this._textures[name]);\r\n            }\r\n            // Texture arrays\r\n            for (name in this._textureArrays) {\r\n                this._effect.setTextureArray(name, this._textureArrays[name]);\r\n            }\r\n            // Int\r\n            for (name in this._ints) {\r\n                this._effect.setInt(name, this._ints[name]);\r\n            }\r\n            // Float\r\n            for (name in this._floats) {\r\n                this._effect.setFloat(name, this._floats[name]);\r\n            }\r\n            // Floats\r\n            for (name in this._floatsArrays) {\r\n                this._effect.setArray(name, this._floatsArrays[name]);\r\n            }\r\n            // Color3\r\n            for (name in this._colors3) {\r\n                this._effect.setColor3(name, this._colors3[name]);\r\n            }\r\n            for (name in this._colors3Arrays) {\r\n                this._effect.setArray3(name, this._colors3Arrays[name]);\r\n            }\r\n            // Color4\r\n            for (name in this._colors4) {\r\n                var color = this._colors4[name];\r\n                this._effect.setFloat4(name, color.r, color.g, color.b, color.a);\r\n            }\r\n            // Vector2\r\n            for (name in this._vectors2) {\r\n                this._effect.setVector2(name, this._vectors2[name]);\r\n            }\r\n            // Vector3\r\n            for (name in this._vectors3) {\r\n                this._effect.setVector3(name, this._vectors3[name]);\r\n            }\r\n            // Vector4\r\n            for (name in this._vectors4) {\r\n                this._effect.setVector4(name, this._vectors4[name]);\r\n            }\r\n            // Matrix\r\n            for (name in this._matrices) {\r\n                this._effect.setMatrix(name, this._matrices[name]);\r\n            }\r\n            // Matrix 3x3\r\n            for (name in this._matrices3x3) {\r\n                this._effect.setMatrix3x3(name, this._matrices3x3[name]);\r\n            }\r\n            // Matrix 2x2\r\n            for (name in this._matrices2x2) {\r\n                this._effect.setMatrix2x2(name, this._matrices2x2[name]);\r\n            }\r\n            // Vector2Array\r\n            for (name in this._vectors2Arrays) {\r\n                this._effect.setArray2(name, this._vectors2Arrays[name]);\r\n            }\r\n            // Vector3Array\r\n            for (name in this._vectors3Arrays) {\r\n                this._effect.setArray3(name, this._vectors3Arrays[name]);\r\n            }\r\n        }\r\n        this._afterBind(mesh);\r\n    };\r\n    /**\r\n     * Gets the active textures from the material\r\n     * @returns an array of textures\r\n     */\r\n    ShaderMaterial.prototype.getActiveTextures = function () {\r\n        var activeTextures = _super.prototype.getActiveTextures.call(this);\r\n        for (var name in this._textures) {\r\n            activeTextures.push(this._textures[name]);\r\n        }\r\n        for (var name in this._textureArrays) {\r\n            var array = this._textureArrays[name];\r\n            for (var index = 0; index < array.length; index++) {\r\n                activeTextures.push(array[index]);\r\n            }\r\n        }\r\n        return activeTextures;\r\n    };\r\n    /**\r\n     * Specifies if the material uses a texture\r\n     * @param texture defines the texture to check against the material\r\n     * @returns a boolean specifying if the material uses the texture\r\n     */\r\n    ShaderMaterial.prototype.hasTexture = function (texture) {\r\n        if (_super.prototype.hasTexture.call(this, texture)) {\r\n            return true;\r\n        }\r\n        for (var name in this._textures) {\r\n            if (this._textures[name] === texture) {\r\n                return true;\r\n            }\r\n        }\r\n        for (var name in this._textureArrays) {\r\n            var array = this._textureArrays[name];\r\n            for (var index = 0; index < array.length; index++) {\r\n                if (array[index] === texture) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    };\r\n    /**\r\n     * Makes a duplicate of the material, and gives it a new name\r\n     * @param name defines the new name for the duplicated material\r\n     * @returns the cloned material\r\n     */\r\n    ShaderMaterial.prototype.clone = function (name) {\r\n        var newShaderMaterial = new ShaderMaterial(name, this.getScene(), this._shaderPath, this._options);\r\n        return newShaderMaterial;\r\n    };\r\n    /**\r\n     * Disposes the material\r\n     * @param forceDisposeEffect specifies if effects should be forcefully disposed\r\n     * @param forceDisposeTextures specifies if textures should be forcefully disposed\r\n     * @param notBoundToMesh specifies if the material that is being disposed is known to be not bound to any mesh\r\n     */\r\n    ShaderMaterial.prototype.dispose = function (forceDisposeEffect, forceDisposeTextures, notBoundToMesh) {\r\n        if (forceDisposeTextures) {\r\n            var name;\r\n            for (name in this._textures) {\r\n                this._textures[name].dispose();\r\n            }\r\n            for (name in this._textureArrays) {\r\n                var array = this._textureArrays[name];\r\n                for (var index = 0; index < array.length; index++) {\r\n                    array[index].dispose();\r\n                }\r\n            }\r\n        }\r\n        this._textures = {};\r\n        _super.prototype.dispose.call(this, forceDisposeEffect, forceDisposeTextures, notBoundToMesh);\r\n    };\r\n    /**\r\n     * Serializes this material in a JSON representation\r\n     * @returns the serialized material object\r\n     */\r\n    ShaderMaterial.prototype.serialize = function () {\r\n        var serializationObject = _Misc_decorators__WEBPACK_IMPORTED_MODULE_1__[\"SerializationHelper\"].Serialize(this);\r\n        serializationObject.customType = \"BABYLON.ShaderMaterial\";\r\n        serializationObject.options = this._options;\r\n        serializationObject.shaderPath = this._shaderPath;\r\n        var name;\r\n        // Texture\r\n        serializationObject.textures = {};\r\n        for (name in this._textures) {\r\n            serializationObject.textures[name] = this._textures[name].serialize();\r\n        }\r\n        // Texture arrays\r\n        serializationObject.textureArrays = {};\r\n        for (name in this._textureArrays) {\r\n            serializationObject.textureArrays[name] = [];\r\n            var array = this._textureArrays[name];\r\n            for (var index = 0; index < array.length; index++) {\r\n                serializationObject.textureArrays[name].push(array[index].serialize());\r\n            }\r\n        }\r\n        // Float\r\n        serializationObject.floats = {};\r\n        for (name in this._floats) {\r\n            serializationObject.floats[name] = this._floats[name];\r\n        }\r\n        // Float s\r\n        serializationObject.FloatArrays = {};\r\n        for (name in this._floatsArrays) {\r\n            serializationObject.FloatArrays[name] = this._floatsArrays[name];\r\n        }\r\n        // Color3\r\n        serializationObject.colors3 = {};\r\n        for (name in this._colors3) {\r\n            serializationObject.colors3[name] = this._colors3[name].asArray();\r\n        }\r\n        // Color3 array\r\n        serializationObject.colors3Arrays = {};\r\n        for (name in this._colors3Arrays) {\r\n            serializationObject.colors3Arrays[name] = this._colors3Arrays[name];\r\n        }\r\n        // Color4\r\n        serializationObject.colors4 = {};\r\n        for (name in this._colors4) {\r\n            serializationObject.colors4[name] = this._colors4[name].asArray();\r\n        }\r\n        // Vector2\r\n        serializationObject.vectors2 = {};\r\n        for (name in this._vectors2) {\r\n            serializationObject.vectors2[name] = this._vectors2[name].asArray();\r\n        }\r\n        // Vector3\r\n        serializationObject.vectors3 = {};\r\n        for (name in this._vectors3) {\r\n            serializationObject.vectors3[name] = this._vectors3[name].asArray();\r\n        }\r\n        // Vector4\r\n        serializationObject.vectors4 = {};\r\n        for (name in this._vectors4) {\r\n            serializationObject.vectors4[name] = this._vectors4[name].asArray();\r\n        }\r\n        // Matrix\r\n        serializationObject.matrices = {};\r\n        for (name in this._matrices) {\r\n            serializationObject.matrices[name] = this._matrices[name].asArray();\r\n        }\r\n        // Matrix 3x3\r\n        serializationObject.matrices3x3 = {};\r\n        for (name in this._matrices3x3) {\r\n            serializationObject.matrices3x3[name] = this._matrices3x3[name];\r\n        }\r\n        // Matrix 2x2\r\n        serializationObject.matrices2x2 = {};\r\n        for (name in this._matrices2x2) {\r\n            serializationObject.matrices2x2[name] = this._matrices2x2[name];\r\n        }\r\n        // Vector2Array\r\n        serializationObject.vectors2Arrays = {};\r\n        for (name in this._vectors2Arrays) {\r\n            serializationObject.vectors2Arrays[name] = this._vectors2Arrays[name];\r\n        }\r\n        // Vector3Array\r\n        serializationObject.vectors3Arrays = {};\r\n        for (name in this._vectors3Arrays) {\r\n            serializationObject.vectors3Arrays[name] = this._vectors3Arrays[name];\r\n        }\r\n        return serializationObject;\r\n    };\r\n    /**\r\n     * Creates a shader material from parsed shader material data\r\n     * @param source defines the JSON represnetation of the material\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\r\n     * @returns a new material\r\n     */\r\n    ShaderMaterial.Parse = function (source, scene, rootUrl) {\r\n        var material = _Misc_decorators__WEBPACK_IMPORTED_MODULE_1__[\"SerializationHelper\"].Parse(function () { return new ShaderMaterial(source.name, scene, source.shaderPath, source.options); }, source, scene, rootUrl);\r\n        var name;\r\n        // Texture\r\n        for (name in source.textures) {\r\n            material.setTexture(name, _Materials_Textures_texture__WEBPACK_IMPORTED_MODULE_4__[\"Texture\"].Parse(source.textures[name], scene, rootUrl));\r\n        }\r\n        // Texture arrays\r\n        for (name in source.textureArrays) {\r\n            var array = source.textureArrays[name];\r\n            var textureArray = new Array();\r\n            for (var index = 0; index < array.length; index++) {\r\n                textureArray.push(_Materials_Textures_texture__WEBPACK_IMPORTED_MODULE_4__[\"Texture\"].Parse(array[index], scene, rootUrl));\r\n            }\r\n            material.setTextureArray(name, textureArray);\r\n        }\r\n        // Float\r\n        for (name in source.floats) {\r\n            material.setFloat(name, source.floats[name]);\r\n        }\r\n        // Float s\r\n        for (name in source.floatsArrays) {\r\n            material.setFloats(name, source.floatsArrays[name]);\r\n        }\r\n        // Color3\r\n        for (name in source.colors3) {\r\n            material.setColor3(name, _Maths_math__WEBPACK_IMPORTED_MODULE_2__[\"Color3\"].FromArray(source.colors3[name]));\r\n        }\r\n        // Color3 arrays\r\n        for (name in source.colors3Arrays) {\r\n            var colors = source.colors3Arrays[name].reduce(function (arr, num, i) {\r\n                if (i % 3 === 0) {\r\n                    arr.push([num]);\r\n                }\r\n                else {\r\n                    arr[arr.length - 1].push(num);\r\n                }\r\n                return arr;\r\n            }, []).map(function (color) { return _Maths_math__WEBPACK_IMPORTED_MODULE_2__[\"Color3\"].FromArray(color); });\r\n            material.setColor3Array(name, colors);\r\n        }\r\n        // Color4\r\n        for (name in source.colors4) {\r\n            material.setColor4(name, _Maths_math__WEBPACK_IMPORTED_MODULE_2__[\"Color4\"].FromArray(source.colors4[name]));\r\n        }\r\n        // Vector2\r\n        for (name in source.vectors2) {\r\n            material.setVector2(name, _Maths_math__WEBPACK_IMPORTED_MODULE_2__[\"Vector2\"].FromArray(source.vectors2[name]));\r\n        }\r\n        // Vector3\r\n        for (name in source.vectors3) {\r\n            material.setVector3(name, _Maths_math__WEBPACK_IMPORTED_MODULE_2__[\"Vector3\"].FromArray(source.vectors3[name]));\r\n        }\r\n        // Vector4\r\n        for (name in source.vectors4) {\r\n            material.setVector4(name, _Maths_math__WEBPACK_IMPORTED_MODULE_2__[\"Vector4\"].FromArray(source.vectors4[name]));\r\n        }\r\n        // Matrix\r\n        for (name in source.matrices) {\r\n            material.setMatrix(name, _Maths_math__WEBPACK_IMPORTED_MODULE_2__[\"Matrix\"].FromArray(source.matrices[name]));\r\n        }\r\n        // Matrix 3x3\r\n        for (name in source.matrices3x3) {\r\n            material.setMatrix3x3(name, source.matrices3x3[name]);\r\n        }\r\n        // Matrix 2x2\r\n        for (name in source.matrices2x2) {\r\n            material.setMatrix2x2(name, source.matrices2x2[name]);\r\n        }\r\n        // Vector2Array\r\n        for (name in source.vectors2Arrays) {\r\n            material.setArray2(name, source.vectors2Arrays[name]);\r\n        }\r\n        // Vector3Array\r\n        for (name in source.vectors3Arrays) {\r\n            material.setArray3(name, source.vectors3Arrays[name]);\r\n        }\r\n        return material;\r\n    };\r\n    return ShaderMaterial;\r\n}(_material__WEBPACK_IMPORTED_MODULE_7__[\"Material\"]));\r\n\r\n_Misc_typeStore__WEBPACK_IMPORTED_MODULE_8__[\"_TypeStore\"].RegisteredTypes[\"BABYLON.ShaderMaterial\"] = ShaderMaterial;\r\n//# sourceMappingURL=shaderMaterial.js.map\n\n//# sourceURL=webpack:///./node_modules/@babylonjs/core/Materials/shaderMaterial.js?");

/***/ }),

/***/ "./node_modules/@babylonjs/core/Meshes/Builders/boxBuilder.js":
/*!********************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Meshes/Builders/boxBuilder.js ***!
  \********************************************************************/
/*! exports provided: BoxBuilder */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BoxBuilder\", function() { return BoxBuilder; });\n/* harmony import */ var _Maths_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Maths/math */ \"./node_modules/@babylonjs/core/Maths/math.js\");\n/* harmony import */ var _mesh__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../mesh */ \"./node_modules/@babylonjs/core/Meshes/mesh.js\");\n/* harmony import */ var _mesh_vertexData__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../mesh.vertexData */ \"./node_modules/@babylonjs/core/Meshes/mesh.vertexData.js\");\n\r\n\r\n\r\n_mesh_vertexData__WEBPACK_IMPORTED_MODULE_2__[\"VertexData\"].CreateBox = function (options) {\r\n    var nbFaces = 6;\r\n    var indices = [0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23];\r\n    var normals = [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0];\r\n    var uvs = [];\r\n    var positions = [];\r\n    var width = options.width || options.size || 1;\r\n    var height = options.height || options.size || 1;\r\n    var depth = options.depth || options.size || 1;\r\n    var wrap = options.wrap || false;\r\n    var topBaseAt = (options.topBaseAt === void 0) ? 1 : options.topBaseAt;\r\n    var bottomBaseAt = (options.bottomBaseAt === void 0) ? 0 : options.bottomBaseAt;\r\n    topBaseAt = (topBaseAt + 4) % 4; // places values as 0 to 3\r\n    bottomBaseAt = (bottomBaseAt + 4) % 4; // places values as 0 to 3\r\n    var topOrder = [2, 0, 3, 1];\r\n    var bottomOrder = [2, 0, 1, 3];\r\n    var topIndex = topOrder[topBaseAt];\r\n    var bottomIndex = bottomOrder[bottomBaseAt];\r\n    var basePositions = [1, -1, 1, -1, -1, 1, -1, 1, 1, 1, 1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1, 1, 1, -1, 1, -1, -1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1, 1, 1, -1, 1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, -1, -1, -1, -1, -1, 1];\r\n    if (wrap) {\r\n        indices = [2, 3, 0, 2, 0, 1, 4, 5, 6, 4, 6, 7, 9, 10, 11, 9, 11, 8, 12, 14, 15, 12, 13, 14];\r\n        basePositions = [-1, 1, 1, 1, 1, 1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1, 1, 1, 1, 1, 1, -1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1, 1, 1, -1, -1, 1, -1, -1, -1];\r\n        var topFaceBase = [[1, 1, 1], [-1, 1, 1], [-1, 1, -1], [1, 1, -1]];\r\n        var bottomFaceBase = [[-1, -1, 1], [1, -1, 1], [1, -1, -1], [-1, -1, -1]];\r\n        var topFaceOrder = [17, 18, 19, 16];\r\n        var bottomFaceOrder = [22, 23, 20, 21];\r\n        while (topIndex > 0) {\r\n            topFaceBase.unshift(topFaceBase.pop());\r\n            topFaceOrder.unshift(topFaceOrder.pop());\r\n            topIndex--;\r\n        }\r\n        while (bottomIndex > 0) {\r\n            bottomFaceBase.unshift(bottomFaceBase.pop());\r\n            bottomFaceOrder.unshift(bottomFaceOrder.pop());\r\n            bottomIndex--;\r\n        }\r\n        topFaceBase = topFaceBase.flat();\r\n        bottomFaceBase = bottomFaceBase.flat();\r\n        basePositions = basePositions.concat(topFaceBase).concat(bottomFaceBase);\r\n        indices.push(topFaceOrder[0], topFaceOrder[2], topFaceOrder[3], topFaceOrder[0], topFaceOrder[1], topFaceOrder[2]);\r\n        indices.push(bottomFaceOrder[0], bottomFaceOrder[2], bottomFaceOrder[3], bottomFaceOrder[0], bottomFaceOrder[1], bottomFaceOrder[2]);\r\n    }\r\n    var scaleArray = [width / 2, height / 2, depth / 2];\r\n    positions = basePositions.reduce(function (accumulator, currentValue, currentIndex) { return accumulator.concat(currentValue * scaleArray[currentIndex % 3]); }, []);\r\n    var sideOrientation = (options.sideOrientation === 0) ? 0 : options.sideOrientation || _mesh_vertexData__WEBPACK_IMPORTED_MODULE_2__[\"VertexData\"].DEFAULTSIDE;\r\n    var faceUV = options.faceUV || new Array(6);\r\n    var faceColors = options.faceColors;\r\n    var colors = [];\r\n    // default face colors and UV if undefined\r\n    for (var f = 0; f < 6; f++) {\r\n        if (faceUV[f] === undefined) {\r\n            faceUV[f] = new _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector4\"](0, 0, 1, 1);\r\n        }\r\n        if (faceColors && faceColors[f] === undefined) {\r\n            faceColors[f] = new _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Color4\"](1, 1, 1, 1);\r\n        }\r\n    }\r\n    // Create each face in turn.\r\n    for (var index = 0; index < nbFaces; index++) {\r\n        uvs.push(faceUV[index].z, faceUV[index].w);\r\n        uvs.push(faceUV[index].x, faceUV[index].w);\r\n        uvs.push(faceUV[index].x, faceUV[index].y);\r\n        uvs.push(faceUV[index].z, faceUV[index].y);\r\n        if (faceColors) {\r\n            for (var c = 0; c < 4; c++) {\r\n                colors.push(faceColors[index].r, faceColors[index].g, faceColors[index].b, faceColors[index].a);\r\n            }\r\n        }\r\n    }\r\n    // sides\r\n    _mesh_vertexData__WEBPACK_IMPORTED_MODULE_2__[\"VertexData\"]._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\r\n    // Result\r\n    var vertexData = new _mesh_vertexData__WEBPACK_IMPORTED_MODULE_2__[\"VertexData\"]();\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n    if (faceColors) {\r\n        var totalColors = (sideOrientation === _mesh_vertexData__WEBPACK_IMPORTED_MODULE_2__[\"VertexData\"].DOUBLESIDE) ? colors.concat(colors) : colors;\r\n        vertexData.colors = totalColors;\r\n    }\r\n    return vertexData;\r\n};\r\n_mesh__WEBPACK_IMPORTED_MODULE_1__[\"Mesh\"].CreateBox = function (name, size, scene, updatable, sideOrientation) {\r\n    if (scene === void 0) { scene = null; }\r\n    var options = {\r\n        size: size,\r\n        sideOrientation: sideOrientation,\r\n        updatable: updatable\r\n    };\r\n    return BoxBuilder.CreateBox(name, options, scene);\r\n};\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n */\r\nvar BoxBuilder = /** @class */ (function () {\r\n    function BoxBuilder() {\r\n    }\r\n    /**\r\n     * Creates a box mesh\r\n     * * The parameter `size` sets the size (float) of each box side (default 1)\r\n     * * You can set some different box dimensions by using the parameters `width`, `height` and `depth` (all by default have the same value of `size`)\r\n     * * You can set different colors and different images to each box side by using the parameters `faceColors` (an array of 6 Color3 elements) and `faceUV` (an array of 6 Vector4 elements)\r\n     * * Please read this tutorial : https://doc.babylonjs.com/how_to/createbox_per_face_textures_and_colors\r\n     * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n     * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\r\n     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n     * @see https://doc.babylonjs.com/how_to/set_shapes#box\r\n     * @param name defines the name of the mesh\r\n     * @param options defines the options used to create the mesh\r\n     * @param scene defines the hosting scene\r\n     * @returns the box mesh\r\n     */\r\n    BoxBuilder.CreateBox = function (name, options, scene) {\r\n        if (scene === void 0) { scene = null; }\r\n        var box = new _mesh__WEBPACK_IMPORTED_MODULE_1__[\"Mesh\"](name, scene);\r\n        options.sideOrientation = _mesh__WEBPACK_IMPORTED_MODULE_1__[\"Mesh\"]._GetDefaultSideOrientation(options.sideOrientation);\r\n        box._originalBuilderSideOrientation = options.sideOrientation;\r\n        var vertexData = _mesh_vertexData__WEBPACK_IMPORTED_MODULE_2__[\"VertexData\"].CreateBox(options);\r\n        vertexData.applyToMesh(box, options.updatable);\r\n        return box;\r\n    };\r\n    return BoxBuilder;\r\n}());\r\n\r\n//# sourceMappingURL=boxBuilder.js.map\n\n//# sourceURL=webpack:///./node_modules/@babylonjs/core/Meshes/Builders/boxBuilder.js?");

/***/ }),

/***/ "./node_modules/@babylonjs/core/Meshes/Builders/cylinderBuilder.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Meshes/Builders/cylinderBuilder.js ***!
  \*************************************************************************/
/*! exports provided: CylinderBuilder */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CylinderBuilder\", function() { return CylinderBuilder; });\n/* harmony import */ var _Maths_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Maths/math */ \"./node_modules/@babylonjs/core/Maths/math.js\");\n/* harmony import */ var _mesh__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../mesh */ \"./node_modules/@babylonjs/core/Meshes/mesh.js\");\n/* harmony import */ var _mesh_vertexData__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../mesh.vertexData */ \"./node_modules/@babylonjs/core/Meshes/mesh.vertexData.js\");\n/* harmony import */ var _scene__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../scene */ \"./node_modules/@babylonjs/core/scene.js\");\n\r\n\r\n\r\n\r\n_mesh_vertexData__WEBPACK_IMPORTED_MODULE_2__[\"VertexData\"].CreateCylinder = function (options) {\r\n    var height = options.height || 2;\r\n    var diameterTop = (options.diameterTop === 0) ? 0 : options.diameterTop || options.diameter || 1;\r\n    var diameterBottom = (options.diameterBottom === 0) ? 0 : options.diameterBottom || options.diameter || 1;\r\n    var tessellation = options.tessellation || 24;\r\n    var subdivisions = options.subdivisions || 1;\r\n    var hasRings = options.hasRings ? true : false;\r\n    var enclose = options.enclose ? true : false;\r\n    var arc = options.arc && (options.arc <= 0 || options.arc > 1) ? 1.0 : options.arc || 1.0;\r\n    var sideOrientation = (options.sideOrientation === 0) ? 0 : options.sideOrientation || _mesh_vertexData__WEBPACK_IMPORTED_MODULE_2__[\"VertexData\"].DEFAULTSIDE;\r\n    var faceUV = options.faceUV || new Array(3);\r\n    var faceColors = options.faceColors;\r\n    // default face colors and UV if undefined\r\n    var quadNb = (arc !== 1 && enclose) ? 2 : 0;\r\n    var ringNb = (hasRings) ? subdivisions : 1;\r\n    var surfaceNb = 2 + (1 + quadNb) * ringNb;\r\n    var f;\r\n    for (f = 0; f < surfaceNb; f++) {\r\n        if (faceColors && faceColors[f] === undefined) {\r\n            faceColors[f] = new _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Color4\"](1, 1, 1, 1);\r\n        }\r\n    }\r\n    for (f = 0; f < surfaceNb; f++) {\r\n        if (faceUV && faceUV[f] === undefined) {\r\n            faceUV[f] = new _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector4\"](0, 0, 1, 1);\r\n        }\r\n    }\r\n    var indices = new Array();\r\n    var positions = new Array();\r\n    var normals = new Array();\r\n    var uvs = new Array();\r\n    var colors = new Array();\r\n    var angle_step = Math.PI * 2 * arc / tessellation;\r\n    var angle;\r\n    var h;\r\n    var radius;\r\n    var tan = (diameterBottom - diameterTop) / 2 / height;\r\n    var ringVertex = _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"].Zero();\r\n    var ringNormal = _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"].Zero();\r\n    var ringFirstVertex = _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"].Zero();\r\n    var ringFirstNormal = _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"].Zero();\r\n    var quadNormal = _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"].Zero();\r\n    var Y = _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Axis\"].Y;\r\n    // positions, normals, uvs\r\n    var i;\r\n    var j;\r\n    var r;\r\n    var ringIdx = 1;\r\n    var s = 1; // surface index\r\n    var cs = 0;\r\n    var v = 0;\r\n    for (i = 0; i <= subdivisions; i++) {\r\n        h = i / subdivisions;\r\n        radius = (h * (diameterTop - diameterBottom) + diameterBottom) / 2;\r\n        ringIdx = (hasRings && i !== 0 && i !== subdivisions) ? 2 : 1;\r\n        for (r = 0; r < ringIdx; r++) {\r\n            if (hasRings) {\r\n                s += r;\r\n            }\r\n            if (enclose) {\r\n                s += 2 * r;\r\n            }\r\n            for (j = 0; j <= tessellation; j++) {\r\n                angle = j * angle_step;\r\n                // position\r\n                ringVertex.x = Math.cos(-angle) * radius;\r\n                ringVertex.y = -height / 2 + h * height;\r\n                ringVertex.z = Math.sin(-angle) * radius;\r\n                // normal\r\n                if (diameterTop === 0 && i === subdivisions) {\r\n                    // if no top cap, reuse former normals\r\n                    ringNormal.x = normals[normals.length - (tessellation + 1) * 3];\r\n                    ringNormal.y = normals[normals.length - (tessellation + 1) * 3 + 1];\r\n                    ringNormal.z = normals[normals.length - (tessellation + 1) * 3 + 2];\r\n                }\r\n                else {\r\n                    ringNormal.x = ringVertex.x;\r\n                    ringNormal.z = ringVertex.z;\r\n                    ringNormal.y = Math.sqrt(ringNormal.x * ringNormal.x + ringNormal.z * ringNormal.z) * tan;\r\n                    ringNormal.normalize();\r\n                }\r\n                // keep first ring vertex values for enclose\r\n                if (j === 0) {\r\n                    ringFirstVertex.copyFrom(ringVertex);\r\n                    ringFirstNormal.copyFrom(ringNormal);\r\n                }\r\n                positions.push(ringVertex.x, ringVertex.y, ringVertex.z);\r\n                normals.push(ringNormal.x, ringNormal.y, ringNormal.z);\r\n                if (hasRings) {\r\n                    v = (cs !== s) ? faceUV[s].y : faceUV[s].w;\r\n                }\r\n                else {\r\n                    v = faceUV[s].y + (faceUV[s].w - faceUV[s].y) * h;\r\n                }\r\n                uvs.push(faceUV[s].x + (faceUV[s].z - faceUV[s].x) * j / tessellation, v);\r\n                if (faceColors) {\r\n                    colors.push(faceColors[s].r, faceColors[s].g, faceColors[s].b, faceColors[s].a);\r\n                }\r\n            }\r\n            // if enclose, add four vertices and their dedicated normals\r\n            if (arc !== 1 && enclose) {\r\n                positions.push(ringVertex.x, ringVertex.y, ringVertex.z);\r\n                positions.push(0, ringVertex.y, 0);\r\n                positions.push(0, ringVertex.y, 0);\r\n                positions.push(ringFirstVertex.x, ringFirstVertex.y, ringFirstVertex.z);\r\n                _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"].CrossToRef(Y, ringNormal, quadNormal);\r\n                quadNormal.normalize();\r\n                normals.push(quadNormal.x, quadNormal.y, quadNormal.z, quadNormal.x, quadNormal.y, quadNormal.z);\r\n                _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"].CrossToRef(ringFirstNormal, Y, quadNormal);\r\n                quadNormal.normalize();\r\n                normals.push(quadNormal.x, quadNormal.y, quadNormal.z, quadNormal.x, quadNormal.y, quadNormal.z);\r\n                if (hasRings) {\r\n                    v = (cs !== s) ? faceUV[s + 1].y : faceUV[s + 1].w;\r\n                }\r\n                else {\r\n                    v = faceUV[s + 1].y + (faceUV[s + 1].w - faceUV[s + 1].y) * h;\r\n                }\r\n                uvs.push(faceUV[s + 1].x, v);\r\n                uvs.push(faceUV[s + 1].z, v);\r\n                if (hasRings) {\r\n                    v = (cs !== s) ? faceUV[s + 2].y : faceUV[s + 2].w;\r\n                }\r\n                else {\r\n                    v = faceUV[s + 2].y + (faceUV[s + 2].w - faceUV[s + 2].y) * h;\r\n                }\r\n                uvs.push(faceUV[s + 2].x, v);\r\n                uvs.push(faceUV[s + 2].z, v);\r\n                if (faceColors) {\r\n                    colors.push(faceColors[s + 1].r, faceColors[s + 1].g, faceColors[s + 1].b, faceColors[s + 1].a);\r\n                    colors.push(faceColors[s + 1].r, faceColors[s + 1].g, faceColors[s + 1].b, faceColors[s + 1].a);\r\n                    colors.push(faceColors[s + 2].r, faceColors[s + 2].g, faceColors[s + 2].b, faceColors[s + 2].a);\r\n                    colors.push(faceColors[s + 2].r, faceColors[s + 2].g, faceColors[s + 2].b, faceColors[s + 2].a);\r\n                }\r\n            }\r\n            if (cs !== s) {\r\n                cs = s;\r\n            }\r\n        }\r\n    }\r\n    // indices\r\n    var e = (arc !== 1 && enclose) ? tessellation + 4 : tessellation; // correction of number of iteration if enclose\r\n    var s;\r\n    i = 0;\r\n    for (s = 0; s < subdivisions; s++) {\r\n        var i0 = 0;\r\n        var i1 = 0;\r\n        var i2 = 0;\r\n        var i3 = 0;\r\n        for (j = 0; j < tessellation; j++) {\r\n            i0 = i * (e + 1) + j;\r\n            i1 = (i + 1) * (e + 1) + j;\r\n            i2 = i * (e + 1) + (j + 1);\r\n            i3 = (i + 1) * (e + 1) + (j + 1);\r\n            indices.push(i0, i1, i2);\r\n            indices.push(i3, i2, i1);\r\n        }\r\n        if (arc !== 1 && enclose) { // if enclose, add two quads\r\n            indices.push(i0 + 2, i1 + 2, i2 + 2);\r\n            indices.push(i3 + 2, i2 + 2, i1 + 2);\r\n            indices.push(i0 + 4, i1 + 4, i2 + 4);\r\n            indices.push(i3 + 4, i2 + 4, i1 + 4);\r\n        }\r\n        i = (hasRings) ? (i + 2) : (i + 1);\r\n    }\r\n    // Caps\r\n    var createCylinderCap = function (isTop) {\r\n        var radius = isTop ? diameterTop / 2 : diameterBottom / 2;\r\n        if (radius === 0) {\r\n            return;\r\n        }\r\n        // Cap positions, normals & uvs\r\n        var angle;\r\n        var circleVector;\r\n        var i;\r\n        var u = (isTop) ? faceUV[surfaceNb - 1] : faceUV[0];\r\n        var c = null;\r\n        if (faceColors) {\r\n            c = (isTop) ? faceColors[surfaceNb - 1] : faceColors[0];\r\n        }\r\n        // cap center\r\n        var vbase = positions.length / 3;\r\n        var offset = isTop ? height / 2 : -height / 2;\r\n        var center = new _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0, offset, 0);\r\n        positions.push(center.x, center.y, center.z);\r\n        normals.push(0, isTop ? 1 : -1, 0);\r\n        uvs.push(u.x + (u.z - u.x) * 0.5, u.y + (u.w - u.y) * 0.5);\r\n        if (c) {\r\n            colors.push(c.r, c.g, c.b, c.a);\r\n        }\r\n        var textureScale = new _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector2\"](0.5, 0.5);\r\n        for (i = 0; i <= tessellation; i++) {\r\n            angle = Math.PI * 2 * i * arc / tessellation;\r\n            var cos = Math.cos(-angle);\r\n            var sin = Math.sin(-angle);\r\n            circleVector = new _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](cos * radius, offset, sin * radius);\r\n            var textureCoordinate = new _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector2\"](cos * textureScale.x + 0.5, sin * textureScale.y + 0.5);\r\n            positions.push(circleVector.x, circleVector.y, circleVector.z);\r\n            normals.push(0, isTop ? 1 : -1, 0);\r\n            uvs.push(u.x + (u.z - u.x) * textureCoordinate.x, u.y + (u.w - u.y) * textureCoordinate.y);\r\n            if (c) {\r\n                colors.push(c.r, c.g, c.b, c.a);\r\n            }\r\n        }\r\n        // Cap indices\r\n        for (i = 0; i < tessellation; i++) {\r\n            if (!isTop) {\r\n                indices.push(vbase);\r\n                indices.push(vbase + (i + 1));\r\n                indices.push(vbase + (i + 2));\r\n            }\r\n            else {\r\n                indices.push(vbase);\r\n                indices.push(vbase + (i + 2));\r\n                indices.push(vbase + (i + 1));\r\n            }\r\n        }\r\n    };\r\n    // add caps to geometry\r\n    createCylinderCap(false);\r\n    createCylinderCap(true);\r\n    // Sides\r\n    _mesh_vertexData__WEBPACK_IMPORTED_MODULE_2__[\"VertexData\"]._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\r\n    var vertexData = new _mesh_vertexData__WEBPACK_IMPORTED_MODULE_2__[\"VertexData\"]();\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n    if (faceColors) {\r\n        vertexData.colors = colors;\r\n    }\r\n    return vertexData;\r\n};\r\n_mesh__WEBPACK_IMPORTED_MODULE_1__[\"Mesh\"].CreateCylinder = function (name, height, diameterTop, diameterBottom, tessellation, subdivisions, scene, updatable, sideOrientation) {\r\n    if (scene === undefined || !(scene instanceof _scene__WEBPACK_IMPORTED_MODULE_3__[\"Scene\"])) {\r\n        if (scene !== undefined) {\r\n            sideOrientation = updatable || _mesh__WEBPACK_IMPORTED_MODULE_1__[\"Mesh\"].DEFAULTSIDE;\r\n            updatable = scene;\r\n        }\r\n        scene = subdivisions;\r\n        subdivisions = 1;\r\n    }\r\n    var options = {\r\n        height: height,\r\n        diameterTop: diameterTop,\r\n        diameterBottom: diameterBottom,\r\n        tessellation: tessellation,\r\n        subdivisions: subdivisions,\r\n        sideOrientation: sideOrientation,\r\n        updatable: updatable\r\n    };\r\n    return CylinderBuilder.CreateCylinder(name, options, scene);\r\n};\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n */\r\nvar CylinderBuilder = /** @class */ (function () {\r\n    function CylinderBuilder() {\r\n    }\r\n    /**\r\n     * Creates a cylinder or a cone mesh\r\n     * * The parameter `height` sets the height size (float) of the cylinder/cone (float, default 2).\r\n     * * The parameter `diameter` sets the diameter of the top and bottom cap at once (float, default 1).\r\n     * * The parameters `diameterTop` and `diameterBottom` overwrite the parameter `diameter` and set respectively the top cap and bottom cap diameter (floats, default 1). The parameter \"diameterBottom\" can't be zero.\r\n     * * The parameter `tessellation` sets the number of cylinder sides (positive integer, default 24). Set it to 3 to get a prism for instance.\r\n     * * The parameter `subdivisions` sets the number of rings along the cylinder height (positive integer, default 1).\r\n     * * The parameter `hasRings` (boolean, default false) makes the subdivisions independent from each other, so they become different faces.\r\n     * * The parameter `enclose`  (boolean, default false) adds two extra faces per subdivision to a sliced cylinder to close it around its height axis.\r\n     * * The parameter `arc` (float, default 1) is the ratio (max 1) to apply to the circumference to slice the cylinder.\r\n     * * You can set different colors and different images to each box side by using the parameters `faceColors` (an array of n Color3 elements) and `faceUV` (an array of n Vector4 elements).\r\n     * * The value of n is the number of cylinder faces. If the cylinder has only 1 subdivisions, n equals : top face + cylinder surface + bottom face = 3\r\n     * * Now, if the cylinder has 5 independent subdivisions (hasRings = true), n equals : top face + 5 stripe surfaces + bottom face = 2 + 5 = 7\r\n     * * Finally, if the cylinder has 5 independent subdivisions and is enclose, n equals : top face + 5 x (stripe surface + 2 closing faces) + bottom face = 2 + 5 * 3 = 17\r\n     * * Each array (color or UVs) is always ordered the same way : the first element is the bottom cap, the last element is the top cap. The other elements are each a ring surface.\r\n     * * If `enclose` is false, a ring surface is one element.\r\n     * * If `enclose` is true, a ring surface is 3 successive elements in the array : the tubular surface, then the two closing faces.\r\n     * * Example how to set colors and textures on a sliced cylinder : https://www.html5gamedevs.com/topic/17945-creating-a-closed-slice-of-a-cylinder/#comment-106379\r\n     * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n     * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\r\n     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\r\n     * @param name defines the name of the mesh\r\n     * @param options defines the options used to create the mesh\r\n     * @param scene defines the hosting scene\r\n     * @returns the cylinder mesh\r\n     * @see https://doc.babylonjs.com/how_to/set_shapes#cylinder-or-cone\r\n     */\r\n    CylinderBuilder.CreateCylinder = function (name, options, scene) {\r\n        var cylinder = new _mesh__WEBPACK_IMPORTED_MODULE_1__[\"Mesh\"](name, scene);\r\n        options.sideOrientation = _mesh__WEBPACK_IMPORTED_MODULE_1__[\"Mesh\"]._GetDefaultSideOrientation(options.sideOrientation);\r\n        cylinder._originalBuilderSideOrientation = options.sideOrientation;\r\n        var vertexData = _mesh_vertexData__WEBPACK_IMPORTED_MODULE_2__[\"VertexData\"].CreateCylinder(options);\r\n        vertexData.applyToMesh(cylinder, options.updatable);\r\n        return cylinder;\r\n    };\r\n    return CylinderBuilder;\r\n}());\r\n\r\n//# sourceMappingURL=cylinderBuilder.js.map\n\n//# sourceURL=webpack:///./node_modules/@babylonjs/core/Meshes/Builders/cylinderBuilder.js?");

/***/ }),

/***/ "./node_modules/@babylonjs/core/Meshes/Builders/decalBuilder.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Meshes/Builders/decalBuilder.js ***!
  \**********************************************************************/
/*! exports provided: DecalBuilder */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DecalBuilder\", function() { return DecalBuilder; });\n/* harmony import */ var _Maths_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Maths/math */ \"./node_modules/@babylonjs/core/Maths/math.js\");\n/* harmony import */ var _mesh__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../mesh */ \"./node_modules/@babylonjs/core/Meshes/mesh.js\");\n/* harmony import */ var _buffer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../buffer */ \"./node_modules/@babylonjs/core/Meshes/buffer.js\");\n/* harmony import */ var _mesh_vertexData__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../mesh.vertexData */ \"./node_modules/@babylonjs/core/Meshes/mesh.vertexData.js\");\n\r\n\r\n\r\n\r\n_mesh__WEBPACK_IMPORTED_MODULE_1__[\"Mesh\"].CreateDecal = function (name, sourceMesh, position, normal, size, angle) {\r\n    var options = {\r\n        position: position,\r\n        normal: normal,\r\n        size: size,\r\n        angle: angle\r\n    };\r\n    return DecalBuilder.CreateDecal(name, sourceMesh, options);\r\n};\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n */\r\nvar DecalBuilder = /** @class */ (function () {\r\n    function DecalBuilder() {\r\n    }\r\n    /**\r\n     * Creates a decal mesh.\r\n     * A decal is a mesh usually applied as a model onto the surface of another mesh. So don't forget the parameter `sourceMesh` depicting the decal\r\n     * * The parameter `position` (Vector3, default `(0, 0, 0)`) sets the position of the decal in World coordinates\r\n     * * The parameter `normal` (Vector3, default `Vector3.Up`) sets the normal of the mesh where the decal is applied onto in World coordinates\r\n     * * The parameter `size` (Vector3, default `(1, 1, 1)`) sets the decal scaling\r\n     * * The parameter `angle` (float in radian, default 0) sets the angle to rotate the decal\r\n     * @param name defines the name of the mesh\r\n     * @param sourceMesh defines the mesh where the decal must be applied\r\n     * @param options defines the options used to create the mesh\r\n     * @param scene defines the hosting scene\r\n     * @returns the decal mesh\r\n     * @see https://doc.babylonjs.com/how_to/decals\r\n     */\r\n    DecalBuilder.CreateDecal = function (name, sourceMesh, options) {\r\n        var indices = sourceMesh.getIndices();\r\n        var positions = sourceMesh.getVerticesData(_buffer__WEBPACK_IMPORTED_MODULE_2__[\"VertexBuffer\"].PositionKind);\r\n        var normals = sourceMesh.getVerticesData(_buffer__WEBPACK_IMPORTED_MODULE_2__[\"VertexBuffer\"].NormalKind);\r\n        var position = options.position || _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"].Zero();\r\n        var normal = options.normal || _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"].Up();\r\n        var size = options.size || _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"].One();\r\n        var angle = options.angle || 0;\r\n        // Getting correct rotation\r\n        if (!normal) {\r\n            var target = new _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0, 0, 1);\r\n            var camera = sourceMesh.getScene().activeCamera;\r\n            var cameraWorldTarget = _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"].TransformCoordinates(target, camera.getWorldMatrix());\r\n            normal = camera.globalPosition.subtract(cameraWorldTarget);\r\n        }\r\n        var yaw = -Math.atan2(normal.z, normal.x) - Math.PI / 2;\r\n        var len = Math.sqrt(normal.x * normal.x + normal.z * normal.z);\r\n        var pitch = Math.atan2(normal.y, len);\r\n        // Matrix\r\n        var decalWorldMatrix = _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Matrix\"].RotationYawPitchRoll(yaw, pitch, angle).multiply(_Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Matrix\"].Translation(position.x, position.y, position.z));\r\n        var inverseDecalWorldMatrix = _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Matrix\"].Invert(decalWorldMatrix);\r\n        var meshWorldMatrix = sourceMesh.getWorldMatrix();\r\n        var transformMatrix = meshWorldMatrix.multiply(inverseDecalWorldMatrix);\r\n        var vertexData = new _mesh_vertexData__WEBPACK_IMPORTED_MODULE_3__[\"VertexData\"]();\r\n        vertexData.indices = [];\r\n        vertexData.positions = [];\r\n        vertexData.normals = [];\r\n        vertexData.uvs = [];\r\n        var currentVertexDataIndex = 0;\r\n        var extractDecalVector3 = function (indexId) {\r\n            var result = new _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"PositionNormalVertex\"]();\r\n            if (!indices || !positions || !normals) {\r\n                return result;\r\n            }\r\n            var vertexId = indices[indexId];\r\n            result.position = new _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](positions[vertexId * 3], positions[vertexId * 3 + 1], positions[vertexId * 3 + 2]);\r\n            // Send vector to decal local world\r\n            result.position = _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"].TransformCoordinates(result.position, transformMatrix);\r\n            // Get normal\r\n            result.normal = new _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](normals[vertexId * 3], normals[vertexId * 3 + 1], normals[vertexId * 3 + 2]);\r\n            result.normal = _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"].TransformNormal(result.normal, transformMatrix);\r\n            return result;\r\n        }; // Inspired by https://github.com/mrdoob/three.js/blob/eee231960882f6f3b6113405f524956145148146/examples/js/geometries/DecalGeometry.js\r\n        var clip = function (vertices, axis) {\r\n            if (vertices.length === 0) {\r\n                return vertices;\r\n            }\r\n            var clipSize = 0.5 * Math.abs(_Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"].Dot(size, axis));\r\n            var clipVertices = function (v0, v1) {\r\n                var clipFactor = _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"].GetClipFactor(v0.position, v1.position, axis, clipSize);\r\n                return new _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"PositionNormalVertex\"](_Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"].Lerp(v0.position, v1.position, clipFactor), _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"].Lerp(v0.normal, v1.normal, clipFactor));\r\n            };\r\n            var result = new Array();\r\n            for (var index = 0; index < vertices.length; index += 3) {\r\n                var v1Out;\r\n                var v2Out;\r\n                var v3Out;\r\n                var total = 0;\r\n                var nV1 = null;\r\n                var nV2 = null;\r\n                var nV3 = null;\r\n                var nV4 = null;\r\n                var d1 = _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"].Dot(vertices[index].position, axis) - clipSize;\r\n                var d2 = _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"].Dot(vertices[index + 1].position, axis) - clipSize;\r\n                var d3 = _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"].Dot(vertices[index + 2].position, axis) - clipSize;\r\n                v1Out = d1 > 0;\r\n                v2Out = d2 > 0;\r\n                v3Out = d3 > 0;\r\n                total = (v1Out ? 1 : 0) + (v2Out ? 1 : 0) + (v3Out ? 1 : 0);\r\n                switch (total) {\r\n                    case 0:\r\n                        result.push(vertices[index]);\r\n                        result.push(vertices[index + 1]);\r\n                        result.push(vertices[index + 2]);\r\n                        break;\r\n                    case 1:\r\n                        if (v1Out) {\r\n                            nV1 = vertices[index + 1];\r\n                            nV2 = vertices[index + 2];\r\n                            nV3 = clipVertices(vertices[index], nV1);\r\n                            nV4 = clipVertices(vertices[index], nV2);\r\n                        }\r\n                        if (v2Out) {\r\n                            nV1 = vertices[index];\r\n                            nV2 = vertices[index + 2];\r\n                            nV3 = clipVertices(vertices[index + 1], nV1);\r\n                            nV4 = clipVertices(vertices[index + 1], nV2);\r\n                            result.push(nV3);\r\n                            result.push(nV2.clone());\r\n                            result.push(nV1.clone());\r\n                            result.push(nV2.clone());\r\n                            result.push(nV3.clone());\r\n                            result.push(nV4);\r\n                            break;\r\n                        }\r\n                        if (v3Out) {\r\n                            nV1 = vertices[index];\r\n                            nV2 = vertices[index + 1];\r\n                            nV3 = clipVertices(vertices[index + 2], nV1);\r\n                            nV4 = clipVertices(vertices[index + 2], nV2);\r\n                        }\r\n                        if (nV1 && nV2 && nV3 && nV4) {\r\n                            result.push(nV1.clone());\r\n                            result.push(nV2.clone());\r\n                            result.push(nV3);\r\n                            result.push(nV4);\r\n                            result.push(nV3.clone());\r\n                            result.push(nV2.clone());\r\n                        }\r\n                        break;\r\n                    case 2:\r\n                        if (!v1Out) {\r\n                            nV1 = vertices[index].clone();\r\n                            nV2 = clipVertices(nV1, vertices[index + 1]);\r\n                            nV3 = clipVertices(nV1, vertices[index + 2]);\r\n                            result.push(nV1);\r\n                            result.push(nV2);\r\n                            result.push(nV3);\r\n                        }\r\n                        if (!v2Out) {\r\n                            nV1 = vertices[index + 1].clone();\r\n                            nV2 = clipVertices(nV1, vertices[index + 2]);\r\n                            nV3 = clipVertices(nV1, vertices[index]);\r\n                            result.push(nV1);\r\n                            result.push(nV2);\r\n                            result.push(nV3);\r\n                        }\r\n                        if (!v3Out) {\r\n                            nV1 = vertices[index + 2].clone();\r\n                            nV2 = clipVertices(nV1, vertices[index]);\r\n                            nV3 = clipVertices(nV1, vertices[index + 1]);\r\n                            result.push(nV1);\r\n                            result.push(nV2);\r\n                            result.push(nV3);\r\n                        }\r\n                        break;\r\n                    case 3:\r\n                        break;\r\n                }\r\n            }\r\n            return result;\r\n        };\r\n        for (var index = 0; index < indices.length; index += 3) {\r\n            var faceVertices = new Array();\r\n            faceVertices.push(extractDecalVector3(index));\r\n            faceVertices.push(extractDecalVector3(index + 1));\r\n            faceVertices.push(extractDecalVector3(index + 2));\r\n            // Clip\r\n            faceVertices = clip(faceVertices, new _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](1, 0, 0));\r\n            faceVertices = clip(faceVertices, new _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](-1, 0, 0));\r\n            faceVertices = clip(faceVertices, new _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0, 1, 0));\r\n            faceVertices = clip(faceVertices, new _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0, -1, 0));\r\n            faceVertices = clip(faceVertices, new _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0, 0, 1));\r\n            faceVertices = clip(faceVertices, new _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0, 0, -1));\r\n            if (faceVertices.length === 0) {\r\n                continue;\r\n            }\r\n            // Add UVs and get back to world\r\n            for (var vIndex = 0; vIndex < faceVertices.length; vIndex++) {\r\n                var vertex = faceVertices[vIndex];\r\n                //TODO check for Int32Array | Uint32Array | Uint16Array\r\n                vertexData.indices.push(currentVertexDataIndex);\r\n                vertex.position.toArray(vertexData.positions, currentVertexDataIndex * 3);\r\n                vertex.normal.toArray(vertexData.normals, currentVertexDataIndex * 3);\r\n                vertexData.uvs.push(0.5 + vertex.position.x / size.x);\r\n                vertexData.uvs.push(0.5 + vertex.position.y / size.y);\r\n                currentVertexDataIndex++;\r\n            }\r\n        }\r\n        // Return mesh\r\n        var decal = new _mesh__WEBPACK_IMPORTED_MODULE_1__[\"Mesh\"](name, sourceMesh.getScene());\r\n        vertexData.applyToMesh(decal);\r\n        decal.position = position.clone();\r\n        decal.rotation = new _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](pitch, yaw, angle);\r\n        return decal;\r\n    };\r\n    return DecalBuilder;\r\n}());\r\n\r\n//# sourceMappingURL=decalBuilder.js.map\n\n//# sourceURL=webpack:///./node_modules/@babylonjs/core/Meshes/Builders/decalBuilder.js?");

/***/ }),

/***/ "./node_modules/@babylonjs/core/Meshes/Builders/discBuilder.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Meshes/Builders/discBuilder.js ***!
  \*********************************************************************/
/*! exports provided: DiscBuilder */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DiscBuilder\", function() { return DiscBuilder; });\n/* harmony import */ var _mesh__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../mesh */ \"./node_modules/@babylonjs/core/Meshes/mesh.js\");\n/* harmony import */ var _mesh_vertexData__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../mesh.vertexData */ \"./node_modules/@babylonjs/core/Meshes/mesh.vertexData.js\");\n\r\n\r\n_mesh_vertexData__WEBPACK_IMPORTED_MODULE_1__[\"VertexData\"].CreateDisc = function (options) {\r\n    var positions = new Array();\r\n    var indices = new Array();\r\n    var normals = new Array();\r\n    var uvs = new Array();\r\n    var radius = options.radius || 0.5;\r\n    var tessellation = options.tessellation || 64;\r\n    var arc = options.arc && (options.arc <= 0 || options.arc > 1) ? 1.0 : options.arc || 1.0;\r\n    var sideOrientation = (options.sideOrientation === 0) ? 0 : options.sideOrientation || _mesh_vertexData__WEBPACK_IMPORTED_MODULE_1__[\"VertexData\"].DEFAULTSIDE;\r\n    // positions and uvs\r\n    positions.push(0, 0, 0); // disc center first\r\n    uvs.push(0.5, 0.5);\r\n    var theta = Math.PI * 2 * arc;\r\n    var step = theta / tessellation;\r\n    for (var a = 0; a < theta; a += step) {\r\n        var x = Math.cos(a);\r\n        var y = Math.sin(a);\r\n        var u = (x + 1) / 2;\r\n        var v = (1 - y) / 2;\r\n        positions.push(radius * x, radius * y, 0);\r\n        uvs.push(u, v);\r\n    }\r\n    if (arc === 1) {\r\n        positions.push(positions[3], positions[4], positions[5]); // close the circle\r\n        uvs.push(uvs[2], uvs[3]);\r\n    }\r\n    //indices\r\n    var vertexNb = positions.length / 3;\r\n    for (var i = 1; i < vertexNb - 1; i++) {\r\n        indices.push(i + 1, 0, i);\r\n    }\r\n    // result\r\n    _mesh_vertexData__WEBPACK_IMPORTED_MODULE_1__[\"VertexData\"].ComputeNormals(positions, indices, normals);\r\n    _mesh_vertexData__WEBPACK_IMPORTED_MODULE_1__[\"VertexData\"]._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\r\n    var vertexData = new _mesh_vertexData__WEBPACK_IMPORTED_MODULE_1__[\"VertexData\"]();\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n    return vertexData;\r\n};\r\n_mesh__WEBPACK_IMPORTED_MODULE_0__[\"Mesh\"].CreateDisc = function (name, radius, tessellation, scene, updatable, sideOrientation) {\r\n    if (scene === void 0) { scene = null; }\r\n    var options = {\r\n        radius: radius,\r\n        tessellation: tessellation,\r\n        sideOrientation: sideOrientation,\r\n        updatable: updatable\r\n    };\r\n    return DiscBuilder.CreateDisc(name, options, scene);\r\n};\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n */\r\nvar DiscBuilder = /** @class */ (function () {\r\n    function DiscBuilder() {\r\n    }\r\n    /**\r\n     * Creates a plane polygonal mesh.  By default, this is a disc\r\n     * * The parameter `radius` sets the radius size (float) of the polygon (default 0.5)\r\n     * * The parameter `tessellation` sets the number of polygon sides (positive integer, default 64). So a tessellation valued to 3 will build a triangle, to 4 a square, etc\r\n     * * You can create an unclosed polygon with the parameter `arc` (positive float, default 1), valued between 0 and 1, what is the ratio of the circumference : 2 x PI x ratio\r\n     * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n     * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\r\n     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n     * @param name defines the name of the mesh\r\n     * @param options defines the options used to create the mesh\r\n     * @param scene defines the hosting scene\r\n     * @returns the plane polygonal mesh\r\n     * @see https://doc.babylonjs.com/how_to/set_shapes#disc-or-regular-polygon\r\n     */\r\n    DiscBuilder.CreateDisc = function (name, options, scene) {\r\n        if (scene === void 0) { scene = null; }\r\n        var disc = new _mesh__WEBPACK_IMPORTED_MODULE_0__[\"Mesh\"](name, scene);\r\n        options.sideOrientation = _mesh__WEBPACK_IMPORTED_MODULE_0__[\"Mesh\"]._GetDefaultSideOrientation(options.sideOrientation);\r\n        disc._originalBuilderSideOrientation = options.sideOrientation;\r\n        var vertexData = _mesh_vertexData__WEBPACK_IMPORTED_MODULE_1__[\"VertexData\"].CreateDisc(options);\r\n        vertexData.applyToMesh(disc, options.updatable);\r\n        return disc;\r\n    };\r\n    return DiscBuilder;\r\n}());\r\n\r\n//# sourceMappingURL=discBuilder.js.map\n\n//# sourceURL=webpack:///./node_modules/@babylonjs/core/Meshes/Builders/discBuilder.js?");

/***/ }),

/***/ "./node_modules/@babylonjs/core/Meshes/Builders/groundBuilder.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Meshes/Builders/groundBuilder.js ***!
  \***********************************************************************/
/*! exports provided: GroundBuilder */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GroundBuilder\", function() { return GroundBuilder; });\n/* harmony import */ var _Maths_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Maths/math */ \"./node_modules/@babylonjs/core/Maths/math.js\");\n/* harmony import */ var _mesh__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../mesh */ \"./node_modules/@babylonjs/core/Meshes/mesh.js\");\n/* harmony import */ var _mesh_vertexData__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../mesh.vertexData */ \"./node_modules/@babylonjs/core/Meshes/mesh.vertexData.js\");\n/* harmony import */ var _groundMesh__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../groundMesh */ \"./node_modules/@babylonjs/core/Meshes/groundMesh.js\");\n/* harmony import */ var _Misc_tools__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../Misc/tools */ \"./node_modules/@babylonjs/core/Misc/tools.js\");\n/* harmony import */ var _Engines_engineStore__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../Engines/engineStore */ \"./node_modules/@babylonjs/core/Engines/engineStore.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n_mesh_vertexData__WEBPACK_IMPORTED_MODULE_2__[\"VertexData\"].CreateGround = function (options) {\r\n    var indices = [];\r\n    var positions = [];\r\n    var normals = [];\r\n    var uvs = [];\r\n    var row, col;\r\n    var width = options.width || 1;\r\n    var height = options.height || 1;\r\n    var subdivisionsX = options.subdivisionsX || options.subdivisions || 1;\r\n    var subdivisionsY = options.subdivisionsY || options.subdivisions || 1;\r\n    for (row = 0; row <= subdivisionsY; row++) {\r\n        for (col = 0; col <= subdivisionsX; col++) {\r\n            var position = new _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"]((col * width) / subdivisionsX - (width / 2.0), 0, ((subdivisionsY - row) * height) / subdivisionsY - (height / 2.0));\r\n            var normal = new _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0, 1.0, 0);\r\n            positions.push(position.x, position.y, position.z);\r\n            normals.push(normal.x, normal.y, normal.z);\r\n            uvs.push(col / subdivisionsX, 1.0 - row / subdivisionsY);\r\n        }\r\n    }\r\n    for (row = 0; row < subdivisionsY; row++) {\r\n        for (col = 0; col < subdivisionsX; col++) {\r\n            indices.push(col + 1 + (row + 1) * (subdivisionsX + 1));\r\n            indices.push(col + 1 + row * (subdivisionsX + 1));\r\n            indices.push(col + row * (subdivisionsX + 1));\r\n            indices.push(col + (row + 1) * (subdivisionsX + 1));\r\n            indices.push(col + 1 + (row + 1) * (subdivisionsX + 1));\r\n            indices.push(col + row * (subdivisionsX + 1));\r\n        }\r\n    }\r\n    // Result\r\n    var vertexData = new _mesh_vertexData__WEBPACK_IMPORTED_MODULE_2__[\"VertexData\"]();\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n    return vertexData;\r\n};\r\n_mesh_vertexData__WEBPACK_IMPORTED_MODULE_2__[\"VertexData\"].CreateTiledGround = function (options) {\r\n    var xmin = (options.xmin !== undefined && options.xmin !== null) ? options.xmin : -1.0;\r\n    var zmin = (options.zmin !== undefined && options.zmin !== null) ? options.zmin : -1.0;\r\n    var xmax = (options.xmax !== undefined && options.xmax !== null) ? options.xmax : 1.0;\r\n    var zmax = (options.zmax !== undefined && options.zmax !== null) ? options.zmax : 1.0;\r\n    var subdivisions = options.subdivisions || { w: 1, h: 1 };\r\n    var precision = options.precision || { w: 1, h: 1 };\r\n    var indices = new Array();\r\n    var positions = new Array();\r\n    var normals = new Array();\r\n    var uvs = new Array();\r\n    var row, col, tileRow, tileCol;\r\n    subdivisions.h = (subdivisions.h < 1) ? 1 : subdivisions.h;\r\n    subdivisions.w = (subdivisions.w < 1) ? 1 : subdivisions.w;\r\n    precision.w = (precision.w < 1) ? 1 : precision.w;\r\n    precision.h = (precision.h < 1) ? 1 : precision.h;\r\n    var tileSize = {\r\n        'w': (xmax - xmin) / subdivisions.w,\r\n        'h': (zmax - zmin) / subdivisions.h\r\n    };\r\n    function applyTile(xTileMin, zTileMin, xTileMax, zTileMax) {\r\n        // Indices\r\n        var base = positions.length / 3;\r\n        var rowLength = precision.w + 1;\r\n        for (row = 0; row < precision.h; row++) {\r\n            for (col = 0; col < precision.w; col++) {\r\n                var square = [\r\n                    base + col + row * rowLength,\r\n                    base + (col + 1) + row * rowLength,\r\n                    base + (col + 1) + (row + 1) * rowLength,\r\n                    base + col + (row + 1) * rowLength\r\n                ];\r\n                indices.push(square[1]);\r\n                indices.push(square[2]);\r\n                indices.push(square[3]);\r\n                indices.push(square[0]);\r\n                indices.push(square[1]);\r\n                indices.push(square[3]);\r\n            }\r\n        }\r\n        // Position, normals and uvs\r\n        var position = _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"].Zero();\r\n        var normal = new _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0, 1.0, 0);\r\n        for (row = 0; row <= precision.h; row++) {\r\n            position.z = (row * (zTileMax - zTileMin)) / precision.h + zTileMin;\r\n            for (col = 0; col <= precision.w; col++) {\r\n                position.x = (col * (xTileMax - xTileMin)) / precision.w + xTileMin;\r\n                position.y = 0;\r\n                positions.push(position.x, position.y, position.z);\r\n                normals.push(normal.x, normal.y, normal.z);\r\n                uvs.push(col / precision.w, row / precision.h);\r\n            }\r\n        }\r\n    }\r\n    for (tileRow = 0; tileRow < subdivisions.h; tileRow++) {\r\n        for (tileCol = 0; tileCol < subdivisions.w; tileCol++) {\r\n            applyTile(xmin + tileCol * tileSize.w, zmin + tileRow * tileSize.h, xmin + (tileCol + 1) * tileSize.w, zmin + (tileRow + 1) * tileSize.h);\r\n        }\r\n    }\r\n    // Result\r\n    var vertexData = new _mesh_vertexData__WEBPACK_IMPORTED_MODULE_2__[\"VertexData\"]();\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n    return vertexData;\r\n};\r\n_mesh_vertexData__WEBPACK_IMPORTED_MODULE_2__[\"VertexData\"].CreateGroundFromHeightMap = function (options) {\r\n    var indices = [];\r\n    var positions = [];\r\n    var normals = [];\r\n    var uvs = [];\r\n    var row, col;\r\n    var filter = options.colorFilter || new _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Color3\"](0.3, 0.59, 0.11);\r\n    var alphaFilter = options.alphaFilter || 0.0;\r\n    var invert = false;\r\n    if (options.minHeight > options.maxHeight) {\r\n        invert = true;\r\n        var temp = options.maxHeight;\r\n        options.maxHeight = options.minHeight;\r\n        options.minHeight = temp;\r\n    }\r\n    // Vertices\r\n    for (row = 0; row <= options.subdivisions; row++) {\r\n        for (col = 0; col <= options.subdivisions; col++) {\r\n            var position = new _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"]((col * options.width) / options.subdivisions - (options.width / 2.0), 0, ((options.subdivisions - row) * options.height) / options.subdivisions - (options.height / 2.0));\r\n            // Compute height\r\n            var heightMapX = (((position.x + options.width / 2) / options.width) * (options.bufferWidth - 1)) | 0;\r\n            var heightMapY = ((1.0 - (position.z + options.height / 2) / options.height) * (options.bufferHeight - 1)) | 0;\r\n            var pos = (heightMapX + heightMapY * options.bufferWidth) * 4;\r\n            var r = options.buffer[pos] / 255.0;\r\n            var g = options.buffer[pos + 1] / 255.0;\r\n            var b = options.buffer[pos + 2] / 255.0;\r\n            var a = options.buffer[pos + 3] / 255.0;\r\n            if (invert) {\r\n                r = 1.0 - r;\r\n                g = 1.0 - g;\r\n                b = 1.0 - b;\r\n            }\r\n            var gradient = r * filter.r + g * filter.g + b * filter.b;\r\n            // If our alpha channel is not within our filter then we will assign a 'special' height\r\n            // Then when building the indices, we will ignore any vertex that is using the special height\r\n            if (a >= alphaFilter) {\r\n                position.y = options.minHeight + (options.maxHeight - options.minHeight) * gradient;\r\n            }\r\n            else {\r\n                position.y = options.minHeight - _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Epsilon\"]; // We can't have a height below minHeight, normally.\r\n            }\r\n            // Add  vertex\r\n            positions.push(position.x, position.y, position.z);\r\n            normals.push(0, 0, 0);\r\n            uvs.push(col / options.subdivisions, 1.0 - row / options.subdivisions);\r\n        }\r\n    }\r\n    // Indices\r\n    for (row = 0; row < options.subdivisions; row++) {\r\n        for (col = 0; col < options.subdivisions; col++) {\r\n            // Calculate Indices\r\n            var idx1 = (col + 1 + (row + 1) * (options.subdivisions + 1));\r\n            var idx2 = (col + 1 + row * (options.subdivisions + 1));\r\n            var idx3 = (col + row * (options.subdivisions + 1));\r\n            var idx4 = (col + (row + 1) * (options.subdivisions + 1));\r\n            // Check that all indices are visible (based on our special height)\r\n            // Only display the vertex if all Indices are visible\r\n            // Positions are stored x,y,z for each vertex, hence the * 3 and + 1 for height\r\n            var isVisibleIdx1 = positions[idx1 * 3 + 1] >= options.minHeight;\r\n            var isVisibleIdx2 = positions[idx2 * 3 + 1] >= options.minHeight;\r\n            var isVisibleIdx3 = positions[idx3 * 3 + 1] >= options.minHeight;\r\n            if (isVisibleIdx1 && isVisibleIdx2 && isVisibleIdx3) {\r\n                indices.push(idx1);\r\n                indices.push(idx2);\r\n                indices.push(idx3);\r\n            }\r\n            var isVisibleIdx4 = positions[idx4 * 3 + 1] >= options.minHeight;\r\n            if (isVisibleIdx4 && isVisibleIdx1 && isVisibleIdx3) {\r\n                indices.push(idx4);\r\n                indices.push(idx1);\r\n                indices.push(idx3);\r\n            }\r\n        }\r\n    }\r\n    // Normals\r\n    _mesh_vertexData__WEBPACK_IMPORTED_MODULE_2__[\"VertexData\"].ComputeNormals(positions, indices, normals);\r\n    // Result\r\n    var vertexData = new _mesh_vertexData__WEBPACK_IMPORTED_MODULE_2__[\"VertexData\"]();\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n    return vertexData;\r\n};\r\n_mesh__WEBPACK_IMPORTED_MODULE_1__[\"Mesh\"].CreateGround = function (name, width, height, subdivisions, scene, updatable) {\r\n    var options = {\r\n        width: width,\r\n        height: height,\r\n        subdivisions: subdivisions,\r\n        updatable: updatable\r\n    };\r\n    return GroundBuilder.CreateGround(name, options, scene);\r\n};\r\n_mesh__WEBPACK_IMPORTED_MODULE_1__[\"Mesh\"].CreateTiledGround = function (name, xmin, zmin, xmax, zmax, subdivisions, precision, scene, updatable) {\r\n    var options = {\r\n        xmin: xmin,\r\n        zmin: zmin,\r\n        xmax: xmax,\r\n        zmax: zmax,\r\n        subdivisions: subdivisions,\r\n        precision: precision,\r\n        updatable: updatable\r\n    };\r\n    return GroundBuilder.CreateTiledGround(name, options, scene);\r\n};\r\n_mesh__WEBPACK_IMPORTED_MODULE_1__[\"Mesh\"].CreateGroundFromHeightMap = function (name, url, width, height, subdivisions, minHeight, maxHeight, scene, updatable, onReady, alphaFilter) {\r\n    var options = {\r\n        width: width,\r\n        height: height,\r\n        subdivisions: subdivisions,\r\n        minHeight: minHeight,\r\n        maxHeight: maxHeight,\r\n        updatable: updatable,\r\n        onReady: onReady,\r\n        alphaFilter: alphaFilter\r\n    };\r\n    return GroundBuilder.CreateGroundFromHeightMap(name, url, options, scene);\r\n};\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n */\r\nvar GroundBuilder = /** @class */ (function () {\r\n    function GroundBuilder() {\r\n    }\r\n    /**\r\n     * Creates a ground mesh\r\n     * * The parameters `width` and `height` (floats, default 1) set the width and height sizes of the ground\r\n     * * The parameter `subdivisions` (positive integer) sets the number of subdivisions per side\r\n     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n     * @param name defines the name of the mesh\r\n     * @param options defines the options used to create the mesh\r\n     * @param scene defines the hosting scene\r\n     * @returns the ground mesh\r\n     * @see https://doc.babylonjs.com/how_to/set_shapes#ground\r\n     */\r\n    GroundBuilder.CreateGround = function (name, options, scene) {\r\n        var ground = new _groundMesh__WEBPACK_IMPORTED_MODULE_3__[\"GroundMesh\"](name, scene);\r\n        ground._setReady(false);\r\n        ground._subdivisionsX = options.subdivisionsX || options.subdivisions || 1;\r\n        ground._subdivisionsY = options.subdivisionsY || options.subdivisions || 1;\r\n        ground._width = options.width || 1;\r\n        ground._height = options.height || 1;\r\n        ground._maxX = ground._width / 2;\r\n        ground._maxZ = ground._height / 2;\r\n        ground._minX = -ground._maxX;\r\n        ground._minZ = -ground._maxZ;\r\n        var vertexData = _mesh_vertexData__WEBPACK_IMPORTED_MODULE_2__[\"VertexData\"].CreateGround(options);\r\n        vertexData.applyToMesh(ground, options.updatable);\r\n        ground._setReady(true);\r\n        return ground;\r\n    };\r\n    /**\r\n     * Creates a tiled ground mesh\r\n     * * The parameters `xmin` and `xmax` (floats, default -1 and 1) set the ground minimum and maximum X coordinates\r\n     * * The parameters `zmin` and `zmax` (floats, default -1 and 1) set the ground minimum and maximum Z coordinates\r\n     * * The parameter `subdivisions` is a javascript object `{w: positive integer, h: positive integer}` (default `{w: 6, h: 6}`). `w` and `h` are the numbers of subdivisions on the ground width and height. Each subdivision is called a tile\r\n     * * The parameter `precision` is a javascript object `{w: positive integer, h: positive integer}` (default `{w: 2, h: 2}`). `w` and `h` are the numbers of subdivisions on the ground width and height of each tile\r\n     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\r\n     * @param name defines the name of the mesh\r\n     * @param options defines the options used to create the mesh\r\n     * @param scene defines the hosting scene\r\n     * @returns the tiled ground mesh\r\n     * @see https://doc.babylonjs.com/how_to/set_shapes#tiled-ground\r\n     */\r\n    GroundBuilder.CreateTiledGround = function (name, options, scene) {\r\n        if (scene === void 0) { scene = null; }\r\n        var tiledGround = new _mesh__WEBPACK_IMPORTED_MODULE_1__[\"Mesh\"](name, scene);\r\n        var vertexData = _mesh_vertexData__WEBPACK_IMPORTED_MODULE_2__[\"VertexData\"].CreateTiledGround(options);\r\n        vertexData.applyToMesh(tiledGround, options.updatable);\r\n        return tiledGround;\r\n    };\r\n    /**\r\n     * Creates a ground mesh from a height map\r\n     * * The parameter `url` sets the URL of the height map image resource.\r\n     * * The parameters `width` and `height` (positive floats, default 10) set the ground width and height sizes.\r\n     * * The parameter `subdivisions` (positive integer, default 1) sets the number of subdivision per side.\r\n     * * The parameter `minHeight` (float, default 0) is the minimum altitude on the ground.\r\n     * * The parameter `maxHeight` (float, default 1) is the maximum altitude on the ground.\r\n     * * The parameter `colorFilter` (optional Color3, default (0.3, 0.59, 0.11) ) is the filter to apply to the image pixel colors to compute the height.\r\n     * * The parameter `onReady` is a javascript callback function that will be called  once the mesh is just built (the height map download can last some time).\r\n     * * The parameter `alphaFilter` will filter any data where the alpha channel is below this value, defaults 0 (all data visible)\r\n     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\r\n     * @param name defines the name of the mesh\r\n     * @param url defines the url to the height map\r\n     * @param options defines the options used to create the mesh\r\n     * @param scene defines the hosting scene\r\n     * @returns the ground mesh\r\n     * @see https://doc.babylonjs.com/babylon101/height_map\r\n     * @see https://doc.babylonjs.com/how_to/set_shapes#ground-from-a-height-map\r\n     */\r\n    GroundBuilder.CreateGroundFromHeightMap = function (name, url, options, scene) {\r\n        if (scene === void 0) { scene = null; }\r\n        var width = options.width || 10.0;\r\n        var height = options.height || 10.0;\r\n        var subdivisions = options.subdivisions || 1 | 0;\r\n        var minHeight = options.minHeight || 0.0;\r\n        var maxHeight = options.maxHeight || 1.0;\r\n        var filter = options.colorFilter || new _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Color3\"](0.3, 0.59, 0.11);\r\n        var alphaFilter = options.alphaFilter || 0.0;\r\n        var updatable = options.updatable;\r\n        var onReady = options.onReady;\r\n        scene = scene || _Engines_engineStore__WEBPACK_IMPORTED_MODULE_5__[\"EngineStore\"].LastCreatedScene;\r\n        var ground = new _groundMesh__WEBPACK_IMPORTED_MODULE_3__[\"GroundMesh\"](name, scene);\r\n        ground._subdivisionsX = subdivisions;\r\n        ground._subdivisionsY = subdivisions;\r\n        ground._width = width;\r\n        ground._height = height;\r\n        ground._maxX = ground._width / 2.0;\r\n        ground._maxZ = ground._height / 2.0;\r\n        ground._minX = -ground._maxX;\r\n        ground._minZ = -ground._maxZ;\r\n        ground._setReady(false);\r\n        var onload = function (img) {\r\n            // Getting height map data\r\n            var canvas = document.createElement(\"canvas\");\r\n            var context = canvas.getContext(\"2d\");\r\n            if (!context) {\r\n                throw new Error(\"Unable to get 2d context for CreateGroundFromHeightMap\");\r\n            }\r\n            if (scene.isDisposed) {\r\n                return;\r\n            }\r\n            var bufferWidth = img.width;\r\n            var bufferHeight = img.height;\r\n            canvas.width = bufferWidth;\r\n            canvas.height = bufferHeight;\r\n            context.drawImage(img, 0, 0);\r\n            // Create VertexData from map data\r\n            // Cast is due to wrong definition in lib.d.ts from ts 1.3 - https://github.com/Microsoft/TypeScript/issues/949\r\n            var buffer = context.getImageData(0, 0, bufferWidth, bufferHeight).data;\r\n            var vertexData = _mesh_vertexData__WEBPACK_IMPORTED_MODULE_2__[\"VertexData\"].CreateGroundFromHeightMap({\r\n                width: width, height: height,\r\n                subdivisions: subdivisions,\r\n                minHeight: minHeight, maxHeight: maxHeight, colorFilter: filter,\r\n                buffer: buffer, bufferWidth: bufferWidth, bufferHeight: bufferHeight,\r\n                alphaFilter: alphaFilter\r\n            });\r\n            vertexData.applyToMesh(ground, updatable);\r\n            //execute ready callback, if set\r\n            if (onReady) {\r\n                onReady(ground);\r\n            }\r\n            ground._setReady(true);\r\n        };\r\n        _Misc_tools__WEBPACK_IMPORTED_MODULE_4__[\"Tools\"].LoadImage(url, onload, function () { }, scene.offlineProvider);\r\n        return ground;\r\n    };\r\n    return GroundBuilder;\r\n}());\r\n\r\n//# sourceMappingURL=groundBuilder.js.map\n\n//# sourceURL=webpack:///./node_modules/@babylonjs/core/Meshes/Builders/groundBuilder.js?");

/***/ }),

/***/ "./node_modules/@babylonjs/core/Meshes/Builders/icoSphereBuilder.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Meshes/Builders/icoSphereBuilder.js ***!
  \**************************************************************************/
/*! exports provided: IcoSphereBuilder */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"IcoSphereBuilder\", function() { return IcoSphereBuilder; });\n/* harmony import */ var _Maths_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Maths/math */ \"./node_modules/@babylonjs/core/Maths/math.js\");\n/* harmony import */ var _mesh__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../mesh */ \"./node_modules/@babylonjs/core/Meshes/mesh.js\");\n/* harmony import */ var _mesh_vertexData__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../mesh.vertexData */ \"./node_modules/@babylonjs/core/Meshes/mesh.vertexData.js\");\n\r\n\r\n\r\n_mesh_vertexData__WEBPACK_IMPORTED_MODULE_2__[\"VertexData\"].CreateIcoSphere = function (options) {\r\n    var sideOrientation = options.sideOrientation || _mesh_vertexData__WEBPACK_IMPORTED_MODULE_2__[\"VertexData\"].DEFAULTSIDE;\r\n    var radius = options.radius || 1;\r\n    var flat = (options.flat === undefined) ? true : options.flat;\r\n    var subdivisions = options.subdivisions || 4;\r\n    var radiusX = options.radiusX || radius;\r\n    var radiusY = options.radiusY || radius;\r\n    var radiusZ = options.radiusZ || radius;\r\n    var t = (1 + Math.sqrt(5)) / 2;\r\n    // 12 vertex x,y,z\r\n    var ico_vertices = [\r\n        -1, t, -0, 1, t, 0, -1, -t, 0, 1, -t, 0,\r\n        0, -1, -t, 0, 1, -t, 0, -1, t, 0, 1, t,\r\n        t, 0, 1, t, 0, -1, -t, 0, 1, -t, 0, -1 // v8-11\r\n    ];\r\n    // index of 3 vertex makes a face of icopshere\r\n    var ico_indices = [\r\n        0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 12, 22, 23,\r\n        1, 5, 20, 5, 11, 4, 23, 22, 13, 22, 18, 6, 7, 1, 8,\r\n        14, 21, 4, 14, 4, 2, 16, 13, 6, 15, 6, 19, 3, 8, 9,\r\n        4, 21, 5, 13, 17, 23, 6, 13, 22, 19, 6, 18, 9, 8, 1\r\n    ];\r\n    // vertex for uv have aliased position, not for UV\r\n    var vertices_unalias_id = [\r\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,\r\n        // vertex alias\r\n        0,\r\n        2,\r\n        3,\r\n        3,\r\n        3,\r\n        4,\r\n        7,\r\n        8,\r\n        9,\r\n        9,\r\n        10,\r\n        11 // 23: B + 12\r\n    ];\r\n    // uv as integer step (not pixels !)\r\n    var ico_vertexuv = [\r\n        5, 1, 3, 1, 6, 4, 0, 0,\r\n        5, 3, 4, 2, 2, 2, 4, 0,\r\n        2, 0, 1, 1, 6, 0, 6, 2,\r\n        // vertex alias (for same vertex on different faces)\r\n        0, 4,\r\n        3, 3,\r\n        4, 4,\r\n        3, 1,\r\n        4, 2,\r\n        4, 4,\r\n        0, 2,\r\n        1, 1,\r\n        2, 2,\r\n        3, 3,\r\n        1, 3,\r\n        2, 4 // 23: B + 12\r\n    ];\r\n    // Vertices[0, 1, ...9, A, B] : position on UV plane\r\n    // '+' indicate duplicate position to be fixed (3,9:0,2,3,4,7,8,A,B)\r\n    // First island of uv mapping\r\n    // v = 4h          3+  2\r\n    // v = 3h        9+  4\r\n    // v = 2h      9+  5   B\r\n    // v = 1h    9   1   0\r\n    // v = 0h  3   8   7   A\r\n    //     u = 0 1 2 3 4 5 6  *a\r\n    // Second island of uv mapping\r\n    // v = 4h  0+  B+  4+\r\n    // v = 3h    A+  2+\r\n    // v = 2h  7+  6   3+\r\n    // v = 1h    8+  3+\r\n    // v = 0h\r\n    //     u = 0 1 2 3 4 5 6  *a\r\n    // Face layout on texture UV mapping\r\n    // ============\r\n    // \\ 4  /\\ 16 /   ======\r\n    //  \\  /  \\  /   /\\ 11 /\r\n    //   \\/ 7  \\/   /  \\  /\r\n    //    =======  / 10 \\/\r\n    //   /\\ 17 /\\  =======\r\n    //  /  \\  /  \\ \\ 15 /\\\r\n    // / 8  \\/ 12 \\ \\  /  \\\r\n    // ============  \\/ 6  \\\r\n    // \\ 18 /\\  ============\r\n    //  \\  /  \\ \\ 5  /\\ 0  /\r\n    //   \\/ 13 \\ \\  /  \\  /\r\n    //   =======  \\/ 1  \\/\r\n    //       =============\r\n    //      /\\ 19 /\\  2 /\\\r\n    //     /  \\  /  \\  /  \\\r\n    //    / 14 \\/ 9  \\/  3 \\\r\n    //   ===================\r\n    // uv step is u:1 or 0.5, v:cos(30)=sqrt(3)/2, ratio approx is 84/97\r\n    var ustep = 138 / 1024;\r\n    var vstep = 239 / 1024;\r\n    var uoffset = 60 / 1024;\r\n    var voffset = 26 / 1024;\r\n    // Second island should have margin, not to touch the first island\r\n    // avoid any borderline artefact in pixel rounding\r\n    var island_u_offset = -40 / 1024;\r\n    var island_v_offset = +20 / 1024;\r\n    // face is either island 0 or 1 :\r\n    // second island is for faces : [4, 7, 8, 12, 13, 16, 17, 18]\r\n    var island = [\r\n        0, 0, 0, 0, 1,\r\n        0, 0, 1, 1, 0,\r\n        0, 0, 1, 1, 0,\r\n        0, 1, 1, 1, 0 //  15 - 19\r\n    ];\r\n    var indices = new Array();\r\n    var positions = new Array();\r\n    var normals = new Array();\r\n    var uvs = new Array();\r\n    var current_indice = 0;\r\n    // prepare array of 3 vector (empty) (to be worked in place, shared for each face)\r\n    var face_vertex_pos = new Array(3);\r\n    var face_vertex_uv = new Array(3);\r\n    var v012;\r\n    for (v012 = 0; v012 < 3; v012++) {\r\n        face_vertex_pos[v012] = _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"].Zero();\r\n        face_vertex_uv[v012] = _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector2\"].Zero();\r\n    }\r\n    // create all with normals\r\n    for (var face = 0; face < 20; face++) {\r\n        // 3 vertex per face\r\n        for (v012 = 0; v012 < 3; v012++) {\r\n            // look up vertex 0,1,2 to its index in 0 to 11 (or 23 including alias)\r\n            var v_id = ico_indices[3 * face + v012];\r\n            // vertex have 3D position (x,y,z)\r\n            face_vertex_pos[v012].copyFromFloats(ico_vertices[3 * vertices_unalias_id[v_id]], ico_vertices[3 * vertices_unalias_id[v_id] + 1], ico_vertices[3 * vertices_unalias_id[v_id] + 2]);\r\n            // Normalize to get normal, then scale to radius\r\n            face_vertex_pos[v012].normalize().scaleInPlace(radius);\r\n            // uv Coordinates from vertex ID\r\n            face_vertex_uv[v012].copyFromFloats(ico_vertexuv[2 * v_id] * ustep + uoffset + island[face] * island_u_offset, ico_vertexuv[2 * v_id + 1] * vstep + voffset + island[face] * island_v_offset);\r\n        }\r\n        // Subdivide the face (interpolate pos, norm, uv)\r\n        // - pos is linear interpolation, then projected to sphere (converge polyhedron to sphere)\r\n        // - norm is linear interpolation of vertex corner normal\r\n        //   (to be checked if better to re-calc from face vertex, or if approximation is OK ??? )\r\n        // - uv is linear interpolation\r\n        //\r\n        // Topology is as below for sub-divide by 2\r\n        // vertex shown as v0,v1,v2\r\n        // interp index is i1 to progress in range [v0,v1[\r\n        // interp index is i2 to progress in range [v0,v2[\r\n        // face index as  (i1,i2)  for /\\  : (i1,i2),(i1+1,i2),(i1,i2+1)\r\n        //            and (i1,i2)' for \\/  : (i1+1,i2),(i1+1,i2+1),(i1,i2+1)\r\n        //\r\n        //\r\n        //                    i2    v2\r\n        //                    ^    ^\r\n        //                   /    / \\\r\n        //                  /    /   \\\r\n        //                 /    /     \\\r\n        //                /    / (0,1) \\\r\n        //               /    #---------\\\r\n        //              /    / \\ (0,0)'/ \\\r\n        //             /    /   \\     /   \\\r\n        //            /    /     \\   /     \\\r\n        //           /    / (0,0) \\ / (1,0) \\\r\n        //          /    #---------#---------\\\r\n        //              v0                    v1\r\n        //\r\n        //              --------------------> i1\r\n        //\r\n        // interp of (i1,i2):\r\n        //  along i2 :  x0=lerp(v0,v2, i2/S) <---> x1=lerp(v1,v2, i2/S)\r\n        //  along i1 :  lerp(x0,x1, i1/(S-i2))\r\n        //\r\n        // centroid of triangle is needed to get help normal computation\r\n        //  (c1,c2) are used for centroid location\r\n        var interp_vertex = function (i1, i2, c1, c2) {\r\n            // vertex is interpolated from\r\n            //   - face_vertex_pos[0..2]\r\n            //   - face_vertex_uv[0..2]\r\n            var pos_x0 = _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"].Lerp(face_vertex_pos[0], face_vertex_pos[2], i2 / subdivisions);\r\n            var pos_x1 = _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"].Lerp(face_vertex_pos[1], face_vertex_pos[2], i2 / subdivisions);\r\n            var pos_interp = (subdivisions === i2) ? face_vertex_pos[2] : _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"].Lerp(pos_x0, pos_x1, i1 / (subdivisions - i2));\r\n            pos_interp.normalize();\r\n            var vertex_normal;\r\n            if (flat) {\r\n                // in flat mode, recalculate normal as face centroid normal\r\n                var centroid_x0 = _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"].Lerp(face_vertex_pos[0], face_vertex_pos[2], c2 / subdivisions);\r\n                var centroid_x1 = _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"].Lerp(face_vertex_pos[1], face_vertex_pos[2], c2 / subdivisions);\r\n                vertex_normal = _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"].Lerp(centroid_x0, centroid_x1, c1 / (subdivisions - c2));\r\n            }\r\n            else {\r\n                // in smooth mode, recalculate normal from each single vertex position\r\n                vertex_normal = new _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](pos_interp.x, pos_interp.y, pos_interp.z);\r\n            }\r\n            // Vertex normal need correction due to X,Y,Z radius scaling\r\n            vertex_normal.x /= radiusX;\r\n            vertex_normal.y /= radiusY;\r\n            vertex_normal.z /= radiusZ;\r\n            vertex_normal.normalize();\r\n            var uv_x0 = _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector2\"].Lerp(face_vertex_uv[0], face_vertex_uv[2], i2 / subdivisions);\r\n            var uv_x1 = _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector2\"].Lerp(face_vertex_uv[1], face_vertex_uv[2], i2 / subdivisions);\r\n            var uv_interp = (subdivisions === i2) ? face_vertex_uv[2] : _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector2\"].Lerp(uv_x0, uv_x1, i1 / (subdivisions - i2));\r\n            positions.push(pos_interp.x * radiusX, pos_interp.y * radiusY, pos_interp.z * radiusZ);\r\n            normals.push(vertex_normal.x, vertex_normal.y, vertex_normal.z);\r\n            uvs.push(uv_interp.x, uv_interp.y);\r\n            // push each vertex has member of a face\r\n            // Same vertex can bleong to multiple face, it is pushed multiple time (duplicate vertex are present)\r\n            indices.push(current_indice);\r\n            current_indice++;\r\n        };\r\n        for (var i2 = 0; i2 < subdivisions; i2++) {\r\n            for (var i1 = 0; i1 + i2 < subdivisions; i1++) {\r\n                // face : (i1,i2)  for /\\  :\r\n                // interp for : (i1,i2),(i1+1,i2),(i1,i2+1)\r\n                interp_vertex(i1, i2, i1 + 1.0 / 3, i2 + 1.0 / 3);\r\n                interp_vertex(i1 + 1, i2, i1 + 1.0 / 3, i2 + 1.0 / 3);\r\n                interp_vertex(i1, i2 + 1, i1 + 1.0 / 3, i2 + 1.0 / 3);\r\n                if (i1 + i2 + 1 < subdivisions) {\r\n                    // face : (i1,i2)' for \\/  :\r\n                    // interp for (i1+1,i2),(i1+1,i2+1),(i1,i2+1)\r\n                    interp_vertex(i1 + 1, i2, i1 + 2.0 / 3, i2 + 2.0 / 3);\r\n                    interp_vertex(i1 + 1, i2 + 1, i1 + 2.0 / 3, i2 + 2.0 / 3);\r\n                    interp_vertex(i1, i2 + 1, i1 + 2.0 / 3, i2 + 2.0 / 3);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // Sides\r\n    _mesh_vertexData__WEBPACK_IMPORTED_MODULE_2__[\"VertexData\"]._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\r\n    // Result\r\n    var vertexData = new _mesh_vertexData__WEBPACK_IMPORTED_MODULE_2__[\"VertexData\"]();\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n    return vertexData;\r\n};\r\n_mesh__WEBPACK_IMPORTED_MODULE_1__[\"Mesh\"].CreateIcoSphere = function (name, options, scene) {\r\n    return IcoSphereBuilder.CreateIcoSphere(name, options, scene);\r\n};\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n */\r\nvar IcoSphereBuilder = /** @class */ (function () {\r\n    function IcoSphereBuilder() {\r\n    }\r\n    /**\r\n     * Creates a sphere based upon an icosahedron with 20 triangular faces which can be subdivided\r\n     * * The parameter `radius` sets the radius size (float) of the icosphere (default 1)\r\n     * * You can set some different icosphere dimensions, for instance to build an ellipsoid, by using the parameters `radiusX`, `radiusY` and `radiusZ` (all by default have the same value of `radius`)\r\n     * * The parameter `subdivisions` sets the number of subdivisions (postive integer, default 4). The more subdivisions, the more faces on the icosphere whatever its size\r\n     * * The parameter `flat` (boolean, default true) gives each side its own normals. Set it to false to get a smooth continuous light reflection on the surface\r\n     * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n     * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\r\n     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n     * @param name defines the name of the mesh\r\n     * @param options defines the options used to create the mesh\r\n     * @param scene defines the hosting scene\r\n     * @returns the icosahedron mesh\r\n     * @see https://doc.babylonjs.com/how_to/polyhedra_shapes#icosphere\r\n     */\r\n    IcoSphereBuilder.CreateIcoSphere = function (name, options, scene) {\r\n        if (scene === void 0) { scene = null; }\r\n        var sphere = new _mesh__WEBPACK_IMPORTED_MODULE_1__[\"Mesh\"](name, scene);\r\n        options.sideOrientation = _mesh__WEBPACK_IMPORTED_MODULE_1__[\"Mesh\"]._GetDefaultSideOrientation(options.sideOrientation);\r\n        sphere._originalBuilderSideOrientation = options.sideOrientation;\r\n        var vertexData = _mesh_vertexData__WEBPACK_IMPORTED_MODULE_2__[\"VertexData\"].CreateIcoSphere(options);\r\n        vertexData.applyToMesh(sphere, options.updatable);\r\n        return sphere;\r\n    };\r\n    return IcoSphereBuilder;\r\n}());\r\n\r\n//# sourceMappingURL=icoSphereBuilder.js.map\n\n//# sourceURL=webpack:///./node_modules/@babylonjs/core/Meshes/Builders/icoSphereBuilder.js?");

/***/ }),

/***/ "./node_modules/@babylonjs/core/Meshes/Builders/latheBuilder.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Meshes/Builders/latheBuilder.js ***!
  \**********************************************************************/
/*! exports provided: LatheBuilder */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LatheBuilder\", function() { return LatheBuilder; });\n/* harmony import */ var _Maths_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Maths/math */ \"./node_modules/@babylonjs/core/Maths/math.js\");\n/* harmony import */ var _mesh__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../mesh */ \"./node_modules/@babylonjs/core/Meshes/mesh.js\");\n/* harmony import */ var _ribbonBuilder__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ribbonBuilder */ \"./node_modules/@babylonjs/core/Meshes/Builders/ribbonBuilder.js\");\n\r\n\r\n\r\n_mesh__WEBPACK_IMPORTED_MODULE_1__[\"Mesh\"].CreateLathe = function (name, shape, radius, tessellation, scene, updatable, sideOrientation) {\r\n    var options = {\r\n        shape: shape,\r\n        radius: radius,\r\n        tessellation: tessellation,\r\n        sideOrientation: sideOrientation,\r\n        updatable: updatable\r\n    };\r\n    return LatheBuilder.CreateLathe(name, options, scene);\r\n};\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n */\r\nvar LatheBuilder = /** @class */ (function () {\r\n    function LatheBuilder() {\r\n    }\r\n    /**\r\n     * Creates lathe mesh.\r\n     * The lathe is a shape with a symetry axis : a 2D model shape is rotated around this axis to design the lathe\r\n     * * The parameter `shape` is a required array of successive Vector3. This array depicts the shape to be rotated in its local space : the shape must be designed in the xOy plane and will be rotated around the Y axis. It's usually a 2D shape, so the Vector3 z coordinates are often set to zero\r\n     * * The parameter `radius` (positive float, default 1) is the radius value of the lathe\r\n     * * The parameter `tessellation` (positive integer, default 64) is the side number of the lathe\r\n     * * The parameter `clip` (positive integer, default 0) is the number of sides to not create without effecting the general shape of the sides\r\n     * * The parameter `arc` (positive float, default 1) is the ratio of the lathe. 0.5 builds for instance half a lathe, so an opened shape\r\n     * * The parameter `closed` (boolean, default true) opens/closes the lathe circumference. This should be set to false when used with the parameter \"arc\"\r\n     * * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL\r\n     * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n     * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\r\n     * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture\r\n     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n     * @param name defines the name of the mesh\r\n     * @param options defines the options used to create the mesh\r\n     * @param scene defines the hosting scene\r\n     * @returns the lathe mesh\r\n     * @see https://doc.babylonjs.com/how_to/parametric_shapes#lathe\r\n     */\r\n    LatheBuilder.CreateLathe = function (name, options, scene) {\r\n        if (scene === void 0) { scene = null; }\r\n        var arc = options.arc ? ((options.arc <= 0 || options.arc > 1) ? 1.0 : options.arc) : 1.0;\r\n        var closed = (options.closed === undefined) ? true : options.closed;\r\n        var shape = options.shape;\r\n        var radius = options.radius || 1;\r\n        var tessellation = options.tessellation || 64;\r\n        var clip = options.clip || 0;\r\n        var updatable = options.updatable;\r\n        var sideOrientation = _mesh__WEBPACK_IMPORTED_MODULE_1__[\"Mesh\"]._GetDefaultSideOrientation(options.sideOrientation);\r\n        var cap = options.cap || _mesh__WEBPACK_IMPORTED_MODULE_1__[\"Mesh\"].NO_CAP;\r\n        var pi2 = Math.PI * 2;\r\n        var paths = new Array();\r\n        var invertUV = options.invertUV || false;\r\n        var i = 0;\r\n        var p = 0;\r\n        var step = pi2 / tessellation * arc;\r\n        var rotated;\r\n        var path = new Array();\r\n        for (i = 0; i <= tessellation - clip; i++) {\r\n            var path = [];\r\n            if (cap == _mesh__WEBPACK_IMPORTED_MODULE_1__[\"Mesh\"].CAP_START || cap == _mesh__WEBPACK_IMPORTED_MODULE_1__[\"Mesh\"].CAP_ALL) {\r\n                path.push(new _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0, shape[0].y, 0));\r\n                path.push(new _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](Math.cos(i * step) * shape[0].x * radius, shape[0].y, Math.sin(i * step) * shape[0].x * radius));\r\n            }\r\n            for (p = 0; p < shape.length; p++) {\r\n                rotated = new _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](Math.cos(i * step) * shape[p].x * radius, shape[p].y, Math.sin(i * step) * shape[p].x * radius);\r\n                path.push(rotated);\r\n            }\r\n            if (cap == _mesh__WEBPACK_IMPORTED_MODULE_1__[\"Mesh\"].CAP_END || cap == _mesh__WEBPACK_IMPORTED_MODULE_1__[\"Mesh\"].CAP_ALL) {\r\n                path.push(new _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](Math.cos(i * step) * shape[shape.length - 1].x * radius, shape[shape.length - 1].y, Math.sin(i * step) * shape[shape.length - 1].x * radius));\r\n                path.push(new _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0, shape[shape.length - 1].y, 0));\r\n            }\r\n            paths.push(path);\r\n        }\r\n        // lathe ribbon\r\n        var lathe = _ribbonBuilder__WEBPACK_IMPORTED_MODULE_2__[\"RibbonBuilder\"].CreateRibbon(name, { pathArray: paths, closeArray: closed, sideOrientation: sideOrientation, updatable: updatable, invertUV: invertUV, frontUVs: options.frontUVs, backUVs: options.backUVs }, scene);\r\n        return lathe;\r\n    };\r\n    return LatheBuilder;\r\n}());\r\n\r\n//# sourceMappingURL=latheBuilder.js.map\n\n//# sourceURL=webpack:///./node_modules/@babylonjs/core/Meshes/Builders/latheBuilder.js?");

/***/ }),

/***/ "./node_modules/@babylonjs/core/Meshes/Builders/linesBuilder.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Meshes/Builders/linesBuilder.js ***!
  \**********************************************************************/
/*! exports provided: LinesBuilder */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LinesBuilder\", function() { return LinesBuilder; });\n/* harmony import */ var _Maths_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Maths/math */ \"./node_modules/@babylonjs/core/Maths/math.js\");\n/* harmony import */ var _mesh__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../mesh */ \"./node_modules/@babylonjs/core/Meshes/mesh.js\");\n/* harmony import */ var _mesh_vertexData__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../mesh.vertexData */ \"./node_modules/@babylonjs/core/Meshes/mesh.vertexData.js\");\n/* harmony import */ var _Meshes_linesMesh__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../Meshes/linesMesh */ \"./node_modules/@babylonjs/core/Meshes/linesMesh.js\");\n/* harmony import */ var _Meshes_buffer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../Meshes/buffer */ \"./node_modules/@babylonjs/core/Meshes/buffer.js\");\n\r\n\r\n\r\n\r\n\r\n_mesh_vertexData__WEBPACK_IMPORTED_MODULE_2__[\"VertexData\"].CreateLineSystem = function (options) {\r\n    var indices = [];\r\n    var positions = [];\r\n    var lines = options.lines;\r\n    var colors = options.colors;\r\n    var vertexColors = [];\r\n    var idx = 0;\r\n    for (var l = 0; l < lines.length; l++) {\r\n        var points = lines[l];\r\n        for (var index = 0; index < points.length; index++) {\r\n            positions.push(points[index].x, points[index].y, points[index].z);\r\n            if (colors) {\r\n                var color = colors[l];\r\n                vertexColors.push(color[index].r, color[index].g, color[index].b, color[index].a);\r\n            }\r\n            if (index > 0) {\r\n                indices.push(idx - 1);\r\n                indices.push(idx);\r\n            }\r\n            idx++;\r\n        }\r\n    }\r\n    var vertexData = new _mesh_vertexData__WEBPACK_IMPORTED_MODULE_2__[\"VertexData\"]();\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    if (colors) {\r\n        vertexData.colors = vertexColors;\r\n    }\r\n    return vertexData;\r\n};\r\n_mesh_vertexData__WEBPACK_IMPORTED_MODULE_2__[\"VertexData\"].CreateDashedLines = function (options) {\r\n    var dashSize = options.dashSize || 3;\r\n    var gapSize = options.gapSize || 1;\r\n    var dashNb = options.dashNb || 200;\r\n    var points = options.points;\r\n    var positions = new Array();\r\n    var indices = new Array();\r\n    var curvect = _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"].Zero();\r\n    var lg = 0;\r\n    var nb = 0;\r\n    var shft = 0;\r\n    var dashshft = 0;\r\n    var curshft = 0;\r\n    var idx = 0;\r\n    var i = 0;\r\n    for (i = 0; i < points.length - 1; i++) {\r\n        points[i + 1].subtractToRef(points[i], curvect);\r\n        lg += curvect.length();\r\n    }\r\n    shft = lg / dashNb;\r\n    dashshft = dashSize * shft / (dashSize + gapSize);\r\n    for (i = 0; i < points.length - 1; i++) {\r\n        points[i + 1].subtractToRef(points[i], curvect);\r\n        nb = Math.floor(curvect.length() / shft);\r\n        curvect.normalize();\r\n        for (var j = 0; j < nb; j++) {\r\n            curshft = shft * j;\r\n            positions.push(points[i].x + curshft * curvect.x, points[i].y + curshft * curvect.y, points[i].z + curshft * curvect.z);\r\n            positions.push(points[i].x + (curshft + dashshft) * curvect.x, points[i].y + (curshft + dashshft) * curvect.y, points[i].z + (curshft + dashshft) * curvect.z);\r\n            indices.push(idx, idx + 1);\r\n            idx += 2;\r\n        }\r\n    }\r\n    // Result\r\n    var vertexData = new _mesh_vertexData__WEBPACK_IMPORTED_MODULE_2__[\"VertexData\"]();\r\n    vertexData.positions = positions;\r\n    vertexData.indices = indices;\r\n    return vertexData;\r\n};\r\n_mesh__WEBPACK_IMPORTED_MODULE_1__[\"Mesh\"].CreateLines = function (name, points, scene, updatable, instance) {\r\n    if (scene === void 0) { scene = null; }\r\n    if (updatable === void 0) { updatable = false; }\r\n    if (instance === void 0) { instance = null; }\r\n    var options = {\r\n        points: points,\r\n        updatable: updatable,\r\n        instance: instance\r\n    };\r\n    return LinesBuilder.CreateLines(name, options, scene);\r\n};\r\n_mesh__WEBPACK_IMPORTED_MODULE_1__[\"Mesh\"].CreateDashedLines = function (name, points, dashSize, gapSize, dashNb, scene, updatable, instance) {\r\n    if (scene === void 0) { scene = null; }\r\n    var options = {\r\n        points: points,\r\n        dashSize: dashSize,\r\n        gapSize: gapSize,\r\n        dashNb: dashNb,\r\n        updatable: updatable,\r\n        instance: instance\r\n    };\r\n    return LinesBuilder.CreateDashedLines(name, options, scene);\r\n};\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n */\r\nvar LinesBuilder = /** @class */ (function () {\r\n    function LinesBuilder() {\r\n    }\r\n    /**\r\n     * Creates a line system mesh. A line system is a pool of many lines gathered in a single mesh\r\n     * * A line system mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of lines as an input parameter\r\n     * * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineSystem to this static function\r\n     * * The parameter `lines` is an array of lines, each line being an array of successive Vector3\r\n     * * The optional parameter `instance` is an instance of an existing LineSystem object to be updated with the passed `lines` parameter\r\n     * * The optional parameter `colors` is an array of line colors, each line colors being an array of successive Color4, one per line point\r\n     * * The optional parameter `useVertexAlpha` is to be set to `false` (default `true`) when you don't need the alpha blending (faster)\r\n     * * Updating a simple Line mesh, you just need to update every line in the `lines` array : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#lines-and-dashedlines\r\n     * * When updating an instance, remember that only line point positions can change, not the number of points, neither the number of lines\r\n     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n     * @see https://doc.babylonjs.com/how_to/parametric_shapes#line-system\r\n     * @param name defines the name of the new line system\r\n     * @param options defines the options used to create the line system\r\n     * @param scene defines the hosting scene\r\n     * @returns a new line system mesh\r\n     */\r\n    LinesBuilder.CreateLineSystem = function (name, options, scene) {\r\n        var instance = options.instance;\r\n        var lines = options.lines;\r\n        var colors = options.colors;\r\n        if (instance) { // lines update\r\n            var positions = instance.getVerticesData(_Meshes_buffer__WEBPACK_IMPORTED_MODULE_4__[\"VertexBuffer\"].PositionKind);\r\n            var vertexColor;\r\n            var lineColors;\r\n            if (colors) {\r\n                vertexColor = instance.getVerticesData(_Meshes_buffer__WEBPACK_IMPORTED_MODULE_4__[\"VertexBuffer\"].ColorKind);\r\n            }\r\n            var i = 0;\r\n            var c = 0;\r\n            for (var l = 0; l < lines.length; l++) {\r\n                var points = lines[l];\r\n                for (var p = 0; p < points.length; p++) {\r\n                    positions[i] = points[p].x;\r\n                    positions[i + 1] = points[p].y;\r\n                    positions[i + 2] = points[p].z;\r\n                    if (colors && vertexColor) {\r\n                        lineColors = colors[l];\r\n                        vertexColor[c] = lineColors[p].r;\r\n                        vertexColor[c + 1] = lineColors[p].g;\r\n                        vertexColor[c + 2] = lineColors[p].b;\r\n                        vertexColor[c + 3] = lineColors[p].a;\r\n                        c += 4;\r\n                    }\r\n                    i += 3;\r\n                }\r\n            }\r\n            instance.updateVerticesData(_Meshes_buffer__WEBPACK_IMPORTED_MODULE_4__[\"VertexBuffer\"].PositionKind, positions, false, false);\r\n            if (colors && vertexColor) {\r\n                instance.updateVerticesData(_Meshes_buffer__WEBPACK_IMPORTED_MODULE_4__[\"VertexBuffer\"].ColorKind, vertexColor, false, false);\r\n            }\r\n            return instance;\r\n        }\r\n        // line system creation\r\n        var useVertexColor = (colors) ? true : false;\r\n        var lineSystem = new _Meshes_linesMesh__WEBPACK_IMPORTED_MODULE_3__[\"LinesMesh\"](name, scene, null, undefined, undefined, useVertexColor, options.useVertexAlpha);\r\n        var vertexData = _mesh_vertexData__WEBPACK_IMPORTED_MODULE_2__[\"VertexData\"].CreateLineSystem(options);\r\n        vertexData.applyToMesh(lineSystem, options.updatable);\r\n        return lineSystem;\r\n    };\r\n    /**\r\n     * Creates a line mesh\r\n     * A line mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of points as an input parameter\r\n     * * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineMesh to this static function\r\n     * * The parameter `points` is an array successive Vector3\r\n     * * The optional parameter `instance` is an instance of an existing LineMesh object to be updated with the passed `points` parameter : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#lines-and-dashedlines\r\n     * * The optional parameter `colors` is an array of successive Color4, one per line point\r\n     * * The optional parameter `useVertexAlpha` is to be set to `false` (default `true`) when you don't need alpha blending (faster)\r\n     * * When updating an instance, remember that only point positions can change, not the number of points\r\n     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n     * @see https://doc.babylonjs.com/how_to/parametric_shapes#lines\r\n     * @param name defines the name of the new line system\r\n     * @param options defines the options used to create the line system\r\n     * @param scene defines the hosting scene\r\n     * @returns a new line mesh\r\n     */\r\n    LinesBuilder.CreateLines = function (name, options, scene) {\r\n        if (scene === void 0) { scene = null; }\r\n        var colors = (options.colors) ? [options.colors] : null;\r\n        var lines = LinesBuilder.CreateLineSystem(name, { lines: [options.points], updatable: options.updatable, instance: options.instance, colors: colors, useVertexAlpha: options.useVertexAlpha }, scene);\r\n        return lines;\r\n    };\r\n    /**\r\n     * Creates a dashed line mesh\r\n     * * A dashed line mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of points as an input parameter\r\n     * * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineMesh to this static function\r\n     * * The parameter `points` is an array successive Vector3\r\n     * * The parameter `dashNb` is the intended total number of dashes (positive integer, default 200)\r\n     * * The parameter `dashSize` is the size of the dashes relatively the dash number (positive float, default 3)\r\n     * * The parameter `gapSize` is the size of the gap between two successive dashes relatively the dash number (positive float, default 1)\r\n     * * The optional parameter `instance` is an instance of an existing LineMesh object to be updated with the passed `points` parameter : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#lines-and-dashedlines\r\n     * * When updating an instance, remember that only point positions can change, not the number of points\r\n     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n     * @param name defines the name of the mesh\r\n     * @param options defines the options used to create the mesh\r\n     * @param scene defines the hosting scene\r\n     * @returns the dashed line mesh\r\n     * @see https://doc.babylonjs.com/how_to/parametric_shapes#dashed-lines\r\n     */\r\n    LinesBuilder.CreateDashedLines = function (name, options, scene) {\r\n        if (scene === void 0) { scene = null; }\r\n        var points = options.points;\r\n        var instance = options.instance;\r\n        var gapSize = options.gapSize || 1;\r\n        var dashSize = options.dashSize || 3;\r\n        if (instance) { //  dashed lines update\r\n            var positionFunction = function (positions) {\r\n                var curvect = _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"].Zero();\r\n                var nbSeg = positions.length / 6;\r\n                var lg = 0;\r\n                var nb = 0;\r\n                var shft = 0;\r\n                var dashshft = 0;\r\n                var curshft = 0;\r\n                var p = 0;\r\n                var i = 0;\r\n                var j = 0;\r\n                for (i = 0; i < points.length - 1; i++) {\r\n                    points[i + 1].subtractToRef(points[i], curvect);\r\n                    lg += curvect.length();\r\n                }\r\n                shft = lg / nbSeg;\r\n                var dashSize = instance._creationDataStorage.dashSize;\r\n                var gapSize = instance._creationDataStorage.gapSize;\r\n                dashshft = dashSize * shft / (dashSize + gapSize);\r\n                for (i = 0; i < points.length - 1; i++) {\r\n                    points[i + 1].subtractToRef(points[i], curvect);\r\n                    nb = Math.floor(curvect.length() / shft);\r\n                    curvect.normalize();\r\n                    j = 0;\r\n                    while (j < nb && p < positions.length) {\r\n                        curshft = shft * j;\r\n                        positions[p] = points[i].x + curshft * curvect.x;\r\n                        positions[p + 1] = points[i].y + curshft * curvect.y;\r\n                        positions[p + 2] = points[i].z + curshft * curvect.z;\r\n                        positions[p + 3] = points[i].x + (curshft + dashshft) * curvect.x;\r\n                        positions[p + 4] = points[i].y + (curshft + dashshft) * curvect.y;\r\n                        positions[p + 5] = points[i].z + (curshft + dashshft) * curvect.z;\r\n                        p += 6;\r\n                        j++;\r\n                    }\r\n                }\r\n                while (p < positions.length) {\r\n                    positions[p] = points[i].x;\r\n                    positions[p + 1] = points[i].y;\r\n                    positions[p + 2] = points[i].z;\r\n                    p += 3;\r\n                }\r\n            };\r\n            instance.updateMeshPositions(positionFunction, false);\r\n            return instance;\r\n        }\r\n        // dashed lines creation\r\n        var dashedLines = new _Meshes_linesMesh__WEBPACK_IMPORTED_MODULE_3__[\"LinesMesh\"](name, scene);\r\n        var vertexData = _mesh_vertexData__WEBPACK_IMPORTED_MODULE_2__[\"VertexData\"].CreateDashedLines(options);\r\n        vertexData.applyToMesh(dashedLines, options.updatable);\r\n        dashedLines._creationDataStorage = new _mesh__WEBPACK_IMPORTED_MODULE_1__[\"_CreationDataStorage\"]();\r\n        dashedLines._creationDataStorage.dashSize = dashSize;\r\n        dashedLines._creationDataStorage.gapSize = gapSize;\r\n        return dashedLines;\r\n    };\r\n    return LinesBuilder;\r\n}());\r\n\r\n//# sourceMappingURL=linesBuilder.js.map\n\n//# sourceURL=webpack:///./node_modules/@babylonjs/core/Meshes/Builders/linesBuilder.js?");

/***/ }),

/***/ "./node_modules/@babylonjs/core/Meshes/Builders/planeBuilder.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Meshes/Builders/planeBuilder.js ***!
  \**********************************************************************/
/*! exports provided: PlaneBuilder */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PlaneBuilder\", function() { return PlaneBuilder; });\n/* harmony import */ var _mesh__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../mesh */ \"./node_modules/@babylonjs/core/Meshes/mesh.js\");\n/* harmony import */ var _mesh_vertexData__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../mesh.vertexData */ \"./node_modules/@babylonjs/core/Meshes/mesh.vertexData.js\");\n\r\n\r\n_mesh_vertexData__WEBPACK_IMPORTED_MODULE_1__[\"VertexData\"].CreatePlane = function (options) {\r\n    var indices = [];\r\n    var positions = [];\r\n    var normals = [];\r\n    var uvs = [];\r\n    var width = options.width || options.size || 1;\r\n    var height = options.height || options.size || 1;\r\n    var sideOrientation = (options.sideOrientation === 0) ? 0 : options.sideOrientation || _mesh_vertexData__WEBPACK_IMPORTED_MODULE_1__[\"VertexData\"].DEFAULTSIDE;\r\n    // Vertices\r\n    var halfWidth = width / 2.0;\r\n    var halfHeight = height / 2.0;\r\n    positions.push(-halfWidth, -halfHeight, 0);\r\n    normals.push(0, 0, -1.0);\r\n    uvs.push(0.0, 0.0);\r\n    positions.push(halfWidth, -halfHeight, 0);\r\n    normals.push(0, 0, -1.0);\r\n    uvs.push(1.0, 0.0);\r\n    positions.push(halfWidth, halfHeight, 0);\r\n    normals.push(0, 0, -1.0);\r\n    uvs.push(1.0, 1.0);\r\n    positions.push(-halfWidth, halfHeight, 0);\r\n    normals.push(0, 0, -1.0);\r\n    uvs.push(0.0, 1.0);\r\n    // Indices\r\n    indices.push(0);\r\n    indices.push(1);\r\n    indices.push(2);\r\n    indices.push(0);\r\n    indices.push(2);\r\n    indices.push(3);\r\n    // Sides\r\n    _mesh_vertexData__WEBPACK_IMPORTED_MODULE_1__[\"VertexData\"]._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\r\n    // Result\r\n    var vertexData = new _mesh_vertexData__WEBPACK_IMPORTED_MODULE_1__[\"VertexData\"]();\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n    return vertexData;\r\n};\r\n_mesh__WEBPACK_IMPORTED_MODULE_0__[\"Mesh\"].CreatePlane = function (name, size, scene, updatable, sideOrientation) {\r\n    var options = {\r\n        size: size,\r\n        width: size,\r\n        height: size,\r\n        sideOrientation: sideOrientation,\r\n        updatable: updatable\r\n    };\r\n    return PlaneBuilder.CreatePlane(name, options, scene);\r\n};\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n */\r\nvar PlaneBuilder = /** @class */ (function () {\r\n    function PlaneBuilder() {\r\n    }\r\n    /**\r\n     * Creates a plane mesh\r\n     * * The parameter `size` sets the size (float) of both sides of the plane at once (default 1)\r\n     * * You can set some different plane dimensions by using the parameters `width` and `height` (both by default have the same value of `size`)\r\n     * * The parameter `sourcePlane` is a Plane instance. It builds a mesh plane from a Math plane\r\n     * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n     * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\r\n     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n     * @param name defines the name of the mesh\r\n     * @param options defines the options used to create the mesh\r\n     * @param scene defines the hosting scene\r\n     * @returns the plane mesh\r\n     * @see https://doc.babylonjs.com/how_to/set_shapes#plane\r\n     */\r\n    PlaneBuilder.CreatePlane = function (name, options, scene) {\r\n        if (scene === void 0) { scene = null; }\r\n        var plane = new _mesh__WEBPACK_IMPORTED_MODULE_0__[\"Mesh\"](name, scene);\r\n        options.sideOrientation = _mesh__WEBPACK_IMPORTED_MODULE_0__[\"Mesh\"]._GetDefaultSideOrientation(options.sideOrientation);\r\n        plane._originalBuilderSideOrientation = options.sideOrientation;\r\n        var vertexData = _mesh_vertexData__WEBPACK_IMPORTED_MODULE_1__[\"VertexData\"].CreatePlane(options);\r\n        vertexData.applyToMesh(plane, options.updatable);\r\n        if (options.sourcePlane) {\r\n            plane.translate(options.sourcePlane.normal, -options.sourcePlane.d);\r\n            plane.setDirection(options.sourcePlane.normal.scale(-1));\r\n        }\r\n        return plane;\r\n    };\r\n    return PlaneBuilder;\r\n}());\r\n\r\n//# sourceMappingURL=planeBuilder.js.map\n\n//# sourceURL=webpack:///./node_modules/@babylonjs/core/Meshes/Builders/planeBuilder.js?");

/***/ }),

/***/ "./node_modules/@babylonjs/core/Meshes/Builders/polygonBuilder.js":
/*!************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Meshes/Builders/polygonBuilder.js ***!
  \************************************************************************/
/*! exports provided: PolygonBuilder */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PolygonBuilder\", function() { return PolygonBuilder; });\n/* harmony import */ var _Maths_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Maths/math */ \"./node_modules/@babylonjs/core/Maths/math.js\");\n/* harmony import */ var _mesh__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../mesh */ \"./node_modules/@babylonjs/core/Meshes/mesh.js\");\n/* harmony import */ var _mesh_vertexData__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../mesh.vertexData */ \"./node_modules/@babylonjs/core/Meshes/mesh.vertexData.js\");\n/* harmony import */ var _polygonMesh__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../polygonMesh */ \"./node_modules/@babylonjs/core/Meshes/polygonMesh.js\");\n/* harmony import */ var _Meshes_buffer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../Meshes/buffer */ \"./node_modules/@babylonjs/core/Meshes/buffer.js\");\n/* harmony import */ var _Engines_engineStore__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../Engines/engineStore */ \"./node_modules/@babylonjs/core/Engines/engineStore.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n_mesh_vertexData__WEBPACK_IMPORTED_MODULE_2__[\"VertexData\"].CreatePolygon = function (polygon, sideOrientation, fUV, fColors, frontUVs, backUVs) {\r\n    var faceUV = fUV || new Array(3);\r\n    var faceColors = fColors;\r\n    var colors = [];\r\n    // default face colors and UV if undefined\r\n    for (var f = 0; f < 3; f++) {\r\n        if (faceUV[f] === undefined) {\r\n            faceUV[f] = new _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector4\"](0, 0, 1, 1);\r\n        }\r\n        if (faceColors && faceColors[f] === undefined) {\r\n            faceColors[f] = new _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Color4\"](1, 1, 1, 1);\r\n        }\r\n    }\r\n    var positions = polygon.getVerticesData(_Meshes_buffer__WEBPACK_IMPORTED_MODULE_4__[\"VertexBuffer\"].PositionKind);\r\n    var normals = polygon.getVerticesData(_Meshes_buffer__WEBPACK_IMPORTED_MODULE_4__[\"VertexBuffer\"].NormalKind);\r\n    var uvs = polygon.getVerticesData(_Meshes_buffer__WEBPACK_IMPORTED_MODULE_4__[\"VertexBuffer\"].UVKind);\r\n    var indices = polygon.getIndices();\r\n    // set face colours and textures\r\n    var idx = 0;\r\n    var face = 0;\r\n    for (var index = 0; index < normals.length; index += 3) {\r\n        //Edge Face  no. 1\r\n        if (Math.abs(normals[index + 1]) < 0.001) {\r\n            face = 1;\r\n        }\r\n        //Top Face  no. 0\r\n        if (Math.abs(normals[index + 1] - 1) < 0.001) {\r\n            face = 0;\r\n        }\r\n        //Bottom Face  no. 2\r\n        if (Math.abs(normals[index + 1] + 1) < 0.001) {\r\n            face = 2;\r\n        }\r\n        idx = index / 3;\r\n        uvs[2 * idx] = (1 - uvs[2 * idx]) * faceUV[face].x + uvs[2 * idx] * faceUV[face].z;\r\n        uvs[2 * idx + 1] = (1 - uvs[2 * idx + 1]) * faceUV[face].y + uvs[2 * idx + 1] * faceUV[face].w;\r\n        if (faceColors) {\r\n            colors.push(faceColors[face].r, faceColors[face].g, faceColors[face].b, faceColors[face].a);\r\n        }\r\n    }\r\n    // sides\r\n    _mesh_vertexData__WEBPACK_IMPORTED_MODULE_2__[\"VertexData\"]._ComputeSides(sideOrientation, positions, indices, normals, uvs, frontUVs, backUVs);\r\n    // Result\r\n    var vertexData = new _mesh_vertexData__WEBPACK_IMPORTED_MODULE_2__[\"VertexData\"]();\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n    if (faceColors) {\r\n        var totalColors = (sideOrientation === _mesh_vertexData__WEBPACK_IMPORTED_MODULE_2__[\"VertexData\"].DOUBLESIDE) ? colors.concat(colors) : colors;\r\n        vertexData.colors = totalColors;\r\n    }\r\n    return vertexData;\r\n};\r\n_mesh__WEBPACK_IMPORTED_MODULE_1__[\"Mesh\"].CreatePolygon = function (name, shape, scene, holes, updatable, sideOrientation, earcutInjection) {\r\n    if (earcutInjection === void 0) { earcutInjection = earcut; }\r\n    var options = {\r\n        shape: shape,\r\n        holes: holes,\r\n        updatable: updatable,\r\n        sideOrientation: sideOrientation\r\n    };\r\n    return PolygonBuilder.CreatePolygon(name, options, scene, earcutInjection);\r\n};\r\n_mesh__WEBPACK_IMPORTED_MODULE_1__[\"Mesh\"].ExtrudePolygon = function (name, shape, depth, scene, holes, updatable, sideOrientation, earcutInjection) {\r\n    if (earcutInjection === void 0) { earcutInjection = earcut; }\r\n    var options = {\r\n        shape: shape,\r\n        holes: holes,\r\n        depth: depth,\r\n        updatable: updatable,\r\n        sideOrientation: sideOrientation\r\n    };\r\n    return PolygonBuilder.ExtrudePolygon(name, options, scene, earcutInjection);\r\n};\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n */\r\nvar PolygonBuilder = /** @class */ (function () {\r\n    function PolygonBuilder() {\r\n    }\r\n    /**\r\n     * Creates a polygon mesh\r\n     * The polygon's shape will depend on the input parameters and is constructed parallel to a ground mesh\r\n     * * The parameter `shape` is a required array of successive Vector3 representing the corners of the polygon in th XoZ plane, that is y = 0 for all vectors\r\n     * * You can set the mesh side orientation with the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n     * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4)\r\n     * * Remember you can only change the shape positions, not their number when updating a polygon\r\n     * @param name defines the name of the mesh\r\n     * @param options defines the options used to create the mesh\r\n     * @param scene defines the hosting scene\r\n     * @param earcutInjection can be used to inject your own earcut reference\r\n     * @returns the polygon mesh\r\n     */\r\n    PolygonBuilder.CreatePolygon = function (name, options, scene, earcutInjection) {\r\n        if (scene === void 0) { scene = null; }\r\n        if (earcutInjection === void 0) { earcutInjection = earcut; }\r\n        options.sideOrientation = _mesh__WEBPACK_IMPORTED_MODULE_1__[\"Mesh\"]._GetDefaultSideOrientation(options.sideOrientation);\r\n        var shape = options.shape;\r\n        var holes = options.holes || [];\r\n        var depth = options.depth || 0;\r\n        var contours = [];\r\n        var hole = [];\r\n        for (var i = 0; i < shape.length; i++) {\r\n            contours[i] = new _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector2\"](shape[i].x, shape[i].z);\r\n        }\r\n        var epsilon = 0.00000001;\r\n        if (contours[0].equalsWithEpsilon(contours[contours.length - 1], epsilon)) {\r\n            contours.pop();\r\n        }\r\n        var polygonTriangulation = new _polygonMesh__WEBPACK_IMPORTED_MODULE_3__[\"PolygonMeshBuilder\"](name, contours, scene || _Engines_engineStore__WEBPACK_IMPORTED_MODULE_5__[\"EngineStore\"].LastCreatedScene, earcutInjection);\r\n        for (var hNb = 0; hNb < holes.length; hNb++) {\r\n            hole = [];\r\n            for (var hPoint = 0; hPoint < holes[hNb].length; hPoint++) {\r\n                hole.push(new _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector2\"](holes[hNb][hPoint].x, holes[hNb][hPoint].z));\r\n            }\r\n            polygonTriangulation.addHole(hole);\r\n        }\r\n        var polygon = polygonTriangulation.build(options.updatable, depth);\r\n        polygon._originalBuilderSideOrientation = options.sideOrientation;\r\n        var vertexData = _mesh_vertexData__WEBPACK_IMPORTED_MODULE_2__[\"VertexData\"].CreatePolygon(polygon, options.sideOrientation, options.faceUV, options.faceColors, options.frontUVs, options.backUVs);\r\n        vertexData.applyToMesh(polygon, options.updatable);\r\n        return polygon;\r\n    };\r\n    /**\r\n     * Creates an extruded polygon mesh, with depth in the Y direction.\r\n     * * You can set different colors and different images to the top, bottom and extruded side by using the parameters `faceColors` (an array of 3 Color3 elements) and `faceUV` (an array of 3 Vector4 elements)\r\n     * @see https://doc.babylonjs.com/how_to/createbox_per_face_textures_and_colors\r\n     * @param name defines the name of the mesh\r\n     * @param options defines the options used to create the mesh\r\n     * @param scene defines the hosting scene\r\n     * @param earcutInjection can be used to inject your own earcut reference\r\n     * @returns the polygon mesh\r\n     */\r\n    PolygonBuilder.ExtrudePolygon = function (name, options, scene, earcutInjection) {\r\n        if (scene === void 0) { scene = null; }\r\n        if (earcutInjection === void 0) { earcutInjection = earcut; }\r\n        return PolygonBuilder.CreatePolygon(name, options, scene, earcutInjection);\r\n    };\r\n    return PolygonBuilder;\r\n}());\r\n\r\n//# sourceMappingURL=polygonBuilder.js.map\n\n//# sourceURL=webpack:///./node_modules/@babylonjs/core/Meshes/Builders/polygonBuilder.js?");

/***/ }),

/***/ "./node_modules/@babylonjs/core/Meshes/Builders/polyhedronBuilder.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Meshes/Builders/polyhedronBuilder.js ***!
  \***************************************************************************/
/*! exports provided: PolyhedronBuilder */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PolyhedronBuilder\", function() { return PolyhedronBuilder; });\n/* harmony import */ var _Maths_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Maths/math */ \"./node_modules/@babylonjs/core/Maths/math.js\");\n/* harmony import */ var _mesh__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../mesh */ \"./node_modules/@babylonjs/core/Meshes/mesh.js\");\n/* harmony import */ var _mesh_vertexData__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../mesh.vertexData */ \"./node_modules/@babylonjs/core/Meshes/mesh.vertexData.js\");\n\r\n\r\n\r\n_mesh_vertexData__WEBPACK_IMPORTED_MODULE_2__[\"VertexData\"].CreatePolyhedron = function (options) {\r\n    // provided polyhedron types :\r\n    // 0 : Tetrahedron, 1 : Octahedron, 2 : Dodecahedron, 3 : Icosahedron, 4 : Rhombicuboctahedron, 5 : Triangular Prism, 6 : Pentagonal Prism, 7 : Hexagonal Prism, 8 : Square Pyramid (J1)\r\n    // 9 : Pentagonal Pyramid (J2), 10 : Triangular Dipyramid (J12), 11 : Pentagonal Dipyramid (J13), 12 : Elongated Square Dipyramid (J15), 13 : Elongated Pentagonal Dipyramid (J16), 14 : Elongated Pentagonal Cupola (J20)\r\n    var polyhedra = [];\r\n    polyhedra[0] = { vertex: [[0, 0, 1.732051], [1.632993, 0, -0.5773503], [-0.8164966, 1.414214, -0.5773503], [-0.8164966, -1.414214, -0.5773503]], face: [[0, 1, 2], [0, 2, 3], [0, 3, 1], [1, 3, 2]] };\r\n    polyhedra[1] = { vertex: [[0, 0, 1.414214], [1.414214, 0, 0], [0, 1.414214, 0], [-1.414214, 0, 0], [0, -1.414214, 0], [0, 0, -1.414214]], face: [[0, 1, 2], [0, 2, 3], [0, 3, 4], [0, 4, 1], [1, 4, 5], [1, 5, 2], [2, 5, 3], [3, 5, 4]] };\r\n    polyhedra[2] = {\r\n        vertex: [[0, 0, 1.070466], [0.7136442, 0, 0.7978784], [-0.3568221, 0.618034, 0.7978784], [-0.3568221, -0.618034, 0.7978784], [0.7978784, 0.618034, 0.3568221], [0.7978784, -0.618034, 0.3568221], [-0.9341724, 0.381966, 0.3568221], [0.1362939, 1, 0.3568221], [0.1362939, -1, 0.3568221], [-0.9341724, -0.381966, 0.3568221], [0.9341724, 0.381966, -0.3568221], [0.9341724, -0.381966, -0.3568221], [-0.7978784, 0.618034, -0.3568221], [-0.1362939, 1, -0.3568221], [-0.1362939, -1, -0.3568221], [-0.7978784, -0.618034, -0.3568221], [0.3568221, 0.618034, -0.7978784], [0.3568221, -0.618034, -0.7978784], [-0.7136442, 0, -0.7978784], [0, 0, -1.070466]],\r\n        face: [[0, 1, 4, 7, 2], [0, 2, 6, 9, 3], [0, 3, 8, 5, 1], [1, 5, 11, 10, 4], [2, 7, 13, 12, 6], [3, 9, 15, 14, 8], [4, 10, 16, 13, 7], [5, 8, 14, 17, 11], [6, 12, 18, 15, 9], [10, 11, 17, 19, 16], [12, 13, 16, 19, 18], [14, 15, 18, 19, 17]]\r\n    };\r\n    polyhedra[3] = {\r\n        vertex: [[0, 0, 1.175571], [1.051462, 0, 0.5257311], [0.3249197, 1, 0.5257311], [-0.8506508, 0.618034, 0.5257311], [-0.8506508, -0.618034, 0.5257311], [0.3249197, -1, 0.5257311], [0.8506508, 0.618034, -0.5257311], [0.8506508, -0.618034, -0.5257311], [-0.3249197, 1, -0.5257311], [-1.051462, 0, -0.5257311], [-0.3249197, -1, -0.5257311], [0, 0, -1.175571]],\r\n        face: [[0, 1, 2], [0, 2, 3], [0, 3, 4], [0, 4, 5], [0, 5, 1], [1, 5, 7], [1, 7, 6], [1, 6, 2], [2, 6, 8], [2, 8, 3], [3, 8, 9], [3, 9, 4], [4, 9, 10], [4, 10, 5], [5, 10, 7], [6, 7, 11], [6, 11, 8], [7, 10, 11], [8, 11, 9], [9, 11, 10]]\r\n    };\r\n    polyhedra[4] = {\r\n        vertex: [[0, 0, 1.070722], [0.7148135, 0, 0.7971752], [-0.104682, 0.7071068, 0.7971752], [-0.6841528, 0.2071068, 0.7971752], [-0.104682, -0.7071068, 0.7971752], [0.6101315, 0.7071068, 0.5236279], [1.04156, 0.2071068, 0.1367736], [0.6101315, -0.7071068, 0.5236279], [-0.3574067, 1, 0.1367736], [-0.7888348, -0.5, 0.5236279], [-0.9368776, 0.5, 0.1367736], [-0.3574067, -1, 0.1367736], [0.3574067, 1, -0.1367736], [0.9368776, -0.5, -0.1367736], [0.7888348, 0.5, -0.5236279], [0.3574067, -1, -0.1367736], [-0.6101315, 0.7071068, -0.5236279], [-1.04156, -0.2071068, -0.1367736], [-0.6101315, -0.7071068, -0.5236279], [0.104682, 0.7071068, -0.7971752], [0.6841528, -0.2071068, -0.7971752], [0.104682, -0.7071068, -0.7971752], [-0.7148135, 0, -0.7971752], [0, 0, -1.070722]],\r\n        face: [[0, 2, 3], [1, 6, 5], [4, 9, 11], [7, 15, 13], [8, 16, 10], [12, 14, 19], [17, 22, 18], [20, 21, 23], [0, 1, 5, 2], [0, 3, 9, 4], [0, 4, 7, 1], [1, 7, 13, 6], [2, 5, 12, 8], [2, 8, 10, 3], [3, 10, 17, 9], [4, 11, 15, 7], [5, 6, 14, 12], [6, 13, 20, 14], [8, 12, 19, 16], [9, 17, 18, 11], [10, 16, 22, 17], [11, 18, 21, 15], [13, 15, 21, 20], [14, 20, 23, 19], [16, 19, 23, 22], [18, 22, 23, 21]]\r\n    };\r\n    polyhedra[5] = { vertex: [[0, 0, 1.322876], [1.309307, 0, 0.1889822], [-0.9819805, 0.8660254, 0.1889822], [0.1636634, -1.299038, 0.1889822], [0.3273268, 0.8660254, -0.9449112], [-0.8183171, -0.4330127, -0.9449112]], face: [[0, 3, 1], [2, 4, 5], [0, 1, 4, 2], [0, 2, 5, 3], [1, 3, 5, 4]] };\r\n    polyhedra[6] = { vertex: [[0, 0, 1.159953], [1.013464, 0, 0.5642542], [-0.3501431, 0.9510565, 0.5642542], [-0.7715208, -0.6571639, 0.5642542], [0.6633206, 0.9510565, -0.03144481], [0.8682979, -0.6571639, -0.3996071], [-1.121664, 0.2938926, -0.03144481], [-0.2348831, -1.063314, -0.3996071], [0.5181548, 0.2938926, -0.9953061], [-0.5850262, -0.112257, -0.9953061]], face: [[0, 1, 4, 2], [0, 2, 6, 3], [1, 5, 8, 4], [3, 6, 9, 7], [5, 7, 9, 8], [0, 3, 7, 5, 1], [2, 4, 8, 9, 6]] };\r\n    polyhedra[7] = { vertex: [[0, 0, 1.118034], [0.8944272, 0, 0.6708204], [-0.2236068, 0.8660254, 0.6708204], [-0.7826238, -0.4330127, 0.6708204], [0.6708204, 0.8660254, 0.2236068], [1.006231, -0.4330127, -0.2236068], [-1.006231, 0.4330127, 0.2236068], [-0.6708204, -0.8660254, -0.2236068], [0.7826238, 0.4330127, -0.6708204], [0.2236068, -0.8660254, -0.6708204], [-0.8944272, 0, -0.6708204], [0, 0, -1.118034]], face: [[0, 1, 4, 2], [0, 2, 6, 3], [1, 5, 8, 4], [3, 6, 10, 7], [5, 9, 11, 8], [7, 10, 11, 9], [0, 3, 7, 9, 5, 1], [2, 4, 8, 11, 10, 6]] };\r\n    polyhedra[8] = { vertex: [[-0.729665, 0.670121, 0.319155], [-0.655235, -0.29213, -0.754096], [-0.093922, -0.607123, 0.537818], [0.702196, 0.595691, 0.485187], [0.776626, -0.36656, -0.588064]], face: [[1, 4, 2], [0, 1, 2], [3, 0, 2], [4, 3, 2], [4, 1, 0, 3]] };\r\n    polyhedra[9] = { vertex: [[-0.868849, -0.100041, 0.61257], [-0.329458, 0.976099, 0.28078], [-0.26629, -0.013796, -0.477654], [-0.13392, -1.034115, 0.229829], [0.738834, 0.707117, -0.307018], [0.859683, -0.535264, -0.338508]], face: [[3, 0, 2], [5, 3, 2], [4, 5, 2], [1, 4, 2], [0, 1, 2], [0, 3, 5, 4, 1]] };\r\n    polyhedra[10] = { vertex: [[-0.610389, 0.243975, 0.531213], [-0.187812, -0.48795, -0.664016], [-0.187812, 0.9759, -0.664016], [0.187812, -0.9759, 0.664016], [0.798201, 0.243975, 0.132803]], face: [[1, 3, 0], [3, 4, 0], [3, 1, 4], [0, 2, 1], [0, 4, 2], [2, 4, 1]] };\r\n    polyhedra[11] = { vertex: [[-1.028778, 0.392027, -0.048786], [-0.640503, -0.646161, 0.621837], [-0.125162, -0.395663, -0.540059], [0.004683, 0.888447, -0.651988], [0.125161, 0.395663, 0.540059], [0.632925, -0.791376, 0.433102], [1.031672, 0.157063, -0.354165]], face: [[3, 2, 0], [2, 1, 0], [2, 5, 1], [0, 4, 3], [0, 1, 4], [4, 1, 5], [2, 3, 6], [3, 4, 6], [5, 2, 6], [4, 5, 6]] };\r\n    polyhedra[12] = { vertex: [[-0.669867, 0.334933, -0.529576], [-0.669867, 0.334933, 0.529577], [-0.4043, 1.212901, 0], [-0.334933, -0.669867, -0.529576], [-0.334933, -0.669867, 0.529577], [0.334933, 0.669867, -0.529576], [0.334933, 0.669867, 0.529577], [0.4043, -1.212901, 0], [0.669867, -0.334933, -0.529576], [0.669867, -0.334933, 0.529577]], face: [[8, 9, 7], [6, 5, 2], [3, 8, 7], [5, 0, 2], [4, 3, 7], [0, 1, 2], [9, 4, 7], [1, 6, 2], [9, 8, 5, 6], [8, 3, 0, 5], [3, 4, 1, 0], [4, 9, 6, 1]] };\r\n    polyhedra[13] = { vertex: [[-0.931836, 0.219976, -0.264632], [-0.636706, 0.318353, 0.692816], [-0.613483, -0.735083, -0.264632], [-0.326545, 0.979634, 0], [-0.318353, -0.636706, 0.692816], [-0.159176, 0.477529, -0.856368], [0.159176, -0.477529, -0.856368], [0.318353, 0.636706, 0.692816], [0.326545, -0.979634, 0], [0.613482, 0.735082, -0.264632], [0.636706, -0.318353, 0.692816], [0.931835, -0.219977, -0.264632]], face: [[11, 10, 8], [7, 9, 3], [6, 11, 8], [9, 5, 3], [2, 6, 8], [5, 0, 3], [4, 2, 8], [0, 1, 3], [10, 4, 8], [1, 7, 3], [10, 11, 9, 7], [11, 6, 5, 9], [6, 2, 0, 5], [2, 4, 1, 0], [4, 10, 7, 1]] };\r\n    polyhedra[14] = {\r\n        vertex: [[-0.93465, 0.300459, -0.271185], [-0.838689, -0.260219, -0.516017], [-0.711319, 0.717591, 0.128359], [-0.710334, -0.156922, 0.080946], [-0.599799, 0.556003, -0.725148], [-0.503838, -0.004675, -0.969981], [-0.487004, 0.26021, 0.48049], [-0.460089, -0.750282, -0.512622], [-0.376468, 0.973135, -0.325605], [-0.331735, -0.646985, 0.084342], [-0.254001, 0.831847, 0.530001], [-0.125239, -0.494738, -0.966586], [0.029622, 0.027949, 0.730817], [0.056536, -0.982543, -0.262295], [0.08085, 1.087391, 0.076037], [0.125583, -0.532729, 0.485984], [0.262625, 0.599586, 0.780328], [0.391387, -0.726999, -0.716259], [0.513854, -0.868287, 0.139347], [0.597475, 0.85513, 0.326364], [0.641224, 0.109523, 0.783723], [0.737185, -0.451155, 0.538891], [0.848705, -0.612742, -0.314616], [0.976075, 0.365067, 0.32976], [1.072036, -0.19561, 0.084927]],\r\n        face: [[15, 18, 21], [12, 20, 16], [6, 10, 2], [3, 0, 1], [9, 7, 13], [2, 8, 4, 0], [0, 4, 5, 1], [1, 5, 11, 7], [7, 11, 17, 13], [13, 17, 22, 18], [18, 22, 24, 21], [21, 24, 23, 20], [20, 23, 19, 16], [16, 19, 14, 10], [10, 14, 8, 2], [15, 9, 13, 18], [12, 15, 21, 20], [6, 12, 16, 10], [3, 6, 2, 0], [9, 3, 1, 7], [9, 15, 12, 6, 3], [22, 17, 11, 5, 4, 8, 14, 19, 23, 24]]\r\n    };\r\n    var type = options.type && (options.type < 0 || options.type >= polyhedra.length) ? 0 : options.type || 0;\r\n    var size = options.size;\r\n    var sizeX = options.sizeX || size || 1;\r\n    var sizeY = options.sizeY || size || 1;\r\n    var sizeZ = options.sizeZ || size || 1;\r\n    var data = options.custom || polyhedra[type];\r\n    var nbfaces = data.face.length;\r\n    var faceUV = options.faceUV || new Array(nbfaces);\r\n    var faceColors = options.faceColors;\r\n    var flat = (options.flat === undefined) ? true : options.flat;\r\n    var sideOrientation = (options.sideOrientation === 0) ? 0 : options.sideOrientation || _mesh_vertexData__WEBPACK_IMPORTED_MODULE_2__[\"VertexData\"].DEFAULTSIDE;\r\n    var positions = new Array();\r\n    var indices = new Array();\r\n    var normals = new Array();\r\n    var uvs = new Array();\r\n    var colors = new Array();\r\n    var index = 0;\r\n    var faceIdx = 0; // face cursor in the array \"indexes\"\r\n    var indexes = new Array();\r\n    var i = 0;\r\n    var f = 0;\r\n    var u, v, ang, x, y, tmp;\r\n    // default face colors and UV if undefined\r\n    if (flat) {\r\n        for (f = 0; f < nbfaces; f++) {\r\n            if (faceColors && faceColors[f] === undefined) {\r\n                faceColors[f] = new _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Color4\"](1, 1, 1, 1);\r\n            }\r\n            if (faceUV && faceUV[f] === undefined) {\r\n                faceUV[f] = new _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector4\"](0, 0, 1, 1);\r\n            }\r\n        }\r\n    }\r\n    if (!flat) {\r\n        for (i = 0; i < data.vertex.length; i++) {\r\n            positions.push(data.vertex[i][0] * sizeX, data.vertex[i][1] * sizeY, data.vertex[i][2] * sizeZ);\r\n            uvs.push(0, 0);\r\n        }\r\n        for (f = 0; f < nbfaces; f++) {\r\n            for (i = 0; i < data.face[f].length - 2; i++) {\r\n                indices.push(data.face[f][0], data.face[f][i + 2], data.face[f][i + 1]);\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        for (f = 0; f < nbfaces; f++) {\r\n            var fl = data.face[f].length; // number of vertices of the current face\r\n            ang = 2 * Math.PI / fl;\r\n            x = 0.5 * Math.tan(ang / 2);\r\n            y = 0.5;\r\n            // positions, uvs, colors\r\n            for (i = 0; i < fl; i++) {\r\n                // positions\r\n                positions.push(data.vertex[data.face[f][i]][0] * sizeX, data.vertex[data.face[f][i]][1] * sizeY, data.vertex[data.face[f][i]][2] * sizeZ);\r\n                indexes.push(index);\r\n                index++;\r\n                // uvs\r\n                u = faceUV[f].x + (faceUV[f].z - faceUV[f].x) * (0.5 + x);\r\n                v = faceUV[f].y + (faceUV[f].w - faceUV[f].y) * (y - 0.5);\r\n                uvs.push(u, v);\r\n                tmp = x * Math.cos(ang) - y * Math.sin(ang);\r\n                y = x * Math.sin(ang) + y * Math.cos(ang);\r\n                x = tmp;\r\n                // colors\r\n                if (faceColors) {\r\n                    colors.push(faceColors[f].r, faceColors[f].g, faceColors[f].b, faceColors[f].a);\r\n                }\r\n            }\r\n            // indices from indexes\r\n            for (i = 0; i < fl - 2; i++) {\r\n                indices.push(indexes[0 + faceIdx], indexes[i + 2 + faceIdx], indexes[i + 1 + faceIdx]);\r\n            }\r\n            faceIdx += fl;\r\n        }\r\n    }\r\n    _mesh_vertexData__WEBPACK_IMPORTED_MODULE_2__[\"VertexData\"].ComputeNormals(positions, indices, normals);\r\n    _mesh_vertexData__WEBPACK_IMPORTED_MODULE_2__[\"VertexData\"]._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\r\n    var vertexData = new _mesh_vertexData__WEBPACK_IMPORTED_MODULE_2__[\"VertexData\"]();\r\n    vertexData.positions = positions;\r\n    vertexData.indices = indices;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n    if (faceColors && flat) {\r\n        vertexData.colors = colors;\r\n    }\r\n    return vertexData;\r\n};\r\n_mesh__WEBPACK_IMPORTED_MODULE_1__[\"Mesh\"].CreatePolyhedron = function (name, options, scene) {\r\n    return PolyhedronBuilder.CreatePolyhedron(name, options, scene);\r\n};\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n */\r\nvar PolyhedronBuilder = /** @class */ (function () {\r\n    function PolyhedronBuilder() {\r\n    }\r\n    /**\r\n     * Creates a polyhedron mesh\r\n     * * The parameter `type` (positive integer, max 14, default 0) sets the polyhedron type to build among the 15 embbeded types. Please refer to the type sheet in the tutorial to choose the wanted type\r\n     * * The parameter `size` (positive float, default 1) sets the polygon size\r\n     * * You can overwrite the `size` on each dimension bu using the parameters `sizeX`, `sizeY` or `sizeZ` (positive floats, default to `size` value)\r\n     * * You can build other polyhedron types than the 15 embbeded ones by setting the parameter `custom` (`polyhedronObject`, default null). If you set the parameter `custom`, this overwrittes the parameter `type`\r\n     * * A `polyhedronObject` is a formatted javascript object. You'll find a full file with pre-set polyhedra here : https://github.com/BabylonJS/Extensions/tree/master/Polyhedron\r\n     * * You can set the color and the UV of each side of the polyhedron with the parameters `faceColors` (Color4, default `(1, 1, 1, 1)`) and faceUV (Vector4, default `(0, 0, 1, 1)`)\r\n     * * To understand how to set `faceUV` or `faceColors`, please read this by considering the right number of faces of your polyhedron, instead of only 6 for the box : https://doc.babylonjs.com/how_to/createbox_per_face_textures_and_colors\r\n     * * The parameter `flat` (boolean, default true). If set to false, it gives the polyhedron a single global face, so less vertices and shared normals. In this case, `faceColors` and `faceUV` are ignored\r\n     * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n     * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\r\n     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n     * @param name defines the name of the mesh\r\n     * @param options defines the options used to create the mesh\r\n     * @param scene defines the hosting scene\r\n     * @returns the polyhedron mesh\r\n     * @see https://doc.babylonjs.com/how_to/polyhedra_shapes\r\n     */\r\n    PolyhedronBuilder.CreatePolyhedron = function (name, options, scene) {\r\n        if (scene === void 0) { scene = null; }\r\n        var polyhedron = new _mesh__WEBPACK_IMPORTED_MODULE_1__[\"Mesh\"](name, scene);\r\n        options.sideOrientation = _mesh__WEBPACK_IMPORTED_MODULE_1__[\"Mesh\"]._GetDefaultSideOrientation(options.sideOrientation);\r\n        polyhedron._originalBuilderSideOrientation = options.sideOrientation;\r\n        var vertexData = _mesh_vertexData__WEBPACK_IMPORTED_MODULE_2__[\"VertexData\"].CreatePolyhedron(options);\r\n        vertexData.applyToMesh(polyhedron, options.updatable);\r\n        return polyhedron;\r\n    };\r\n    return PolyhedronBuilder;\r\n}());\r\n\r\n//# sourceMappingURL=polyhedronBuilder.js.map\n\n//# sourceURL=webpack:///./node_modules/@babylonjs/core/Meshes/Builders/polyhedronBuilder.js?");

/***/ }),

/***/ "./node_modules/@babylonjs/core/Meshes/Builders/ribbonBuilder.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Meshes/Builders/ribbonBuilder.js ***!
  \***********************************************************************/
/*! exports provided: RibbonBuilder */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RibbonBuilder\", function() { return RibbonBuilder; });\n/* harmony import */ var _Maths_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Maths/math */ \"./node_modules/@babylonjs/core/Maths/math.js\");\n/* harmony import */ var _mesh__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../mesh */ \"./node_modules/@babylonjs/core/Meshes/mesh.js\");\n/* harmony import */ var _buffer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../buffer */ \"./node_modules/@babylonjs/core/Meshes/buffer.js\");\n/* harmony import */ var _mesh_vertexData__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../mesh.vertexData */ \"./node_modules/@babylonjs/core/Meshes/mesh.vertexData.js\");\n/* harmony import */ var _Culling_boundingInfo__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../Culling/boundingInfo */ \"./node_modules/@babylonjs/core/Culling/boundingInfo.js\");\n\r\n\r\n\r\n\r\n\r\n_mesh_vertexData__WEBPACK_IMPORTED_MODULE_3__[\"VertexData\"].CreateRibbon = function (options) {\r\n    var pathArray = options.pathArray;\r\n    var closeArray = options.closeArray || false;\r\n    var closePath = options.closePath || false;\r\n    var invertUV = options.invertUV || false;\r\n    var defaultOffset = Math.floor(pathArray[0].length / 2);\r\n    var offset = options.offset || defaultOffset;\r\n    offset = offset > defaultOffset ? defaultOffset : Math.floor(offset); // offset max allowed : defaultOffset\r\n    var sideOrientation = (options.sideOrientation === 0) ? 0 : options.sideOrientation || _mesh_vertexData__WEBPACK_IMPORTED_MODULE_3__[\"VertexData\"].DEFAULTSIDE;\r\n    var customUV = options.uvs;\r\n    var customColors = options.colors;\r\n    var positions = [];\r\n    var indices = [];\r\n    var normals = [];\r\n    var uvs = [];\r\n    var us = []; // us[path_id] = [uDist1, uDist2, uDist3 ... ] distances between points on path path_id\r\n    var vs = []; // vs[i] = [vDist1, vDist2, vDist3, ... ] distances between points i of consecutives paths from pathArray\r\n    var uTotalDistance = []; // uTotalDistance[p] : total distance of path p\r\n    var vTotalDistance = []; //  vTotalDistance[i] : total distance between points i of first and last path from pathArray\r\n    var minlg; // minimal length among all paths from pathArray\r\n    var lg = []; // array of path lengths : nb of vertex per path\r\n    var idx = []; // array of path indexes : index of each path (first vertex) in the total vertex number\r\n    var p; // path iterator\r\n    var i; // point iterator\r\n    var j; // point iterator\r\n    // if single path in pathArray\r\n    if (pathArray.length < 2) {\r\n        var ar1 = [];\r\n        var ar2 = [];\r\n        for (i = 0; i < pathArray[0].length - offset; i++) {\r\n            ar1.push(pathArray[0][i]);\r\n            ar2.push(pathArray[0][i + offset]);\r\n        }\r\n        pathArray = [ar1, ar2];\r\n    }\r\n    // positions and horizontal distances (u)\r\n    var idc = 0;\r\n    var closePathCorr = (closePath) ? 1 : 0; // the final index will be +1 if closePath\r\n    var path;\r\n    var l;\r\n    minlg = pathArray[0].length;\r\n    var vectlg;\r\n    var dist;\r\n    for (p = 0; p < pathArray.length; p++) {\r\n        uTotalDistance[p] = 0;\r\n        us[p] = [0];\r\n        path = pathArray[p];\r\n        l = path.length;\r\n        minlg = (minlg < l) ? minlg : l;\r\n        j = 0;\r\n        while (j < l) {\r\n            positions.push(path[j].x, path[j].y, path[j].z);\r\n            if (j > 0) {\r\n                vectlg = path[j].subtract(path[j - 1]).length();\r\n                dist = vectlg + uTotalDistance[p];\r\n                us[p].push(dist);\r\n                uTotalDistance[p] = dist;\r\n            }\r\n            j++;\r\n        }\r\n        if (closePath) { // an extra hidden vertex is added in the \"positions\" array\r\n            j--;\r\n            positions.push(path[0].x, path[0].y, path[0].z);\r\n            vectlg = path[j].subtract(path[0]).length();\r\n            dist = vectlg + uTotalDistance[p];\r\n            us[p].push(dist);\r\n            uTotalDistance[p] = dist;\r\n        }\r\n        lg[p] = l + closePathCorr;\r\n        idx[p] = idc;\r\n        idc += (l + closePathCorr);\r\n    }\r\n    // vertical distances (v)\r\n    var path1;\r\n    var path2;\r\n    var vertex1 = null;\r\n    var vertex2 = null;\r\n    for (i = 0; i < minlg + closePathCorr; i++) {\r\n        vTotalDistance[i] = 0;\r\n        vs[i] = [0];\r\n        for (p = 0; p < pathArray.length - 1; p++) {\r\n            path1 = pathArray[p];\r\n            path2 = pathArray[p + 1];\r\n            if (i === minlg) { // closePath\r\n                vertex1 = path1[0];\r\n                vertex2 = path2[0];\r\n            }\r\n            else {\r\n                vertex1 = path1[i];\r\n                vertex2 = path2[i];\r\n            }\r\n            vectlg = vertex2.subtract(vertex1).length();\r\n            dist = vectlg + vTotalDistance[i];\r\n            vs[i].push(dist);\r\n            vTotalDistance[i] = dist;\r\n        }\r\n        if (closeArray && vertex2 && vertex1) {\r\n            path1 = pathArray[p];\r\n            path2 = pathArray[0];\r\n            if (i === minlg) { // closePath\r\n                vertex2 = path2[0];\r\n            }\r\n            vectlg = vertex2.subtract(vertex1).length();\r\n            dist = vectlg + vTotalDistance[i];\r\n            vTotalDistance[i] = dist;\r\n        }\r\n    }\r\n    // uvs\r\n    var u;\r\n    var v;\r\n    if (customUV) {\r\n        for (p = 0; p < customUV.length; p++) {\r\n            uvs.push(customUV[p].x, customUV[p].y);\r\n        }\r\n    }\r\n    else {\r\n        for (p = 0; p < pathArray.length; p++) {\r\n            for (i = 0; i < minlg + closePathCorr; i++) {\r\n                u = (uTotalDistance[p] != 0.0) ? us[p][i] / uTotalDistance[p] : 0.0;\r\n                v = (vTotalDistance[i] != 0.0) ? vs[i][p] / vTotalDistance[i] : 0.0;\r\n                if (invertUV) {\r\n                    uvs.push(v, u);\r\n                }\r\n                else {\r\n                    uvs.push(u, v);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // indices\r\n    p = 0; // path index\r\n    var pi = 0; // positions array index\r\n    var l1 = lg[p] - 1; // path1 length\r\n    var l2 = lg[p + 1] - 1; // path2 length\r\n    var min = (l1 < l2) ? l1 : l2; // current path stop index\r\n    var shft = idx[1] - idx[0]; // shift\r\n    var path1nb = closeArray ? lg.length : lg.length - 1; // number of path1 to iterate\ton\r\n    while (pi <= min && p < path1nb) { //  stay under min and don't go over next to last path\r\n        // draw two triangles between path1 (p1) and path2 (p2) : (p1.pi, p2.pi, p1.pi+1) and (p2.pi+1, p1.pi+1, p2.pi) clockwise\r\n        indices.push(pi, pi + shft, pi + 1);\r\n        indices.push(pi + shft + 1, pi + 1, pi + shft);\r\n        pi += 1;\r\n        if (pi === min) { // if end of one of two consecutive paths reached, go to next existing path\r\n            p++;\r\n            if (p === lg.length - 1) { // last path of pathArray reached <=> closeArray == true\r\n                shft = idx[0] - idx[p];\r\n                l1 = lg[p] - 1;\r\n                l2 = lg[0] - 1;\r\n            }\r\n            else {\r\n                shft = idx[p + 1] - idx[p];\r\n                l1 = lg[p] - 1;\r\n                l2 = lg[p + 1] - 1;\r\n            }\r\n            pi = idx[p];\r\n            min = (l1 < l2) ? l1 + pi : l2 + pi;\r\n        }\r\n    }\r\n    // normals\r\n    _mesh_vertexData__WEBPACK_IMPORTED_MODULE_3__[\"VertexData\"].ComputeNormals(positions, indices, normals);\r\n    if (closePath) { // update both the first and last vertex normals to their average value\r\n        var indexFirst = 0;\r\n        var indexLast = 0;\r\n        for (p = 0; p < pathArray.length; p++) {\r\n            indexFirst = idx[p] * 3;\r\n            if (p + 1 < pathArray.length) {\r\n                indexLast = (idx[p + 1] - 1) * 3;\r\n            }\r\n            else {\r\n                indexLast = normals.length - 3;\r\n            }\r\n            normals[indexFirst] = (normals[indexFirst] + normals[indexLast]) * 0.5;\r\n            normals[indexFirst + 1] = (normals[indexFirst + 1] + normals[indexLast + 1]) * 0.5;\r\n            normals[indexFirst + 2] = (normals[indexFirst + 2] + normals[indexLast + 2]) * 0.5;\r\n            normals[indexLast] = normals[indexFirst];\r\n            normals[indexLast + 1] = normals[indexFirst + 1];\r\n            normals[indexLast + 2] = normals[indexFirst + 2];\r\n        }\r\n    }\r\n    // sides\r\n    _mesh_vertexData__WEBPACK_IMPORTED_MODULE_3__[\"VertexData\"]._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\r\n    // Colors\r\n    var colors = null;\r\n    if (customColors) {\r\n        colors = new Float32Array(customColors.length * 4);\r\n        for (var c = 0; c < customColors.length; c++) {\r\n            colors[c * 4] = customColors[c].r;\r\n            colors[c * 4 + 1] = customColors[c].g;\r\n            colors[c * 4 + 2] = customColors[c].b;\r\n            colors[c * 4 + 3] = customColors[c].a;\r\n        }\r\n    }\r\n    // Result\r\n    var vertexData = new _mesh_vertexData__WEBPACK_IMPORTED_MODULE_3__[\"VertexData\"]();\r\n    var positions32 = new Float32Array(positions);\r\n    var normals32 = new Float32Array(normals);\r\n    var uvs32 = new Float32Array(uvs);\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions32;\r\n    vertexData.normals = normals32;\r\n    vertexData.uvs = uvs32;\r\n    if (colors) {\r\n        vertexData.set(colors, _buffer__WEBPACK_IMPORTED_MODULE_2__[\"VertexBuffer\"].ColorKind);\r\n    }\r\n    if (closePath) {\r\n        vertexData._idx = idx;\r\n    }\r\n    return vertexData;\r\n};\r\n_mesh__WEBPACK_IMPORTED_MODULE_1__[\"Mesh\"].CreateRibbon = function (name, pathArray, closeArray, closePath, offset, scene, updatable, sideOrientation, instance) {\r\n    if (closeArray === void 0) { closeArray = false; }\r\n    if (updatable === void 0) { updatable = false; }\r\n    return RibbonBuilder.CreateRibbon(name, {\r\n        pathArray: pathArray,\r\n        closeArray: closeArray,\r\n        closePath: closePath,\r\n        offset: offset,\r\n        updatable: updatable,\r\n        sideOrientation: sideOrientation,\r\n        instance: instance\r\n    }, scene);\r\n};\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n */\r\nvar RibbonBuilder = /** @class */ (function () {\r\n    function RibbonBuilder() {\r\n    }\r\n    /**\r\n     * Creates a ribbon mesh. The ribbon is a parametric shape.  It has no predefined shape. Its final shape will depend on the input parameters\r\n     * * The parameter `pathArray` is a required array of paths, what are each an array of successive Vector3. The pathArray parameter depicts the ribbon geometry\r\n     * * The parameter `closeArray` (boolean, default false) creates a seam between the first and the last paths of the path array\r\n     * * The parameter `closePath` (boolean, default false) creates a seam between the first and the last points of each path of the path array\r\n     * * The parameter `offset` (positive integer, default : rounded half size of the pathArray length), is taken in account only if the `pathArray` is containing a single path\r\n     * * It's the offset to join the points from the same path. Ex : offset = 10 means the point 1 is joined to the point 11\r\n     * * The optional parameter `instance` is an instance of an existing Ribbon object to be updated with the passed `pathArray` parameter : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#ribbon\r\n     * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n     * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\r\n     * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture\r\n     * * The parameter `uvs` is an optional flat array of `Vector2` to update/set each ribbon vertex with its own custom UV values instead of the computed ones\r\n     * * The parameters `colors` is an optional flat array of `Color4` to set/update each ribbon vertex with its own custom color values\r\n     * * Note that if you use the parameters `uvs` or `colors`, the passed arrays must be populated with the right number of elements, it is to say the number of ribbon vertices. Remember that if you set `closePath` to `true`, there's one extra vertex per path in the geometry\r\n     * * Moreover, you can use the parameter `color` with `instance` (to update the ribbon), only if you previously used it at creation time\r\n     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n     * @param name defines the name of the mesh\r\n     * @param options defines the options used to create the mesh\r\n     * @param scene defines the hosting scene\r\n     * @returns the ribbon mesh\r\n     * @see https://doc.babylonjs.com/how_to/ribbon_tutorial\r\n     * @see https://doc.babylonjs.com/how_to/parametric_shapes\r\n     */\r\n    RibbonBuilder.CreateRibbon = function (name, options, scene) {\r\n        if (scene === void 0) { scene = null; }\r\n        var pathArray = options.pathArray;\r\n        var closeArray = options.closeArray;\r\n        var closePath = options.closePath;\r\n        var sideOrientation = _mesh__WEBPACK_IMPORTED_MODULE_1__[\"Mesh\"]._GetDefaultSideOrientation(options.sideOrientation);\r\n        var instance = options.instance;\r\n        var updatable = options.updatable;\r\n        if (instance) { // existing ribbon instance update\r\n            // positionFunction : ribbon case\r\n            // only pathArray and sideOrientation parameters are taken into account for positions update\r\n            var minimum_1 = _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Tmp\"].Vector3[0].setAll(Number.MAX_VALUE);\r\n            var maximum_1 = _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Tmp\"].Vector3[1].setAll(-Number.MAX_VALUE);\r\n            var positionFunction = function (positions) {\r\n                var minlg = pathArray[0].length;\r\n                var mesh = instance;\r\n                var i = 0;\r\n                var ns = (mesh._originalBuilderSideOrientation === _mesh__WEBPACK_IMPORTED_MODULE_1__[\"Mesh\"].DOUBLESIDE) ? 2 : 1;\r\n                for (var si = 1; si <= ns; ++si) {\r\n                    for (var p = 0; p < pathArray.length; ++p) {\r\n                        var path = pathArray[p];\r\n                        var l = path.length;\r\n                        minlg = (minlg < l) ? minlg : l;\r\n                        for (var j = 0; j < minlg; ++j) {\r\n                            var pathPoint = path[j];\r\n                            positions[i] = pathPoint.x;\r\n                            positions[i + 1] = pathPoint.y;\r\n                            positions[i + 2] = pathPoint.z;\r\n                            minimum_1.minimizeInPlaceFromFloats(pathPoint.x, pathPoint.y, pathPoint.z);\r\n                            maximum_1.maximizeInPlaceFromFloats(pathPoint.x, pathPoint.y, pathPoint.z);\r\n                            i += 3;\r\n                        }\r\n                        if (mesh._creationDataStorage && mesh._creationDataStorage.closePath) {\r\n                            var pathPoint = path[0];\r\n                            positions[i] = pathPoint.x;\r\n                            positions[i + 1] = pathPoint.y;\r\n                            positions[i + 2] = pathPoint.z;\r\n                            i += 3;\r\n                        }\r\n                    }\r\n                }\r\n            };\r\n            var positions = instance.getVerticesData(_buffer__WEBPACK_IMPORTED_MODULE_2__[\"VertexBuffer\"].PositionKind);\r\n            positionFunction(positions);\r\n            if (instance._boundingInfo) {\r\n                instance._boundingInfo.reConstruct(minimum_1, maximum_1, instance._worldMatrix);\r\n            }\r\n            else {\r\n                instance._boundingInfo = new _Culling_boundingInfo__WEBPACK_IMPORTED_MODULE_4__[\"BoundingInfo\"](minimum_1, maximum_1, instance._worldMatrix);\r\n            }\r\n            instance.updateVerticesData(_buffer__WEBPACK_IMPORTED_MODULE_2__[\"VertexBuffer\"].PositionKind, positions, false, false);\r\n            if (options.colors) {\r\n                var colors = instance.getVerticesData(_buffer__WEBPACK_IMPORTED_MODULE_2__[\"VertexBuffer\"].ColorKind);\r\n                for (var c = 0, colorIndex = 0; c < options.colors.length; c++, colorIndex += 4) {\r\n                    var color = options.colors[c];\r\n                    colors[colorIndex] = color.r;\r\n                    colors[colorIndex + 1] = color.g;\r\n                    colors[colorIndex + 2] = color.b;\r\n                    colors[colorIndex + 3] = color.a;\r\n                }\r\n                instance.updateVerticesData(_buffer__WEBPACK_IMPORTED_MODULE_2__[\"VertexBuffer\"].ColorKind, colors, false, false);\r\n            }\r\n            if (options.uvs) {\r\n                var uvs = instance.getVerticesData(_buffer__WEBPACK_IMPORTED_MODULE_2__[\"VertexBuffer\"].UVKind);\r\n                for (var i = 0; i < options.uvs.length; i++) {\r\n                    uvs[i * 2] = options.uvs[i].x;\r\n                    uvs[i * 2 + 1] = options.uvs[i].y;\r\n                }\r\n                instance.updateVerticesData(_buffer__WEBPACK_IMPORTED_MODULE_2__[\"VertexBuffer\"].UVKind, uvs, false, false);\r\n            }\r\n            if (!instance.areNormalsFrozen || instance.isFacetDataEnabled) {\r\n                var indices = instance.getIndices();\r\n                var normals = instance.getVerticesData(_buffer__WEBPACK_IMPORTED_MODULE_2__[\"VertexBuffer\"].NormalKind);\r\n                var params = instance.isFacetDataEnabled ? instance.getFacetDataParameters() : null;\r\n                _mesh_vertexData__WEBPACK_IMPORTED_MODULE_3__[\"VertexData\"].ComputeNormals(positions, indices, normals, params);\r\n                if (instance._creationDataStorage && instance._creationDataStorage.closePath) {\r\n                    var indexFirst = 0;\r\n                    var indexLast = 0;\r\n                    for (var p = 0; p < pathArray.length; p++) {\r\n                        indexFirst = instance._creationDataStorage.idx[p] * 3;\r\n                        if (p + 1 < pathArray.length) {\r\n                            indexLast = (instance._creationDataStorage.idx[p + 1] - 1) * 3;\r\n                        }\r\n                        else {\r\n                            indexLast = normals.length - 3;\r\n                        }\r\n                        normals[indexFirst] = (normals[indexFirst] + normals[indexLast]) * 0.5;\r\n                        normals[indexFirst + 1] = (normals[indexFirst + 1] + normals[indexLast + 1]) * 0.5;\r\n                        normals[indexFirst + 2] = (normals[indexFirst + 2] + normals[indexLast + 2]) * 0.5;\r\n                        normals[indexLast] = normals[indexFirst];\r\n                        normals[indexLast + 1] = normals[indexFirst + 1];\r\n                        normals[indexLast + 2] = normals[indexFirst + 2];\r\n                    }\r\n                }\r\n                if (!(instance.areNormalsFrozen)) {\r\n                    instance.updateVerticesData(_buffer__WEBPACK_IMPORTED_MODULE_2__[\"VertexBuffer\"].NormalKind, normals, false, false);\r\n                }\r\n            }\r\n            return instance;\r\n        }\r\n        else { // new ribbon creation\r\n            var ribbon = new _mesh__WEBPACK_IMPORTED_MODULE_1__[\"Mesh\"](name, scene);\r\n            ribbon._originalBuilderSideOrientation = sideOrientation;\r\n            ribbon._creationDataStorage = new _mesh__WEBPACK_IMPORTED_MODULE_1__[\"_CreationDataStorage\"]();\r\n            var vertexData = _mesh_vertexData__WEBPACK_IMPORTED_MODULE_3__[\"VertexData\"].CreateRibbon(options);\r\n            if (closePath) {\r\n                ribbon._creationDataStorage.idx = vertexData._idx;\r\n            }\r\n            ribbon._creationDataStorage.closePath = closePath;\r\n            ribbon._creationDataStorage.closeArray = closeArray;\r\n            vertexData.applyToMesh(ribbon, updatable);\r\n            return ribbon;\r\n        }\r\n    };\r\n    return RibbonBuilder;\r\n}());\r\n\r\n//# sourceMappingURL=ribbonBuilder.js.map\n\n//# sourceURL=webpack:///./node_modules/@babylonjs/core/Meshes/Builders/ribbonBuilder.js?");

/***/ }),

/***/ "./node_modules/@babylonjs/core/Meshes/Builders/shapeBuilder.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Meshes/Builders/shapeBuilder.js ***!
  \**********************************************************************/
/*! exports provided: ShapeBuilder */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ShapeBuilder\", function() { return ShapeBuilder; });\n/* harmony import */ var _Maths_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Maths/math */ \"./node_modules/@babylonjs/core/Maths/math.js\");\n/* harmony import */ var _mesh__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../mesh */ \"./node_modules/@babylonjs/core/Meshes/mesh.js\");\n/* harmony import */ var _ribbonBuilder__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ribbonBuilder */ \"./node_modules/@babylonjs/core/Meshes/Builders/ribbonBuilder.js\");\n\r\n\r\n\r\n_mesh__WEBPACK_IMPORTED_MODULE_1__[\"Mesh\"].ExtrudeShape = function (name, shape, path, scale, rotation, cap, scene, updatable, sideOrientation, instance) {\r\n    if (scene === void 0) { scene = null; }\r\n    var options = {\r\n        shape: shape,\r\n        path: path,\r\n        scale: scale,\r\n        rotation: rotation,\r\n        cap: (cap === 0) ? 0 : cap || _mesh__WEBPACK_IMPORTED_MODULE_1__[\"Mesh\"].NO_CAP,\r\n        sideOrientation: sideOrientation,\r\n        instance: instance,\r\n        updatable: updatable\r\n    };\r\n    return ShapeBuilder.ExtrudeShape(name, options, scene);\r\n};\r\n_mesh__WEBPACK_IMPORTED_MODULE_1__[\"Mesh\"].ExtrudeShapeCustom = function (name, shape, path, scaleFunction, rotationFunction, ribbonCloseArray, ribbonClosePath, cap, scene, updatable, sideOrientation, instance) {\r\n    var options = {\r\n        shape: shape,\r\n        path: path,\r\n        scaleFunction: scaleFunction,\r\n        rotationFunction: rotationFunction,\r\n        ribbonCloseArray: ribbonCloseArray,\r\n        ribbonClosePath: ribbonClosePath,\r\n        cap: (cap === 0) ? 0 : cap || _mesh__WEBPACK_IMPORTED_MODULE_1__[\"Mesh\"].NO_CAP,\r\n        sideOrientation: sideOrientation,\r\n        instance: instance,\r\n        updatable: updatable\r\n    };\r\n    return ShapeBuilder.ExtrudeShapeCustom(name, options, scene);\r\n};\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n */\r\nvar ShapeBuilder = /** @class */ (function () {\r\n    function ShapeBuilder() {\r\n    }\r\n    /**\r\n     * Creates an extruded shape mesh. The extrusion is a parametric shape. It has no predefined shape. Its final shape will depend on the input parameters.\r\n     * * The parameter `shape` is a required array of successive Vector3. This array depicts the shape to be extruded in its local space : the shape must be designed in the xOy plane and will be extruded along the Z axis.\r\n     * * The parameter `path` is a required array of successive Vector3. This is the axis curve the shape is extruded along.\r\n     * * The parameter `rotation` (float, default 0 radians) is the angle value to rotate the shape each step (each path point), from the former step (so rotation added each step) along the curve.\r\n     * * The parameter `scale` (float, default 1) is the value to scale the shape.\r\n     * * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL\r\n     * * The optional parameter `instance` is an instance of an existing ExtrudedShape object to be updated with the passed `shape`, `path`, `scale` or `rotation` parameters : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#extruded-shape\r\n     * * Remember you can only change the shape or path point positions, not their number when updating an extruded shape.\r\n     * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n     * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\r\n     * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture.\r\n     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\r\n     * @param name defines the name of the mesh\r\n     * @param options defines the options used to create the mesh\r\n     * @param scene defines the hosting scene\r\n     * @returns the extruded shape mesh\r\n     * @see https://doc.babylonjs.com/how_to/parametric_shapes\r\n     * @see https://doc.babylonjs.com/how_to/parametric_shapes#extruded-shapes\r\n     */\r\n    ShapeBuilder.ExtrudeShape = function (name, options, scene) {\r\n        if (scene === void 0) { scene = null; }\r\n        var path = options.path;\r\n        var shape = options.shape;\r\n        var scale = options.scale || 1;\r\n        var rotation = options.rotation || 0;\r\n        var cap = (options.cap === 0) ? 0 : options.cap || _mesh__WEBPACK_IMPORTED_MODULE_1__[\"Mesh\"].NO_CAP;\r\n        var updatable = options.updatable;\r\n        var sideOrientation = _mesh__WEBPACK_IMPORTED_MODULE_1__[\"Mesh\"]._GetDefaultSideOrientation(options.sideOrientation);\r\n        var instance = options.instance || null;\r\n        var invertUV = options.invertUV || false;\r\n        return ShapeBuilder._ExtrudeShapeGeneric(name, shape, path, scale, rotation, null, null, false, false, cap, false, scene, updatable ? true : false, sideOrientation, instance, invertUV, options.frontUVs || null, options.backUVs || null);\r\n    };\r\n    /**\r\n     * Creates an custom extruded shape mesh.\r\n     * The custom extrusion is a parametric shape. It has no predefined shape. Its final shape will depend on the input parameters.\r\n     * * The parameter `shape` is a required array of successive Vector3. This array depicts the shape to be extruded in its local space : the shape must be designed in the xOy plane and will be extruded along the Z axis.\r\n     * * The parameter `path` is a required array of successive Vector3. This is the axis curve the shape is extruded along.\r\n     * * The parameter `rotationFunction` (JS function) is a custom Javascript function called on each path point. This function is passed the position i of the point in the path and the distance of this point from the begining of the path\r\n     * * It must returns a float value that will be the rotation in radians applied to the shape on each path point.\r\n     * * The parameter `scaleFunction` (JS function) is a custom Javascript function called on each path point. This function is passed the position i of the point in the path and the distance of this point from the begining of the path\r\n     * * It must returns a float value that will be the scale value applied to the shape on each path point\r\n     * * The parameter `ribbonClosePath` (boolean, default false) forces the extrusion underlying ribbon to close all the paths in its `pathArray`\r\n     * * The parameter `ribbonCloseArray` (boolean, default false) forces the extrusion underlying ribbon to close its `pathArray`\r\n     * * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL\r\n     * * The optional parameter `instance` is an instance of an existing ExtrudedShape object to be updated with the passed `shape`, `path`, `scale` or `rotation` parameters : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#extruded-shape\r\n     * * Remember you can only change the shape or path point positions, not their number when updating an extruded shape\r\n     * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n     * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\r\n     * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture\r\n     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n     * @param name defines the name of the mesh\r\n     * @param options defines the options used to create the mesh\r\n     * @param scene defines the hosting scene\r\n     * @returns the custom extruded shape mesh\r\n     * @see https://doc.babylonjs.com/how_to/parametric_shapes#custom-extruded-shapes\r\n     * @see https://doc.babylonjs.com/how_to/parametric_shapes\r\n     * @see https://doc.babylonjs.com/how_to/parametric_shapes#extruded-shapes\r\n     */\r\n    ShapeBuilder.ExtrudeShapeCustom = function (name, options, scene) {\r\n        if (scene === void 0) { scene = null; }\r\n        var path = options.path;\r\n        var shape = options.shape;\r\n        var scaleFunction = options.scaleFunction || (function () { return 1; });\r\n        var rotationFunction = options.rotationFunction || (function () { return 0; });\r\n        var ribbonCloseArray = options.ribbonCloseArray || false;\r\n        var ribbonClosePath = options.ribbonClosePath || false;\r\n        var cap = (options.cap === 0) ? 0 : options.cap || _mesh__WEBPACK_IMPORTED_MODULE_1__[\"Mesh\"].NO_CAP;\r\n        var updatable = options.updatable;\r\n        var sideOrientation = _mesh__WEBPACK_IMPORTED_MODULE_1__[\"Mesh\"]._GetDefaultSideOrientation(options.sideOrientation);\r\n        var instance = options.instance;\r\n        var invertUV = options.invertUV || false;\r\n        return ShapeBuilder._ExtrudeShapeGeneric(name, shape, path, null, null, scaleFunction, rotationFunction, ribbonCloseArray, ribbonClosePath, cap, true, scene, updatable ? true : false, sideOrientation, instance || null, invertUV, options.frontUVs || null, options.backUVs || null);\r\n    };\r\n    ShapeBuilder._ExtrudeShapeGeneric = function (name, shape, curve, scale, rotation, scaleFunction, rotateFunction, rbCA, rbCP, cap, custom, scene, updtbl, side, instance, invertUV, frontUVs, backUVs) {\r\n        // extrusion geometry\r\n        var extrusionPathArray = function (shape, curve, path3D, shapePaths, scale, rotation, scaleFunction, rotateFunction, cap, custom) {\r\n            var tangents = path3D.getTangents();\r\n            var normals = path3D.getNormals();\r\n            var binormals = path3D.getBinormals();\r\n            var distances = path3D.getDistances();\r\n            var angle = 0;\r\n            var returnScale = function () { return scale !== null ? scale : 1; };\r\n            var returnRotation = function () { return rotation !== null ? rotation : 0; };\r\n            var rotate = custom && rotateFunction ? rotateFunction : returnRotation;\r\n            var scl = custom && scaleFunction ? scaleFunction : returnScale;\r\n            var index = (cap === _mesh__WEBPACK_IMPORTED_MODULE_1__[\"Mesh\"].NO_CAP || cap === _mesh__WEBPACK_IMPORTED_MODULE_1__[\"Mesh\"].CAP_END) ? 0 : 2;\r\n            var rotationMatrix = _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Tmp\"].Matrix[0];\r\n            for (var i = 0; i < curve.length; i++) {\r\n                var shapePath = new Array();\r\n                var angleStep = rotate(i, distances[i]);\r\n                var scaleRatio = scl(i, distances[i]);\r\n                for (var p = 0; p < shape.length; p++) {\r\n                    _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Matrix\"].RotationAxisToRef(tangents[i], angle, rotationMatrix);\r\n                    var planed = ((tangents[i].scale(shape[p].z)).add(normals[i].scale(shape[p].x)).add(binormals[i].scale(shape[p].y)));\r\n                    var rotated = shapePath[p] ? shapePath[p] : _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"].Zero();\r\n                    _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"].TransformCoordinatesToRef(planed, rotationMatrix, rotated);\r\n                    rotated.scaleInPlace(scaleRatio).addInPlace(curve[i]);\r\n                    shapePath[p] = rotated;\r\n                }\r\n                shapePaths[index] = shapePath;\r\n                angle += angleStep;\r\n                index++;\r\n            }\r\n            // cap\r\n            var capPath = function (shapePath) {\r\n                var pointCap = Array();\r\n                var barycenter = _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"].Zero();\r\n                var i;\r\n                for (i = 0; i < shapePath.length; i++) {\r\n                    barycenter.addInPlace(shapePath[i]);\r\n                }\r\n                barycenter.scaleInPlace(1.0 / shapePath.length);\r\n                for (i = 0; i < shapePath.length; i++) {\r\n                    pointCap.push(barycenter);\r\n                }\r\n                return pointCap;\r\n            };\r\n            switch (cap) {\r\n                case _mesh__WEBPACK_IMPORTED_MODULE_1__[\"Mesh\"].NO_CAP:\r\n                    break;\r\n                case _mesh__WEBPACK_IMPORTED_MODULE_1__[\"Mesh\"].CAP_START:\r\n                    shapePaths[0] = capPath(shapePaths[2]);\r\n                    shapePaths[1] = shapePaths[2];\r\n                    break;\r\n                case _mesh__WEBPACK_IMPORTED_MODULE_1__[\"Mesh\"].CAP_END:\r\n                    shapePaths[index] = shapePaths[index - 1];\r\n                    shapePaths[index + 1] = capPath(shapePaths[index - 1]);\r\n                    break;\r\n                case _mesh__WEBPACK_IMPORTED_MODULE_1__[\"Mesh\"].CAP_ALL:\r\n                    shapePaths[0] = capPath(shapePaths[2]);\r\n                    shapePaths[1] = shapePaths[2];\r\n                    shapePaths[index] = shapePaths[index - 1];\r\n                    shapePaths[index + 1] = capPath(shapePaths[index - 1]);\r\n                    break;\r\n                default:\r\n                    break;\r\n            }\r\n            return shapePaths;\r\n        };\r\n        var path3D;\r\n        var pathArray;\r\n        if (instance) { // instance update\r\n            var storage = instance._creationDataStorage;\r\n            path3D = storage.path3D.update(curve);\r\n            pathArray = extrusionPathArray(shape, curve, storage.path3D, storage.pathArray, scale, rotation, scaleFunction, rotateFunction, storage.cap, custom);\r\n            instance = _mesh__WEBPACK_IMPORTED_MODULE_1__[\"Mesh\"].CreateRibbon(\"\", pathArray, false, false, 0, scene || undefined, false, 0, instance);\r\n            return instance;\r\n        }\r\n        // extruded shape creation\r\n        path3D = new _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Path3D\"](curve);\r\n        var newShapePaths = new Array();\r\n        cap = (cap < 0 || cap > 3) ? 0 : cap;\r\n        pathArray = extrusionPathArray(shape, curve, path3D, newShapePaths, scale, rotation, scaleFunction, rotateFunction, cap, custom);\r\n        var extrudedGeneric = _ribbonBuilder__WEBPACK_IMPORTED_MODULE_2__[\"RibbonBuilder\"].CreateRibbon(name, { pathArray: pathArray, closeArray: rbCA, closePath: rbCP, updatable: updtbl, sideOrientation: side, invertUV: invertUV, frontUVs: frontUVs || undefined, backUVs: backUVs || undefined }, scene);\r\n        extrudedGeneric._creationDataStorage.pathArray = pathArray;\r\n        extrudedGeneric._creationDataStorage.path3D = path3D;\r\n        extrudedGeneric._creationDataStorage.cap = cap;\r\n        return extrudedGeneric;\r\n    };\r\n    return ShapeBuilder;\r\n}());\r\n\r\n//# sourceMappingURL=shapeBuilder.js.map\n\n//# sourceURL=webpack:///./node_modules/@babylonjs/core/Meshes/Builders/shapeBuilder.js?");

/***/ }),

/***/ "./node_modules/@babylonjs/core/Meshes/Builders/sphereBuilder.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Meshes/Builders/sphereBuilder.js ***!
  \***********************************************************************/
/*! exports provided: SphereBuilder */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SphereBuilder\", function() { return SphereBuilder; });\n/* harmony import */ var _Maths_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Maths/math */ \"./node_modules/@babylonjs/core/Maths/math.js\");\n/* harmony import */ var _mesh__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../mesh */ \"./node_modules/@babylonjs/core/Meshes/mesh.js\");\n/* harmony import */ var _mesh_vertexData__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../mesh.vertexData */ \"./node_modules/@babylonjs/core/Meshes/mesh.vertexData.js\");\n\r\n\r\n\r\n_mesh_vertexData__WEBPACK_IMPORTED_MODULE_2__[\"VertexData\"].CreateSphere = function (options) {\r\n    var segments = options.segments || 32;\r\n    var diameterX = options.diameterX || options.diameter || 1;\r\n    var diameterY = options.diameterY || options.diameter || 1;\r\n    var diameterZ = options.diameterZ || options.diameter || 1;\r\n    var arc = options.arc && (options.arc <= 0 || options.arc > 1) ? 1.0 : options.arc || 1.0;\r\n    var slice = options.slice && (options.slice <= 0) ? 1.0 : options.slice || 1.0;\r\n    var sideOrientation = (options.sideOrientation === 0) ? 0 : options.sideOrientation || _mesh_vertexData__WEBPACK_IMPORTED_MODULE_2__[\"VertexData\"].DEFAULTSIDE;\r\n    var radius = new _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](diameterX / 2, diameterY / 2, diameterZ / 2);\r\n    var totalZRotationSteps = 2 + segments;\r\n    var totalYRotationSteps = 2 * totalZRotationSteps;\r\n    var indices = [];\r\n    var positions = [];\r\n    var normals = [];\r\n    var uvs = [];\r\n    for (var zRotationStep = 0; zRotationStep <= totalZRotationSteps; zRotationStep++) {\r\n        var normalizedZ = zRotationStep / totalZRotationSteps;\r\n        var angleZ = normalizedZ * Math.PI * slice;\r\n        for (var yRotationStep = 0; yRotationStep <= totalYRotationSteps; yRotationStep++) {\r\n            var normalizedY = yRotationStep / totalYRotationSteps;\r\n            var angleY = normalizedY * Math.PI * 2 * arc;\r\n            var rotationZ = _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Matrix\"].RotationZ(-angleZ);\r\n            var rotationY = _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Matrix\"].RotationY(angleY);\r\n            var afterRotZ = _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"].TransformCoordinates(_Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"].Up(), rotationZ);\r\n            var complete = _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"].TransformCoordinates(afterRotZ, rotationY);\r\n            var vertex = complete.multiply(radius);\r\n            var normal = complete.divide(radius).normalize();\r\n            positions.push(vertex.x, vertex.y, vertex.z);\r\n            normals.push(normal.x, normal.y, normal.z);\r\n            uvs.push(normalizedY, normalizedZ);\r\n        }\r\n        if (zRotationStep > 0) {\r\n            var verticesCount = positions.length / 3;\r\n            for (var firstIndex = verticesCount - 2 * (totalYRotationSteps + 1); (firstIndex + totalYRotationSteps + 2) < verticesCount; firstIndex++) {\r\n                indices.push((firstIndex));\r\n                indices.push((firstIndex + 1));\r\n                indices.push(firstIndex + totalYRotationSteps + 1);\r\n                indices.push((firstIndex + totalYRotationSteps + 1));\r\n                indices.push((firstIndex + 1));\r\n                indices.push((firstIndex + totalYRotationSteps + 2));\r\n            }\r\n        }\r\n    }\r\n    // Sides\r\n    _mesh_vertexData__WEBPACK_IMPORTED_MODULE_2__[\"VertexData\"]._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\r\n    // Result\r\n    var vertexData = new _mesh_vertexData__WEBPACK_IMPORTED_MODULE_2__[\"VertexData\"]();\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n    return vertexData;\r\n};\r\n_mesh__WEBPACK_IMPORTED_MODULE_1__[\"Mesh\"].CreateSphere = function (name, segments, diameter, scene, updatable, sideOrientation) {\r\n    var options = {\r\n        segments: segments,\r\n        diameterX: diameter,\r\n        diameterY: diameter,\r\n        diameterZ: diameter,\r\n        sideOrientation: sideOrientation,\r\n        updatable: updatable\r\n    };\r\n    return SphereBuilder.CreateSphere(name, options, scene);\r\n};\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n */\r\nvar SphereBuilder = /** @class */ (function () {\r\n    function SphereBuilder() {\r\n    }\r\n    /**\r\n     * Creates a sphere mesh\r\n     * * The parameter `diameter` sets the diameter size (float) of the sphere (default 1)\r\n     * * You can set some different sphere dimensions, for instance to build an ellipsoid, by using the parameters `diameterX`, `diameterY` and `diameterZ` (all by default have the same value of `diameter`)\r\n     * * The parameter `segments` sets the sphere number of horizontal stripes (positive integer, default 32)\r\n     * * You can create an unclosed sphere with the parameter `arc` (positive float, default 1), valued between 0 and 1, what is the ratio of the circumference (latitude) : 2 x PI x ratio\r\n     * * You can create an unclosed sphere on its height with the parameter `slice` (positive float, default1), valued between 0 and 1, what is the height ratio (longitude)\r\n     * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n     * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\r\n     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n     * @param name defines the name of the mesh\r\n     * @param options defines the options used to create the mesh\r\n     * @param scene defines the hosting scene\r\n     * @returns the sphere mesh\r\n     * @see https://doc.babylonjs.com/how_to/set_shapes#sphere\r\n     */\r\n    SphereBuilder.CreateSphere = function (name, options, scene) {\r\n        var sphere = new _mesh__WEBPACK_IMPORTED_MODULE_1__[\"Mesh\"](name, scene);\r\n        options.sideOrientation = _mesh__WEBPACK_IMPORTED_MODULE_1__[\"Mesh\"]._GetDefaultSideOrientation(options.sideOrientation);\r\n        sphere._originalBuilderSideOrientation = options.sideOrientation;\r\n        var vertexData = _mesh_vertexData__WEBPACK_IMPORTED_MODULE_2__[\"VertexData\"].CreateSphere(options);\r\n        vertexData.applyToMesh(sphere, options.updatable);\r\n        return sphere;\r\n    };\r\n    return SphereBuilder;\r\n}());\r\n\r\n//# sourceMappingURL=sphereBuilder.js.map\n\n//# sourceURL=webpack:///./node_modules/@babylonjs/core/Meshes/Builders/sphereBuilder.js?");

/***/ }),

/***/ "./node_modules/@babylonjs/core/Meshes/Builders/torusBuilder.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Meshes/Builders/torusBuilder.js ***!
  \**********************************************************************/
/*! exports provided: TorusBuilder */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TorusBuilder\", function() { return TorusBuilder; });\n/* harmony import */ var _Maths_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Maths/math */ \"./node_modules/@babylonjs/core/Maths/math.js\");\n/* harmony import */ var _mesh__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../mesh */ \"./node_modules/@babylonjs/core/Meshes/mesh.js\");\n/* harmony import */ var _mesh_vertexData__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../mesh.vertexData */ \"./node_modules/@babylonjs/core/Meshes/mesh.vertexData.js\");\n\r\n\r\n\r\n_mesh_vertexData__WEBPACK_IMPORTED_MODULE_2__[\"VertexData\"].CreateTorus = function (options) {\r\n    var indices = [];\r\n    var positions = [];\r\n    var normals = [];\r\n    var uvs = [];\r\n    var diameter = options.diameter || 1;\r\n    var thickness = options.thickness || 0.5;\r\n    var tessellation = options.tessellation || 16;\r\n    var sideOrientation = (options.sideOrientation === 0) ? 0 : options.sideOrientation || _mesh_vertexData__WEBPACK_IMPORTED_MODULE_2__[\"VertexData\"].DEFAULTSIDE;\r\n    var stride = tessellation + 1;\r\n    for (var i = 0; i <= tessellation; i++) {\r\n        var u = i / tessellation;\r\n        var outerAngle = i * Math.PI * 2.0 / tessellation - Math.PI / 2.0;\r\n        var transform = _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Matrix\"].Translation(diameter / 2.0, 0, 0).multiply(_Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Matrix\"].RotationY(outerAngle));\r\n        for (var j = 0; j <= tessellation; j++) {\r\n            var v = 1 - j / tessellation;\r\n            var innerAngle = j * Math.PI * 2.0 / tessellation + Math.PI;\r\n            var dx = Math.cos(innerAngle);\r\n            var dy = Math.sin(innerAngle);\r\n            // Create a vertex.\r\n            var normal = new _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](dx, dy, 0);\r\n            var position = normal.scale(thickness / 2);\r\n            var textureCoordinate = new _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector2\"](u, v);\r\n            position = _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"].TransformCoordinates(position, transform);\r\n            normal = _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"].TransformNormal(normal, transform);\r\n            positions.push(position.x, position.y, position.z);\r\n            normals.push(normal.x, normal.y, normal.z);\r\n            uvs.push(textureCoordinate.x, textureCoordinate.y);\r\n            // And create indices for two triangles.\r\n            var nextI = (i + 1) % stride;\r\n            var nextJ = (j + 1) % stride;\r\n            indices.push(i * stride + j);\r\n            indices.push(i * stride + nextJ);\r\n            indices.push(nextI * stride + j);\r\n            indices.push(i * stride + nextJ);\r\n            indices.push(nextI * stride + nextJ);\r\n            indices.push(nextI * stride + j);\r\n        }\r\n    }\r\n    // Sides\r\n    _mesh_vertexData__WEBPACK_IMPORTED_MODULE_2__[\"VertexData\"]._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\r\n    // Result\r\n    var vertexData = new _mesh_vertexData__WEBPACK_IMPORTED_MODULE_2__[\"VertexData\"]();\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n    return vertexData;\r\n};\r\n_mesh__WEBPACK_IMPORTED_MODULE_1__[\"Mesh\"].CreateTorus = function (name, diameter, thickness, tessellation, scene, updatable, sideOrientation) {\r\n    var options = {\r\n        diameter: diameter,\r\n        thickness: thickness,\r\n        tessellation: tessellation,\r\n        sideOrientation: sideOrientation,\r\n        updatable: updatable\r\n    };\r\n    return TorusBuilder.CreateTorus(name, options, scene);\r\n};\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n */\r\nvar TorusBuilder = /** @class */ (function () {\r\n    function TorusBuilder() {\r\n    }\r\n    /**\r\n     * Creates a torus mesh\r\n     * * The parameter `diameter` sets the diameter size (float) of the torus (default 1)\r\n     * * The parameter `thickness` sets the diameter size of the tube of the torus (float, default 0.5)\r\n     * * The parameter `tessellation` sets the number of torus sides (postive integer, default 16)\r\n     * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n     * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\r\n     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\r\n     * @param name defines the name of the mesh\r\n     * @param options defines the options used to create the mesh\r\n     * @param scene defines the hosting scene\r\n     * @returns the torus mesh\r\n     * @see https://doc.babylonjs.com/how_to/set_shapes#torus\r\n     */\r\n    TorusBuilder.CreateTorus = function (name, options, scene) {\r\n        var torus = new _mesh__WEBPACK_IMPORTED_MODULE_1__[\"Mesh\"](name, scene);\r\n        options.sideOrientation = _mesh__WEBPACK_IMPORTED_MODULE_1__[\"Mesh\"]._GetDefaultSideOrientation(options.sideOrientation);\r\n        torus._originalBuilderSideOrientation = options.sideOrientation;\r\n        var vertexData = _mesh_vertexData__WEBPACK_IMPORTED_MODULE_2__[\"VertexData\"].CreateTorus(options);\r\n        vertexData.applyToMesh(torus, options.updatable);\r\n        return torus;\r\n    };\r\n    return TorusBuilder;\r\n}());\r\n\r\n//# sourceMappingURL=torusBuilder.js.map\n\n//# sourceURL=webpack:///./node_modules/@babylonjs/core/Meshes/Builders/torusBuilder.js?");

/***/ }),

/***/ "./node_modules/@babylonjs/core/Meshes/Builders/torusKnotBuilder.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Meshes/Builders/torusKnotBuilder.js ***!
  \**************************************************************************/
/*! exports provided: TorusKnotBuilder */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TorusKnotBuilder\", function() { return TorusKnotBuilder; });\n/* harmony import */ var _Maths_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Maths/math */ \"./node_modules/@babylonjs/core/Maths/math.js\");\n/* harmony import */ var _mesh__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../mesh */ \"./node_modules/@babylonjs/core/Meshes/mesh.js\");\n/* harmony import */ var _mesh_vertexData__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../mesh.vertexData */ \"./node_modules/@babylonjs/core/Meshes/mesh.vertexData.js\");\n\r\n\r\n\r\n_mesh_vertexData__WEBPACK_IMPORTED_MODULE_2__[\"VertexData\"].CreateTorusKnot = function (options) {\r\n    var indices = new Array();\r\n    var positions = new Array();\r\n    var normals = new Array();\r\n    var uvs = new Array();\r\n    var radius = options.radius || 2;\r\n    var tube = options.tube || 0.5;\r\n    var radialSegments = options.radialSegments || 32;\r\n    var tubularSegments = options.tubularSegments || 32;\r\n    var p = options.p || 2;\r\n    var q = options.q || 3;\r\n    var sideOrientation = (options.sideOrientation === 0) ? 0 : options.sideOrientation || _mesh_vertexData__WEBPACK_IMPORTED_MODULE_2__[\"VertexData\"].DEFAULTSIDE;\r\n    // Helper\r\n    var getPos = function (angle) {\r\n        var cu = Math.cos(angle);\r\n        var su = Math.sin(angle);\r\n        var quOverP = q / p * angle;\r\n        var cs = Math.cos(quOverP);\r\n        var tx = radius * (2 + cs) * 0.5 * cu;\r\n        var ty = radius * (2 + cs) * su * 0.5;\r\n        var tz = radius * Math.sin(quOverP) * 0.5;\r\n        return new _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](tx, ty, tz);\r\n    };\r\n    // Vertices\r\n    var i;\r\n    var j;\r\n    for (i = 0; i <= radialSegments; i++) {\r\n        var modI = i % radialSegments;\r\n        var u = modI / radialSegments * 2 * p * Math.PI;\r\n        var p1 = getPos(u);\r\n        var p2 = getPos(u + 0.01);\r\n        var tang = p2.subtract(p1);\r\n        var n = p2.add(p1);\r\n        var bitan = _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"].Cross(tang, n);\r\n        n = _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"].Cross(bitan, tang);\r\n        bitan.normalize();\r\n        n.normalize();\r\n        for (j = 0; j < tubularSegments; j++) {\r\n            var modJ = j % tubularSegments;\r\n            var v = modJ / tubularSegments * 2 * Math.PI;\r\n            var cx = -tube * Math.cos(v);\r\n            var cy = tube * Math.sin(v);\r\n            positions.push(p1.x + cx * n.x + cy * bitan.x);\r\n            positions.push(p1.y + cx * n.y + cy * bitan.y);\r\n            positions.push(p1.z + cx * n.z + cy * bitan.z);\r\n            uvs.push(i / radialSegments);\r\n            uvs.push(j / tubularSegments);\r\n        }\r\n    }\r\n    for (i = 0; i < radialSegments; i++) {\r\n        for (j = 0; j < tubularSegments; j++) {\r\n            var jNext = (j + 1) % tubularSegments;\r\n            var a = i * tubularSegments + j;\r\n            var b = (i + 1) * tubularSegments + j;\r\n            var c = (i + 1) * tubularSegments + jNext;\r\n            var d = i * tubularSegments + jNext;\r\n            indices.push(d);\r\n            indices.push(b);\r\n            indices.push(a);\r\n            indices.push(d);\r\n            indices.push(c);\r\n            indices.push(b);\r\n        }\r\n    }\r\n    // Normals\r\n    _mesh_vertexData__WEBPACK_IMPORTED_MODULE_2__[\"VertexData\"].ComputeNormals(positions, indices, normals);\r\n    // Sides\r\n    _mesh_vertexData__WEBPACK_IMPORTED_MODULE_2__[\"VertexData\"]._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\r\n    // Result\r\n    var vertexData = new _mesh_vertexData__WEBPACK_IMPORTED_MODULE_2__[\"VertexData\"]();\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n    return vertexData;\r\n};\r\n_mesh__WEBPACK_IMPORTED_MODULE_1__[\"Mesh\"].CreateTorusKnot = function (name, radius, tube, radialSegments, tubularSegments, p, q, scene, updatable, sideOrientation) {\r\n    var options = {\r\n        radius: radius,\r\n        tube: tube,\r\n        radialSegments: radialSegments,\r\n        tubularSegments: tubularSegments,\r\n        p: p,\r\n        q: q,\r\n        sideOrientation: sideOrientation,\r\n        updatable: updatable\r\n    };\r\n    return TorusKnotBuilder.CreateTorusKnot(name, options, scene);\r\n};\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n */\r\nvar TorusKnotBuilder = /** @class */ (function () {\r\n    function TorusKnotBuilder() {\r\n    }\r\n    /**\r\n     * Creates a torus knot mesh\r\n     * * The parameter `radius` sets the global radius size (float) of the torus knot (default 2)\r\n     * * The parameter `radialSegments` sets the number of sides on each tube segments (positive integer, default 32)\r\n     * * The parameter `tubularSegments` sets the number of tubes to decompose the knot into (positive integer, default 32)\r\n     * * The parameters `p` and `q` are the number of windings on each axis (positive integers, default 2 and 3)\r\n     * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n     * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\r\n     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\r\n     * @param name defines the name of the mesh\r\n     * @param options defines the options used to create the mesh\r\n     * @param scene defines the hosting scene\r\n     * @returns the torus knot mesh\r\n     * @see  https://doc.babylonjs.com/how_to/set_shapes#torus-knot\r\n     */\r\n    TorusKnotBuilder.CreateTorusKnot = function (name, options, scene) {\r\n        var torusKnot = new _mesh__WEBPACK_IMPORTED_MODULE_1__[\"Mesh\"](name, scene);\r\n        options.sideOrientation = _mesh__WEBPACK_IMPORTED_MODULE_1__[\"Mesh\"]._GetDefaultSideOrientation(options.sideOrientation);\r\n        torusKnot._originalBuilderSideOrientation = options.sideOrientation;\r\n        var vertexData = _mesh_vertexData__WEBPACK_IMPORTED_MODULE_2__[\"VertexData\"].CreateTorusKnot(options);\r\n        vertexData.applyToMesh(torusKnot, options.updatable);\r\n        return torusKnot;\r\n    };\r\n    return TorusKnotBuilder;\r\n}());\r\n\r\n//# sourceMappingURL=torusKnotBuilder.js.map\n\n//# sourceURL=webpack:///./node_modules/@babylonjs/core/Meshes/Builders/torusKnotBuilder.js?");

/***/ }),

/***/ "./node_modules/@babylonjs/core/Meshes/Builders/tubeBuilder.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Meshes/Builders/tubeBuilder.js ***!
  \*********************************************************************/
/*! exports provided: TubeBuilder */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TubeBuilder\", function() { return TubeBuilder; });\n/* harmony import */ var _Maths_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Maths/math */ \"./node_modules/@babylonjs/core/Maths/math.js\");\n/* harmony import */ var _mesh__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../mesh */ \"./node_modules/@babylonjs/core/Meshes/mesh.js\");\n/* harmony import */ var _ribbonBuilder__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ribbonBuilder */ \"./node_modules/@babylonjs/core/Meshes/Builders/ribbonBuilder.js\");\n\r\n\r\n\r\n_mesh__WEBPACK_IMPORTED_MODULE_1__[\"Mesh\"].CreateTube = function (name, path, radius, tessellation, radiusFunction, cap, scene, updatable, sideOrientation, instance) {\r\n    var options = {\r\n        path: path,\r\n        radius: radius,\r\n        tessellation: tessellation,\r\n        radiusFunction: radiusFunction,\r\n        arc: 1,\r\n        cap: cap,\r\n        updatable: updatable,\r\n        sideOrientation: sideOrientation,\r\n        instance: instance\r\n    };\r\n    return TubeBuilder.CreateTube(name, options, scene);\r\n};\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n */\r\nvar TubeBuilder = /** @class */ (function () {\r\n    function TubeBuilder() {\r\n    }\r\n    /**\r\n     * Creates a tube mesh.\r\n     * The tube is a parametric shape. It has no predefined shape. Its final shape will depend on the input parameters\r\n     * * The parameter `path` is a required array of successive Vector3. It is the curve used as the axis of the tube\r\n     * * The parameter `radius` (positive float, default 1) sets the tube radius size\r\n     * * The parameter `tessellation` (positive float, default 64) is the number of sides on the tubular surface\r\n     * * The parameter `radiusFunction` (javascript function, default null) is a vanilla javascript function. If it is not null, it overwrittes the parameter `radius`\r\n     * * This function is called on each point of the tube path and is passed the index `i` of the i-th point and the distance of this point from the first point of the path. It must return a radius value (positive float)\r\n     * * The parameter `arc` (positive float, maximum 1, default 1) is the ratio to apply to the tube circumference : 2 x PI x arc\r\n     * * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL\r\n     * * The optional parameter `instance` is an instance of an existing Tube object to be updated with the passed `pathArray` parameter : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#tube\r\n     * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n     * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\r\n     * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture\r\n     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n     * @param name defines the name of the mesh\r\n     * @param options defines the options used to create the mesh\r\n     * @param scene defines the hosting scene\r\n     * @returns the tube mesh\r\n     * @see https://doc.babylonjs.com/how_to/parametric_shapes\r\n     * @see https://doc.babylonjs.com/how_to/set_shapes#tube\r\n     */\r\n    TubeBuilder.CreateTube = function (name, options, scene) {\r\n        if (scene === void 0) { scene = null; }\r\n        var path = options.path;\r\n        var instance = options.instance;\r\n        var radius = 1.0;\r\n        if (options.radius !== undefined) {\r\n            radius = options.radius;\r\n        }\r\n        else if (instance) {\r\n            radius = instance._creationDataStorage.radius;\r\n        }\r\n        var tessellation = options.tessellation || 64 | 0;\r\n        var radiusFunction = options.radiusFunction || null;\r\n        var cap = options.cap || _mesh__WEBPACK_IMPORTED_MODULE_1__[\"Mesh\"].NO_CAP;\r\n        var invertUV = options.invertUV || false;\r\n        var updatable = options.updatable;\r\n        var sideOrientation = _mesh__WEBPACK_IMPORTED_MODULE_1__[\"Mesh\"]._GetDefaultSideOrientation(options.sideOrientation);\r\n        options.arc = options.arc && (options.arc <= 0.0 || options.arc > 1.0) ? 1.0 : options.arc || 1.0;\r\n        // tube geometry\r\n        var tubePathArray = function (path, path3D, circlePaths, radius, tessellation, radiusFunction, cap, arc) {\r\n            var tangents = path3D.getTangents();\r\n            var normals = path3D.getNormals();\r\n            var distances = path3D.getDistances();\r\n            var pi2 = Math.PI * 2;\r\n            var step = pi2 / tessellation * arc;\r\n            var returnRadius = function () { return radius; };\r\n            var radiusFunctionFinal = radiusFunction || returnRadius;\r\n            var circlePath;\r\n            var rad;\r\n            var normal;\r\n            var rotated;\r\n            var rotationMatrix = _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Tmp\"].Matrix[0];\r\n            var index = (cap === _mesh__WEBPACK_IMPORTED_MODULE_1__[\"Mesh\"].NO_CAP || cap === _mesh__WEBPACK_IMPORTED_MODULE_1__[\"Mesh\"].CAP_END) ? 0 : 2;\r\n            for (var i = 0; i < path.length; i++) {\r\n                rad = radiusFunctionFinal(i, distances[i]); // current radius\r\n                circlePath = Array(); // current circle array\r\n                normal = normals[i]; // current normal\r\n                for (var t = 0; t < tessellation; t++) {\r\n                    _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Matrix\"].RotationAxisToRef(tangents[i], step * t, rotationMatrix);\r\n                    rotated = circlePath[t] ? circlePath[t] : _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"].Zero();\r\n                    _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"].TransformCoordinatesToRef(normal, rotationMatrix, rotated);\r\n                    rotated.scaleInPlace(rad).addInPlace(path[i]);\r\n                    circlePath[t] = rotated;\r\n                }\r\n                circlePaths[index] = circlePath;\r\n                index++;\r\n            }\r\n            // cap\r\n            var capPath = function (nbPoints, pathIndex) {\r\n                var pointCap = Array();\r\n                for (var i = 0; i < nbPoints; i++) {\r\n                    pointCap.push(path[pathIndex]);\r\n                }\r\n                return pointCap;\r\n            };\r\n            switch (cap) {\r\n                case _mesh__WEBPACK_IMPORTED_MODULE_1__[\"Mesh\"].NO_CAP:\r\n                    break;\r\n                case _mesh__WEBPACK_IMPORTED_MODULE_1__[\"Mesh\"].CAP_START:\r\n                    circlePaths[0] = capPath(tessellation, 0);\r\n                    circlePaths[1] = circlePaths[2].slice(0);\r\n                    break;\r\n                case _mesh__WEBPACK_IMPORTED_MODULE_1__[\"Mesh\"].CAP_END:\r\n                    circlePaths[index] = circlePaths[index - 1].slice(0);\r\n                    circlePaths[index + 1] = capPath(tessellation, path.length - 1);\r\n                    break;\r\n                case _mesh__WEBPACK_IMPORTED_MODULE_1__[\"Mesh\"].CAP_ALL:\r\n                    circlePaths[0] = capPath(tessellation, 0);\r\n                    circlePaths[1] = circlePaths[2].slice(0);\r\n                    circlePaths[index] = circlePaths[index - 1].slice(0);\r\n                    circlePaths[index + 1] = capPath(tessellation, path.length - 1);\r\n                    break;\r\n                default:\r\n                    break;\r\n            }\r\n            return circlePaths;\r\n        };\r\n        var path3D;\r\n        var pathArray;\r\n        if (instance) { // tube update\r\n            var storage = instance._creationDataStorage;\r\n            var arc = options.arc || storage.arc;\r\n            path3D = storage.path3D.update(path);\r\n            pathArray = tubePathArray(path, path3D, storage.pathArray, radius, storage.tessellation, radiusFunction, storage.cap, arc);\r\n            instance = _ribbonBuilder__WEBPACK_IMPORTED_MODULE_2__[\"RibbonBuilder\"].CreateRibbon(\"\", { pathArray: pathArray, instance: instance });\r\n            // Update mode, no need to recreate the storage.\r\n            storage.path3D = path3D;\r\n            storage.pathArray = pathArray;\r\n            storage.arc = arc;\r\n            storage.radius = radius;\r\n            return instance;\r\n        }\r\n        // tube creation\r\n        path3D = new _Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Path3D\"](path);\r\n        var newPathArray = new Array();\r\n        cap = (cap < 0 || cap > 3) ? 0 : cap;\r\n        pathArray = tubePathArray(path, path3D, newPathArray, radius, tessellation, radiusFunction, cap, options.arc);\r\n        var tube = _ribbonBuilder__WEBPACK_IMPORTED_MODULE_2__[\"RibbonBuilder\"].CreateRibbon(name, { pathArray: pathArray, closePath: true, closeArray: false, updatable: updatable, sideOrientation: sideOrientation, invertUV: invertUV, frontUVs: options.frontUVs, backUVs: options.backUVs }, scene);\r\n        tube._creationDataStorage.pathArray = pathArray;\r\n        tube._creationDataStorage.path3D = path3D;\r\n        tube._creationDataStorage.tessellation = tessellation;\r\n        tube._creationDataStorage.cap = cap;\r\n        tube._creationDataStorage.arc = options.arc;\r\n        tube._creationDataStorage.radius = radius;\r\n        return tube;\r\n    };\r\n    return TubeBuilder;\r\n}());\r\n\r\n//# sourceMappingURL=tubeBuilder.js.map\n\n//# sourceURL=webpack:///./node_modules/@babylonjs/core/Meshes/Builders/tubeBuilder.js?");

/***/ }),

/***/ "./node_modules/@babylonjs/core/Meshes/groundMesh.js":
/*!***********************************************************!*\
  !*** ./node_modules/@babylonjs/core/Meshes/groundMesh.js ***!
  \***********************************************************/
/*! exports provided: GroundMesh */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GroundMesh\", function() { return GroundMesh; });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\n/* harmony import */ var _Maths_math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Maths/math */ \"./node_modules/@babylonjs/core/Maths/math.js\");\n/* harmony import */ var _Meshes_buffer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Meshes/buffer */ \"./node_modules/@babylonjs/core/Meshes/buffer.js\");\n/* harmony import */ var _Meshes_mesh__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Meshes/mesh */ \"./node_modules/@babylonjs/core/Meshes/mesh.js\");\n\r\n\r\n\r\n\r\n_Meshes_mesh__WEBPACK_IMPORTED_MODULE_3__[\"Mesh\"]._GroundMeshParser = function (parsedMesh, scene) {\r\n    return GroundMesh.Parse(parsedMesh, scene);\r\n};\r\n/**\r\n * Mesh representing the gorund\r\n */\r\nvar GroundMesh = /** @class */ (function (_super) {\r\n    tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"](GroundMesh, _super);\r\n    function GroundMesh(name, scene) {\r\n        var _this = _super.call(this, name, scene) || this;\r\n        /** If octree should be generated */\r\n        _this.generateOctree = false;\r\n        return _this;\r\n    }\r\n    /**\r\n     * \"GroundMesh\"\r\n     * @returns \"GroundMesh\"\r\n     */\r\n    GroundMesh.prototype.getClassName = function () {\r\n        return \"GroundMesh\";\r\n    };\r\n    Object.defineProperty(GroundMesh.prototype, \"subdivisions\", {\r\n        /**\r\n         * The minimum of x and y subdivisions\r\n         */\r\n        get: function () {\r\n            return Math.min(this._subdivisionsX, this._subdivisionsY);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(GroundMesh.prototype, \"subdivisionsX\", {\r\n        /**\r\n         * X subdivisions\r\n         */\r\n        get: function () {\r\n            return this._subdivisionsX;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(GroundMesh.prototype, \"subdivisionsY\", {\r\n        /**\r\n         * Y subdivisions\r\n         */\r\n        get: function () {\r\n            return this._subdivisionsY;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * This function will update an octree to help to select the right submeshes for rendering, picking and collision computations.\r\n     * Please note that you must have a decent number of submeshes to get performance improvements when using an octree\r\n     * @param chunksCount the number of subdivisions for x and y\r\n     * @param octreeBlocksSize (Default: 32)\r\n     */\r\n    GroundMesh.prototype.optimize = function (chunksCount, octreeBlocksSize) {\r\n        if (octreeBlocksSize === void 0) { octreeBlocksSize = 32; }\r\n        this._subdivisionsX = chunksCount;\r\n        this._subdivisionsY = chunksCount;\r\n        this.subdivide(chunksCount);\r\n        // Call the octree system optimization if it is defined.\r\n        var thisAsAny = this;\r\n        if (thisAsAny.createOrUpdateSubmeshesOctree) {\r\n            thisAsAny.createOrUpdateSubmeshesOctree(octreeBlocksSize);\r\n        }\r\n    };\r\n    /**\r\n     * Returns a height (y) value in the Worl system :\r\n     * the ground altitude at the coordinates (x, z) expressed in the World system.\r\n     * @param x x coordinate\r\n     * @param z z coordinate\r\n     * @returns the ground y position if (x, z) are outside the ground surface.\r\n     */\r\n    GroundMesh.prototype.getHeightAtCoordinates = function (x, z) {\r\n        var world = this.getWorldMatrix();\r\n        var invMat = _Maths_math__WEBPACK_IMPORTED_MODULE_1__[\"Tmp\"].Matrix[5];\r\n        world.invertToRef(invMat);\r\n        var tmpVect = _Maths_math__WEBPACK_IMPORTED_MODULE_1__[\"Tmp\"].Vector3[8];\r\n        _Maths_math__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"].TransformCoordinatesFromFloatsToRef(x, 0.0, z, invMat, tmpVect); // transform x,z in the mesh local space\r\n        x = tmpVect.x;\r\n        z = tmpVect.z;\r\n        if (x < this._minX || x > this._maxX || z < this._minZ || z > this._maxZ) {\r\n            return this.position.y;\r\n        }\r\n        if (!this._heightQuads || this._heightQuads.length == 0) {\r\n            this._initHeightQuads();\r\n            this._computeHeightQuads();\r\n        }\r\n        var facet = this._getFacetAt(x, z);\r\n        var y = -(facet.x * x + facet.z * z + facet.w) / facet.y;\r\n        // return y in the World system\r\n        _Maths_math__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"].TransformCoordinatesFromFloatsToRef(0.0, y, 0.0, world, tmpVect);\r\n        return tmpVect.y;\r\n    };\r\n    /**\r\n     * Returns a normalized vector (Vector3) orthogonal to the ground\r\n     * at the ground coordinates (x, z) expressed in the World system.\r\n     * @param x x coordinate\r\n     * @param z z coordinate\r\n     * @returns Vector3(0.0, 1.0, 0.0) if (x, z) are outside the ground surface.\r\n     */\r\n    GroundMesh.prototype.getNormalAtCoordinates = function (x, z) {\r\n        var normal = new _Maths_math__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"](0.0, 1.0, 0.0);\r\n        this.getNormalAtCoordinatesToRef(x, z, normal);\r\n        return normal;\r\n    };\r\n    /**\r\n     * Updates the Vector3 passed a reference with a normalized vector orthogonal to the ground\r\n     * at the ground coordinates (x, z) expressed in the World system.\r\n     * Doesn't uptade the reference Vector3 if (x, z) are outside the ground surface.\r\n     * @param x x coordinate\r\n     * @param z z coordinate\r\n     * @param ref vector to store the result\r\n     * @returns the GroundMesh.\r\n     */\r\n    GroundMesh.prototype.getNormalAtCoordinatesToRef = function (x, z, ref) {\r\n        var world = this.getWorldMatrix();\r\n        var tmpMat = _Maths_math__WEBPACK_IMPORTED_MODULE_1__[\"Tmp\"].Matrix[5];\r\n        world.invertToRef(tmpMat);\r\n        var tmpVect = _Maths_math__WEBPACK_IMPORTED_MODULE_1__[\"Tmp\"].Vector3[8];\r\n        _Maths_math__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"].TransformCoordinatesFromFloatsToRef(x, 0.0, z, tmpMat, tmpVect); // transform x,z in the mesh local space\r\n        x = tmpVect.x;\r\n        z = tmpVect.z;\r\n        if (x < this._minX || x > this._maxX || z < this._minZ || z > this._maxZ) {\r\n            return this;\r\n        }\r\n        if (!this._heightQuads || this._heightQuads.length == 0) {\r\n            this._initHeightQuads();\r\n            this._computeHeightQuads();\r\n        }\r\n        var facet = this._getFacetAt(x, z);\r\n        _Maths_math__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"].TransformNormalFromFloatsToRef(facet.x, facet.y, facet.z, world, ref);\r\n        return this;\r\n    };\r\n    /**\r\n    * Force the heights to be recomputed for getHeightAtCoordinates() or getNormalAtCoordinates()\r\n    * if the ground has been updated.\r\n    * This can be used in the render loop.\r\n    * @returns the GroundMesh.\r\n    */\r\n    GroundMesh.prototype.updateCoordinateHeights = function () {\r\n        if (!this._heightQuads || this._heightQuads.length == 0) {\r\n            this._initHeightQuads();\r\n        }\r\n        this._computeHeightQuads();\r\n        return this;\r\n    };\r\n    // Returns the element \"facet\" from the heightQuads array relative to (x, z) local coordinates\r\n    GroundMesh.prototype._getFacetAt = function (x, z) {\r\n        // retrieve col and row from x, z coordinates in the ground local system\r\n        var col = Math.floor((x + this._maxX) * this._subdivisionsX / this._width);\r\n        var row = Math.floor(-(z + this._maxZ) * this._subdivisionsY / this._height + this._subdivisionsY);\r\n        var quad = this._heightQuads[row * this._subdivisionsX + col];\r\n        var facet;\r\n        if (z < quad.slope.x * x + quad.slope.y) {\r\n            facet = quad.facet1;\r\n        }\r\n        else {\r\n            facet = quad.facet2;\r\n        }\r\n        return facet;\r\n    };\r\n    //  Creates and populates the heightMap array with \"facet\" elements :\r\n    // a quad is two triangular facets separated by a slope, so a \"facet\" element is 1 slope + 2 facets\r\n    // slope : Vector2(c, h) = 2D diagonal line equation setting appart two triangular facets in a quad : z = cx + h\r\n    // facet1 : Vector4(a, b, c, d) = first facet 3D plane equation : ax + by + cz + d = 0\r\n    // facet2 :  Vector4(a, b, c, d) = second facet 3D plane equation : ax + by + cz + d = 0\r\n    // Returns the GroundMesh.\r\n    GroundMesh.prototype._initHeightQuads = function () {\r\n        var subdivisionsX = this._subdivisionsX;\r\n        var subdivisionsY = this._subdivisionsY;\r\n        this._heightQuads = new Array();\r\n        for (var row = 0; row < subdivisionsY; row++) {\r\n            for (var col = 0; col < subdivisionsX; col++) {\r\n                var quad = { slope: _Maths_math__WEBPACK_IMPORTED_MODULE_1__[\"Vector2\"].Zero(), facet1: new _Maths_math__WEBPACK_IMPORTED_MODULE_1__[\"Vector4\"](0.0, 0.0, 0.0, 0.0), facet2: new _Maths_math__WEBPACK_IMPORTED_MODULE_1__[\"Vector4\"](0.0, 0.0, 0.0, 0.0) };\r\n                this._heightQuads[row * subdivisionsX + col] = quad;\r\n            }\r\n        }\r\n        return this;\r\n    };\r\n    // Compute each quad element values and update the the heightMap array :\r\n    // slope : Vector2(c, h) = 2D diagonal line equation setting appart two triangular facets in a quad : z = cx + h\r\n    // facet1 : Vector4(a, b, c, d) = first facet 3D plane equation : ax + by + cz + d = 0\r\n    // facet2 :  Vector4(a, b, c, d) = second facet 3D plane equation : ax + by + cz + d = 0\r\n    // Returns the GroundMesh.\r\n    GroundMesh.prototype._computeHeightQuads = function () {\r\n        var positions = this.getVerticesData(_Meshes_buffer__WEBPACK_IMPORTED_MODULE_2__[\"VertexBuffer\"].PositionKind);\r\n        if (!positions) {\r\n            return this;\r\n        }\r\n        var v1 = _Maths_math__WEBPACK_IMPORTED_MODULE_1__[\"Tmp\"].Vector3[3];\r\n        var v2 = _Maths_math__WEBPACK_IMPORTED_MODULE_1__[\"Tmp\"].Vector3[2];\r\n        var v3 = _Maths_math__WEBPACK_IMPORTED_MODULE_1__[\"Tmp\"].Vector3[1];\r\n        var v4 = _Maths_math__WEBPACK_IMPORTED_MODULE_1__[\"Tmp\"].Vector3[0];\r\n        var v1v2 = _Maths_math__WEBPACK_IMPORTED_MODULE_1__[\"Tmp\"].Vector3[4];\r\n        var v1v3 = _Maths_math__WEBPACK_IMPORTED_MODULE_1__[\"Tmp\"].Vector3[5];\r\n        var v1v4 = _Maths_math__WEBPACK_IMPORTED_MODULE_1__[\"Tmp\"].Vector3[6];\r\n        var norm1 = _Maths_math__WEBPACK_IMPORTED_MODULE_1__[\"Tmp\"].Vector3[7];\r\n        var norm2 = _Maths_math__WEBPACK_IMPORTED_MODULE_1__[\"Tmp\"].Vector3[8];\r\n        var i = 0;\r\n        var j = 0;\r\n        var k = 0;\r\n        var cd = 0; // 2D slope coefficient : z = cd * x + h\r\n        var h = 0;\r\n        var d1 = 0; // facet plane equation : ax + by + cz + d = 0\r\n        var d2 = 0;\r\n        var subdivisionsX = this._subdivisionsX;\r\n        var subdivisionsY = this._subdivisionsY;\r\n        for (var row = 0; row < subdivisionsY; row++) {\r\n            for (var col = 0; col < subdivisionsX; col++) {\r\n                i = col * 3;\r\n                j = row * (subdivisionsX + 1) * 3;\r\n                k = (row + 1) * (subdivisionsX + 1) * 3;\r\n                v1.x = positions[j + i];\r\n                v1.y = positions[j + i + 1];\r\n                v1.z = positions[j + i + 2];\r\n                v2.x = positions[j + i + 3];\r\n                v2.y = positions[j + i + 4];\r\n                v2.z = positions[j + i + 5];\r\n                v3.x = positions[k + i];\r\n                v3.y = positions[k + i + 1];\r\n                v3.z = positions[k + i + 2];\r\n                v4.x = positions[k + i + 3];\r\n                v4.y = positions[k + i + 4];\r\n                v4.z = positions[k + i + 5];\r\n                // 2D slope V1V4\r\n                cd = (v4.z - v1.z) / (v4.x - v1.x);\r\n                h = v1.z - cd * v1.x; // v1 belongs to the slope\r\n                // facet equations :\r\n                // we compute each facet normal vector\r\n                // the equation of the facet plane is : norm.x * x + norm.y * y + norm.z * z + d = 0\r\n                // we compute the value d by applying the equation to v1 which belongs to the plane\r\n                // then we store the facet equation in a Vector4\r\n                v2.subtractToRef(v1, v1v2);\r\n                v3.subtractToRef(v1, v1v3);\r\n                v4.subtractToRef(v1, v1v4);\r\n                _Maths_math__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"].CrossToRef(v1v4, v1v3, norm1); // caution : CrossToRef uses the Tmp class\r\n                _Maths_math__WEBPACK_IMPORTED_MODULE_1__[\"Vector3\"].CrossToRef(v1v2, v1v4, norm2);\r\n                norm1.normalize();\r\n                norm2.normalize();\r\n                d1 = -(norm1.x * v1.x + norm1.y * v1.y + norm1.z * v1.z);\r\n                d2 = -(norm2.x * v2.x + norm2.y * v2.y + norm2.z * v2.z);\r\n                var quad = this._heightQuads[row * subdivisionsX + col];\r\n                quad.slope.copyFromFloats(cd, h);\r\n                quad.facet1.copyFromFloats(norm1.x, norm1.y, norm1.z, d1);\r\n                quad.facet2.copyFromFloats(norm2.x, norm2.y, norm2.z, d2);\r\n            }\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * Serializes this ground mesh\r\n     * @param serializationObject object to write serialization to\r\n     */\r\n    GroundMesh.prototype.serialize = function (serializationObject) {\r\n        _super.prototype.serialize.call(this, serializationObject);\r\n        serializationObject.subdivisionsX = this._subdivisionsX;\r\n        serializationObject.subdivisionsY = this._subdivisionsY;\r\n        serializationObject.minX = this._minX;\r\n        serializationObject.maxX = this._maxX;\r\n        serializationObject.minZ = this._minZ;\r\n        serializationObject.maxZ = this._maxZ;\r\n        serializationObject.width = this._width;\r\n        serializationObject.height = this._height;\r\n    };\r\n    /**\r\n     * Parses a serialized ground mesh\r\n     * @param parsedMesh the serialized mesh\r\n     * @param scene the scene to create the ground mesh in\r\n     * @returns the created ground mesh\r\n     */\r\n    GroundMesh.Parse = function (parsedMesh, scene) {\r\n        var result = new GroundMesh(parsedMesh.name, scene);\r\n        result._subdivisionsX = parsedMesh.subdivisionsX || 1;\r\n        result._subdivisionsY = parsedMesh.subdivisionsY || 1;\r\n        result._minX = parsedMesh.minX;\r\n        result._maxX = parsedMesh.maxX;\r\n        result._minZ = parsedMesh.minZ;\r\n        result._maxZ = parsedMesh.maxZ;\r\n        result._width = parsedMesh.width;\r\n        result._height = parsedMesh.height;\r\n        return result;\r\n    };\r\n    return GroundMesh;\r\n}(_Meshes_mesh__WEBPACK_IMPORTED_MODULE_3__[\"Mesh\"]));\r\n\r\n//# sourceMappingURL=groundMesh.js.map\n\n//# sourceURL=webpack:///./node_modules/@babylonjs/core/Meshes/groundMesh.js?");

/***/ }),

/***/ "./node_modules/@babylonjs/core/Meshes/instancedMesh.js":
/*!**************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Meshes/instancedMesh.js ***!
  \**************************************************************/
/*! exports provided: InstancedMesh */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"InstancedMesh\", function() { return InstancedMesh; });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\n/* harmony import */ var _Maths_math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Maths/math */ \"./node_modules/@babylonjs/core/Maths/math.js\");\n/* harmony import */ var _Misc_logger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Misc/logger */ \"./node_modules/@babylonjs/core/Misc/logger.js\");\n/* harmony import */ var _Meshes_abstractMesh__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Meshes/abstractMesh */ \"./node_modules/@babylonjs/core/Meshes/abstractMesh.js\");\n/* harmony import */ var _Meshes_mesh__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Meshes/mesh */ \"./node_modules/@babylonjs/core/Meshes/mesh.js\");\n/* harmony import */ var _Misc_deepCopier__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../Misc/deepCopier */ \"./node_modules/@babylonjs/core/Misc/deepCopier.js\");\n/* harmony import */ var _transformNode__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./transformNode */ \"./node_modules/@babylonjs/core/Meshes/transformNode.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n_Meshes_mesh__WEBPACK_IMPORTED_MODULE_4__[\"Mesh\"]._instancedMeshFactory = function (name, mesh) {\r\n    return new InstancedMesh(name, mesh);\r\n};\r\n/**\r\n * Creates an instance based on a source mesh.\r\n */\r\nvar InstancedMesh = /** @class */ (function (_super) {\r\n    tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"](InstancedMesh, _super);\r\n    function InstancedMesh(name, source) {\r\n        var _this = _super.call(this, name, source.getScene()) || this;\r\n        /** @hidden */\r\n        _this._indexInSourceMeshInstanceArray = -1;\r\n        source.addInstance(_this);\r\n        _this._sourceMesh = source;\r\n        _this.position.copyFrom(source.position);\r\n        _this.rotation.copyFrom(source.rotation);\r\n        _this.scaling.copyFrom(source.scaling);\r\n        if (source.rotationQuaternion) {\r\n            _this.rotationQuaternion = source.rotationQuaternion.clone();\r\n        }\r\n        _this.infiniteDistance = source.infiniteDistance;\r\n        _this.setPivotMatrix(source.getPivotMatrix());\r\n        _this.refreshBoundingInfo();\r\n        _this._syncSubMeshes();\r\n        return _this;\r\n    }\r\n    /**\r\n     * Returns the string \"InstancedMesh\".\r\n     */\r\n    InstancedMesh.prototype.getClassName = function () {\r\n        return \"InstancedMesh\";\r\n    };\r\n    Object.defineProperty(InstancedMesh.prototype, \"lightSources\", {\r\n        /** Gets the list of lights affecting that mesh */\r\n        get: function () {\r\n            return this._sourceMesh._lightSources;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    InstancedMesh.prototype._resyncLightSources = function () {\r\n        // Do nothing as all the work will be done by source mesh\r\n    };\r\n    InstancedMesh.prototype._resyncLighSource = function (light) {\r\n        // Do nothing as all the work will be done by source mesh\r\n    };\r\n    InstancedMesh.prototype._removeLightSource = function (light) {\r\n        // Do nothing as all the work will be done by source mesh\r\n    };\r\n    Object.defineProperty(InstancedMesh.prototype, \"receiveShadows\", {\r\n        // Methods\r\n        /**\r\n         * If the source mesh receives shadows\r\n         */\r\n        get: function () {\r\n            return this._sourceMesh.receiveShadows;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(InstancedMesh.prototype, \"material\", {\r\n        /**\r\n         * The material of the source mesh\r\n         */\r\n        get: function () {\r\n            return this._sourceMesh.material;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(InstancedMesh.prototype, \"visibility\", {\r\n        /**\r\n         * Visibility of the source mesh\r\n         */\r\n        get: function () {\r\n            return this._sourceMesh.visibility;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(InstancedMesh.prototype, \"skeleton\", {\r\n        /**\r\n         * Skeleton of the source mesh\r\n         */\r\n        get: function () {\r\n            return this._sourceMesh.skeleton;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(InstancedMesh.prototype, \"renderingGroupId\", {\r\n        /**\r\n         * Rendering ground id of the source mesh\r\n         */\r\n        get: function () {\r\n            return this._sourceMesh.renderingGroupId;\r\n        },\r\n        set: function (value) {\r\n            if (!this._sourceMesh || value === this._sourceMesh.renderingGroupId) {\r\n                return;\r\n            }\r\n            //no-op with warning\r\n            _Misc_logger__WEBPACK_IMPORTED_MODULE_2__[\"Logger\"].Warn(\"Note - setting renderingGroupId of an instanced mesh has no effect on the scene\");\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Returns the total number of vertices (integer).\r\n     */\r\n    InstancedMesh.prototype.getTotalVertices = function () {\r\n        return this._sourceMesh.getTotalVertices();\r\n    };\r\n    /**\r\n     * Returns a positive integer : the total number of indices in this mesh geometry.\r\n     * @returns the numner of indices or zero if the mesh has no geometry.\r\n     */\r\n    InstancedMesh.prototype.getTotalIndices = function () {\r\n        return this._sourceMesh.getTotalIndices();\r\n    };\r\n    Object.defineProperty(InstancedMesh.prototype, \"sourceMesh\", {\r\n        /**\r\n         * The source mesh of the instance\r\n         */\r\n        get: function () {\r\n            return this._sourceMesh;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Is this node ready to be used/rendered\r\n     * @param completeCheck defines if a complete check (including materials and lights) has to be done (false by default)\r\n     * @return {boolean} is it ready\r\n     */\r\n    InstancedMesh.prototype.isReady = function (completeCheck) {\r\n        if (completeCheck === void 0) { completeCheck = false; }\r\n        return this._sourceMesh.isReady(completeCheck, true);\r\n    };\r\n    /**\r\n     * Returns an array of integers or a typed array (Int32Array, Uint32Array, Uint16Array) populated with the mesh indices.\r\n     * @param kind kind of verticies to retreive (eg. positons, normals, uvs, etc.)\r\n     * @param copyWhenShared If true (default false) and and if the mesh geometry is shared among some other meshes, the returned array is a copy of the internal one.\r\n     * @returns a float array or a Float32Array of the requested kind of data : positons, normals, uvs, etc.\r\n     */\r\n    InstancedMesh.prototype.getVerticesData = function (kind, copyWhenShared) {\r\n        return this._sourceMesh.getVerticesData(kind, copyWhenShared);\r\n    };\r\n    /**\r\n     * Sets the vertex data of the mesh geometry for the requested `kind`.\r\n     * If the mesh has no geometry, a new Geometry object is set to the mesh and then passed this vertex data.\r\n     * The `data` are either a numeric array either a Float32Array.\r\n     * The parameter `updatable` is passed as is to the underlying Geometry object constructor (if initianilly none) or updater.\r\n     * The parameter `stride` is an optional positive integer, it is usually automatically deducted from the `kind` (3 for positions or normals, 2 for UV, etc).\r\n     * Note that a new underlying VertexBuffer object is created each call.\r\n     * If the `kind` is the `PositionKind`, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed.\r\n     *\r\n     * Possible `kind` values :\r\n     * - VertexBuffer.PositionKind\r\n     * - VertexBuffer.UVKind\r\n     * - VertexBuffer.UV2Kind\r\n     * - VertexBuffer.UV3Kind\r\n     * - VertexBuffer.UV4Kind\r\n     * - VertexBuffer.UV5Kind\r\n     * - VertexBuffer.UV6Kind\r\n     * - VertexBuffer.ColorKind\r\n     * - VertexBuffer.MatricesIndicesKind\r\n     * - VertexBuffer.MatricesIndicesExtraKind\r\n     * - VertexBuffer.MatricesWeightsKind\r\n     * - VertexBuffer.MatricesWeightsExtraKind\r\n     *\r\n     * Returns the Mesh.\r\n     */\r\n    InstancedMesh.prototype.setVerticesData = function (kind, data, updatable, stride) {\r\n        if (this.sourceMesh) {\r\n            this.sourceMesh.setVerticesData(kind, data, updatable, stride);\r\n        }\r\n        return this.sourceMesh;\r\n    };\r\n    /**\r\n     * Updates the existing vertex data of the mesh geometry for the requested `kind`.\r\n     * If the mesh has no geometry, it is simply returned as it is.\r\n     * The `data` are either a numeric array either a Float32Array.\r\n     * No new underlying VertexBuffer object is created.\r\n     * If the `kind` is the `PositionKind` and if `updateExtends` is true, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed.\r\n     * If the parameter `makeItUnique` is true, a new global geometry is created from this positions and is set to the mesh.\r\n     *\r\n     * Possible `kind` values :\r\n     * - VertexBuffer.PositionKind\r\n     * - VertexBuffer.UVKind\r\n     * - VertexBuffer.UV2Kind\r\n     * - VertexBuffer.UV3Kind\r\n     * - VertexBuffer.UV4Kind\r\n     * - VertexBuffer.UV5Kind\r\n     * - VertexBuffer.UV6Kind\r\n     * - VertexBuffer.ColorKind\r\n     * - VertexBuffer.MatricesIndicesKind\r\n     * - VertexBuffer.MatricesIndicesExtraKind\r\n     * - VertexBuffer.MatricesWeightsKind\r\n     * - VertexBuffer.MatricesWeightsExtraKind\r\n     *\r\n     * Returns the Mesh.\r\n     */\r\n    InstancedMesh.prototype.updateVerticesData = function (kind, data, updateExtends, makeItUnique) {\r\n        if (this.sourceMesh) {\r\n            this.sourceMesh.updateVerticesData(kind, data, updateExtends, makeItUnique);\r\n        }\r\n        return this.sourceMesh;\r\n    };\r\n    /**\r\n     * Sets the mesh indices.\r\n     * Expects an array populated with integers or a typed array (Int32Array, Uint32Array, Uint16Array).\r\n     * If the mesh has no geometry, a new Geometry object is created and set to the mesh.\r\n     * This method creates a new index buffer each call.\r\n     * Returns the Mesh.\r\n     */\r\n    InstancedMesh.prototype.setIndices = function (indices, totalVertices) {\r\n        if (totalVertices === void 0) { totalVertices = null; }\r\n        if (this.sourceMesh) {\r\n            this.sourceMesh.setIndices(indices, totalVertices);\r\n        }\r\n        return this.sourceMesh;\r\n    };\r\n    /**\r\n     * Boolean : True if the mesh owns the requested kind of data.\r\n     */\r\n    InstancedMesh.prototype.isVerticesDataPresent = function (kind) {\r\n        return this._sourceMesh.isVerticesDataPresent(kind);\r\n    };\r\n    /**\r\n     * Returns an array of indices (IndicesArray).\r\n     */\r\n    InstancedMesh.prototype.getIndices = function () {\r\n        return this._sourceMesh.getIndices();\r\n    };\r\n    Object.defineProperty(InstancedMesh.prototype, \"_positions\", {\r\n        get: function () {\r\n            return this._sourceMesh._positions;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * This method recomputes and sets a new BoundingInfo to the mesh unless it is locked.\r\n     * This means the mesh underlying bounding box and sphere are recomputed.\r\n     * @param applySkeleton defines whether to apply the skeleton before computing the bounding info\r\n     * @returns the current mesh\r\n     */\r\n    InstancedMesh.prototype.refreshBoundingInfo = function (applySkeleton) {\r\n        if (applySkeleton === void 0) { applySkeleton = false; }\r\n        if (this._boundingInfo && this._boundingInfo.isLocked) {\r\n            return this;\r\n        }\r\n        var bias = this._sourceMesh.geometry ? this._sourceMesh.geometry.boundingBias : null;\r\n        this._refreshBoundingInfo(this._sourceMesh._getPositionData(applySkeleton), bias);\r\n        return this;\r\n    };\r\n    /** @hidden */\r\n    InstancedMesh.prototype._preActivate = function () {\r\n        if (this._currentLOD) {\r\n            this._currentLOD._preActivate();\r\n        }\r\n        return this;\r\n    };\r\n    /** @hidden */\r\n    InstancedMesh.prototype._activate = function (renderId, intermediateRendering) {\r\n        if (this._currentLOD) {\r\n            this._currentLOD._registerInstanceForRenderId(this, renderId);\r\n        }\r\n        if (intermediateRendering) {\r\n            if (!this._currentLOD._internalAbstractMeshDataInfo._isActiveIntermediate) {\r\n                this._currentLOD._internalAbstractMeshDataInfo._onlyForInstancesIntermediate = true;\r\n                return true;\r\n            }\r\n        }\r\n        else {\r\n            if (!this._currentLOD._internalAbstractMeshDataInfo._isActive) {\r\n                this._currentLOD._internalAbstractMeshDataInfo._onlyForInstances = true;\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    };\r\n    /** @hidden */\r\n    InstancedMesh.prototype._postActivate = function () {\r\n        if (this._edgesRenderer && this._edgesRenderer.isEnabled && this._sourceMesh._renderingGroup) {\r\n            this._sourceMesh._renderingGroup._edgesRenderers.push(this._edgesRenderer);\r\n        }\r\n    };\r\n    InstancedMesh.prototype.getWorldMatrix = function () {\r\n        if (this._currentLOD && this._currentLOD.billboardMode !== _transformNode__WEBPACK_IMPORTED_MODULE_6__[\"TransformNode\"].BILLBOARDMODE_NONE && this._currentLOD._masterMesh !== this) {\r\n            var tempMaster = this._currentLOD._masterMesh;\r\n            this._currentLOD._masterMesh = this;\r\n            _Maths_math__WEBPACK_IMPORTED_MODULE_1__[\"Tmp\"].Matrix[0].copyFrom(this._currentLOD.computeWorldMatrix(true));\r\n            this._currentLOD._masterMesh = tempMaster;\r\n            return _Maths_math__WEBPACK_IMPORTED_MODULE_1__[\"Tmp\"].Matrix[0];\r\n        }\r\n        return _super.prototype.getWorldMatrix.call(this);\r\n    };\r\n    Object.defineProperty(InstancedMesh.prototype, \"isAnInstance\", {\r\n        get: function () {\r\n            return true;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Returns the current associated LOD AbstractMesh.\r\n     */\r\n    InstancedMesh.prototype.getLOD = function (camera) {\r\n        if (!camera) {\r\n            return this;\r\n        }\r\n        var boundingInfo = this.getBoundingInfo();\r\n        this._currentLOD = this.sourceMesh.getLOD(camera, boundingInfo.boundingSphere);\r\n        if (this._currentLOD === this.sourceMesh) {\r\n            return this.sourceMesh;\r\n        }\r\n        return this._currentLOD;\r\n    };\r\n    /** @hidden */\r\n    InstancedMesh.prototype._syncSubMeshes = function () {\r\n        this.releaseSubMeshes();\r\n        if (this._sourceMesh.subMeshes) {\r\n            for (var index = 0; index < this._sourceMesh.subMeshes.length; index++) {\r\n                this._sourceMesh.subMeshes[index].clone(this, this._sourceMesh);\r\n            }\r\n        }\r\n        return this;\r\n    };\r\n    /** @hidden */\r\n    InstancedMesh.prototype._generatePointsArray = function () {\r\n        return this._sourceMesh._generatePointsArray();\r\n    };\r\n    /**\r\n     * Creates a new InstancedMesh from the current mesh.\r\n     * - name (string) : the cloned mesh name\r\n     * - newParent (optional Node) : the optional Node to parent the clone to.\r\n     * - doNotCloneChildren (optional boolean, default `false`) : if `true` the model children aren't cloned.\r\n     *\r\n     * Returns the clone.\r\n     */\r\n    InstancedMesh.prototype.clone = function (name, newParent, doNotCloneChildren) {\r\n        var result = this._sourceMesh.createInstance(name);\r\n        // Deep copy\r\n        _Misc_deepCopier__WEBPACK_IMPORTED_MODULE_5__[\"DeepCopier\"].DeepCopy(this, result, [\"name\", \"subMeshes\", \"uniqueId\"], []);\r\n        // Bounding info\r\n        this.refreshBoundingInfo();\r\n        // Parent\r\n        if (newParent) {\r\n            result.parent = newParent;\r\n        }\r\n        if (!doNotCloneChildren) {\r\n            // Children\r\n            for (var index = 0; index < this.getScene().meshes.length; index++) {\r\n                var mesh = this.getScene().meshes[index];\r\n                if (mesh.parent === this) {\r\n                    mesh.clone(mesh.name, result);\r\n                }\r\n            }\r\n        }\r\n        result.computeWorldMatrix(true);\r\n        return result;\r\n    };\r\n    /**\r\n     * Disposes the InstancedMesh.\r\n     * Returns nothing.\r\n     */\r\n    InstancedMesh.prototype.dispose = function (doNotRecurse, disposeMaterialAndTextures) {\r\n        if (disposeMaterialAndTextures === void 0) { disposeMaterialAndTextures = false; }\r\n        // Remove from mesh\r\n        this._sourceMesh.removeInstance(this);\r\n        _super.prototype.dispose.call(this, doNotRecurse, disposeMaterialAndTextures);\r\n    };\r\n    return InstancedMesh;\r\n}(_Meshes_abstractMesh__WEBPACK_IMPORTED_MODULE_3__[\"AbstractMesh\"]));\r\n\r\n//# sourceMappingURL=instancedMesh.js.map\n\n//# sourceURL=webpack:///./node_modules/@babylonjs/core/Meshes/instancedMesh.js?");

/***/ }),

/***/ "./node_modules/@babylonjs/core/Meshes/linesMesh.js":
/*!**********************************************************!*\
  !*** ./node_modules/@babylonjs/core/Meshes/linesMesh.js ***!
  \**********************************************************/
/*! exports provided: LinesMesh, InstancedLinesMesh */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LinesMesh\", function() { return LinesMesh; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"InstancedLinesMesh\", function() { return InstancedLinesMesh; });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\n/* harmony import */ var _Maths_math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Maths/math */ \"./node_modules/@babylonjs/core/Maths/math.js\");\n/* harmony import */ var _Meshes_buffer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Meshes/buffer */ \"./node_modules/@babylonjs/core/Meshes/buffer.js\");\n/* harmony import */ var _Meshes_mesh__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Meshes/mesh */ \"./node_modules/@babylonjs/core/Meshes/mesh.js\");\n/* harmony import */ var _Meshes_instancedMesh__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Meshes/instancedMesh */ \"./node_modules/@babylonjs/core/Meshes/instancedMesh.js\");\n/* harmony import */ var _Materials_material__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../Materials/material */ \"./node_modules/@babylonjs/core/Materials/material.js\");\n/* harmony import */ var _Materials_shaderMaterial__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../Materials/shaderMaterial */ \"./node_modules/@babylonjs/core/Materials/shaderMaterial.js\");\n/* harmony import */ var _Shaders_color_fragment__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../Shaders/color.fragment */ \"./node_modules/@babylonjs/core/Shaders/color.fragment.js\");\n/* harmony import */ var _Shaders_color_vertex__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../Shaders/color.vertex */ \"./node_modules/@babylonjs/core/Shaders/color.vertex.js\");\n/* harmony import */ var _Materials_materialHelper__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../Materials/materialHelper */ \"./node_modules/@babylonjs/core/Materials/materialHelper.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * Line mesh\r\n * @see https://doc.babylonjs.com/babylon101/parametric_shapes\r\n */\r\nvar LinesMesh = /** @class */ (function (_super) {\r\n    tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"](LinesMesh, _super);\r\n    /**\r\n     * Creates a new LinesMesh\r\n     * @param name defines the name\r\n     * @param scene defines the hosting scene\r\n     * @param parent defines the parent mesh if any\r\n     * @param source defines the optional source LinesMesh used to clone data from\r\n     * @param doNotCloneChildren When cloning, skip cloning child meshes of source, default False.\r\n     * When false, achieved by calling a clone(), also passing False.\r\n     * This will make creation of children, recursive.\r\n     * @param useVertexColor defines if this LinesMesh supports vertex color\r\n     * @param useVertexAlpha defines if this LinesMesh supports vertex alpha\r\n     */\r\n    function LinesMesh(name, scene, parent, source, doNotCloneChildren, \r\n    /**\r\n     * If vertex color should be applied to the mesh\r\n     */\r\n    useVertexColor, \r\n    /**\r\n     * If vertex alpha should be applied to the mesh\r\n     */\r\n    useVertexAlpha) {\r\n        if (scene === void 0) { scene = null; }\r\n        if (parent === void 0) { parent = null; }\r\n        var _this = _super.call(this, name, scene, parent, source, doNotCloneChildren) || this;\r\n        _this.useVertexColor = useVertexColor;\r\n        _this.useVertexAlpha = useVertexAlpha;\r\n        /**\r\n         * Color of the line (Default: White)\r\n         */\r\n        _this.color = new _Maths_math__WEBPACK_IMPORTED_MODULE_1__[\"Color3\"](1, 1, 1);\r\n        /**\r\n         * Alpha of the line (Default: 1)\r\n         */\r\n        _this.alpha = 1;\r\n        if (source) {\r\n            _this.color = source.color.clone();\r\n            _this.alpha = source.alpha;\r\n            _this.useVertexColor = source.useVertexColor;\r\n            _this.useVertexAlpha = source.useVertexAlpha;\r\n        }\r\n        _this.intersectionThreshold = 0.1;\r\n        var defines = [];\r\n        var options = {\r\n            attributes: [_Meshes_buffer__WEBPACK_IMPORTED_MODULE_2__[\"VertexBuffer\"].PositionKind, \"world0\", \"world1\", \"world2\", \"world3\"],\r\n            uniforms: [\"vClipPlane\", \"vClipPlane2\", \"vClipPlane3\", \"vClipPlane4\", \"world\", \"viewProjection\"],\r\n            needAlphaBlending: true,\r\n            defines: defines\r\n        };\r\n        if (useVertexAlpha === false) {\r\n            options.needAlphaBlending = false;\r\n        }\r\n        if (!useVertexColor) {\r\n            options.uniforms.push(\"color\");\r\n        }\r\n        else {\r\n            options.defines.push(\"#define VERTEXCOLOR\");\r\n            options.attributes.push(_Meshes_buffer__WEBPACK_IMPORTED_MODULE_2__[\"VertexBuffer\"].ColorKind);\r\n        }\r\n        _this._colorShader = new _Materials_shaderMaterial__WEBPACK_IMPORTED_MODULE_6__[\"ShaderMaterial\"](\"colorShader\", _this.getScene(), \"color\", options);\r\n        return _this;\r\n    }\r\n    LinesMesh.prototype._addClipPlaneDefine = function (label) {\r\n        var define = \"#define \" + label;\r\n        var index = this._colorShader.options.defines.indexOf(define);\r\n        if (index !== -1) {\r\n            return;\r\n        }\r\n        this._colorShader.options.defines.push(define);\r\n    };\r\n    LinesMesh.prototype._removeClipPlaneDefine = function (label) {\r\n        var define = \"#define \" + label;\r\n        var index = this._colorShader.options.defines.indexOf(define);\r\n        if (index === -1) {\r\n            return;\r\n        }\r\n        this._colorShader.options.defines.splice(index, 1);\r\n    };\r\n    LinesMesh.prototype.isReady = function () {\r\n        var scene = this.getScene();\r\n        // Clip planes\r\n        scene.clipPlane ? this._addClipPlaneDefine(\"CLIPPLANE\") : this._removeClipPlaneDefine(\"CLIPPLANE\");\r\n        scene.clipPlane2 ? this._addClipPlaneDefine(\"CLIPPLANE2\") : this._removeClipPlaneDefine(\"CLIPPLANE2\");\r\n        scene.clipPlane3 ? this._addClipPlaneDefine(\"CLIPPLANE3\") : this._removeClipPlaneDefine(\"CLIPPLANE3\");\r\n        scene.clipPlane4 ? this._addClipPlaneDefine(\"CLIPPLANE4\") : this._removeClipPlaneDefine(\"CLIPPLANE4\");\r\n        if (!this._colorShader.isReady()) {\r\n            return false;\r\n        }\r\n        return _super.prototype.isReady.call(this);\r\n    };\r\n    /**\r\n     * Returns the string \"LineMesh\"\r\n     */\r\n    LinesMesh.prototype.getClassName = function () {\r\n        return \"LinesMesh\";\r\n    };\r\n    Object.defineProperty(LinesMesh.prototype, \"material\", {\r\n        /**\r\n         * @hidden\r\n         */\r\n        get: function () {\r\n            return this._colorShader;\r\n        },\r\n        /**\r\n         * @hidden\r\n         */\r\n        set: function (value) {\r\n            // Do nothing\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(LinesMesh.prototype, \"checkCollisions\", {\r\n        /**\r\n         * @hidden\r\n         */\r\n        get: function () {\r\n            return false;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /** @hidden */\r\n    LinesMesh.prototype._bind = function (subMesh, effect, fillMode) {\r\n        if (!this._geometry) {\r\n            return this;\r\n        }\r\n        var colorEffect = this._colorShader.getEffect();\r\n        // VBOs\r\n        var indexToBind = this.isUnIndexed ? null : this._geometry.getIndexBuffer();\r\n        this._geometry._bind(colorEffect, indexToBind);\r\n        // Color\r\n        if (!this.useVertexColor) {\r\n            this._colorShader.setColor4(\"color\", this.color.toColor4(this.alpha));\r\n        }\r\n        // Clip planes\r\n        _Materials_materialHelper__WEBPACK_IMPORTED_MODULE_9__[\"MaterialHelper\"].BindClipPlane(colorEffect, this.getScene());\r\n        return this;\r\n    };\r\n    /** @hidden */\r\n    LinesMesh.prototype._draw = function (subMesh, fillMode, instancesCount) {\r\n        if (!this._geometry || !this._geometry.getVertexBuffers() || (!this._unIndexed && !this._geometry.getIndexBuffer())) {\r\n            return this;\r\n        }\r\n        var engine = this.getScene().getEngine();\r\n        // Draw order\r\n        if (this._unIndexed) {\r\n            engine.drawArraysType(_Materials_material__WEBPACK_IMPORTED_MODULE_5__[\"Material\"].LineListDrawMode, subMesh.verticesStart, subMesh.verticesCount, instancesCount);\r\n        }\r\n        else {\r\n            engine.drawElementsType(_Materials_material__WEBPACK_IMPORTED_MODULE_5__[\"Material\"].LineListDrawMode, subMesh.indexStart, subMesh.indexCount, instancesCount);\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * Disposes of the line mesh\r\n     * @param doNotRecurse If children should be disposed\r\n     */\r\n    LinesMesh.prototype.dispose = function (doNotRecurse) {\r\n        this._colorShader.dispose(false, false, true);\r\n        _super.prototype.dispose.call(this, doNotRecurse);\r\n    };\r\n    /**\r\n     * Returns a new LineMesh object cloned from the current one.\r\n     */\r\n    LinesMesh.prototype.clone = function (name, newParent, doNotCloneChildren) {\r\n        return new LinesMesh(name, this.getScene(), newParent, this, doNotCloneChildren);\r\n    };\r\n    /**\r\n     * Creates a new InstancedLinesMesh object from the mesh model.\r\n     * @see http://doc.babylonjs.com/how_to/how_to_use_instances\r\n     * @param name defines the name of the new instance\r\n     * @returns a new InstancedLinesMesh\r\n     */\r\n    LinesMesh.prototype.createInstance = function (name) {\r\n        return new InstancedLinesMesh(name, this);\r\n    };\r\n    return LinesMesh;\r\n}(_Meshes_mesh__WEBPACK_IMPORTED_MODULE_3__[\"Mesh\"]));\r\n\r\n/**\r\n * Creates an instance based on a source LinesMesh\r\n */\r\nvar InstancedLinesMesh = /** @class */ (function (_super) {\r\n    tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"](InstancedLinesMesh, _super);\r\n    function InstancedLinesMesh(name, source) {\r\n        var _this = _super.call(this, name, source) || this;\r\n        _this.intersectionThreshold = source.intersectionThreshold;\r\n        return _this;\r\n    }\r\n    /**\r\n     * Returns the string \"InstancedLinesMesh\".\r\n     */\r\n    InstancedLinesMesh.prototype.getClassName = function () {\r\n        return \"InstancedLinesMesh\";\r\n    };\r\n    return InstancedLinesMesh;\r\n}(_Meshes_instancedMesh__WEBPACK_IMPORTED_MODULE_4__[\"InstancedMesh\"]));\r\n\r\n//# sourceMappingURL=linesMesh.js.map\n\n//# sourceURL=webpack:///./node_modules/@babylonjs/core/Meshes/linesMesh.js?");

/***/ }),

/***/ "./node_modules/@babylonjs/core/Meshes/meshBuilder.js":
/*!************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Meshes/meshBuilder.js ***!
  \************************************************************/
/*! exports provided: MeshBuilder */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MeshBuilder\", function() { return MeshBuilder; });\n/* harmony import */ var _Builders_ribbonBuilder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Builders/ribbonBuilder */ \"./node_modules/@babylonjs/core/Meshes/Builders/ribbonBuilder.js\");\n/* harmony import */ var _Builders_discBuilder__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Builders/discBuilder */ \"./node_modules/@babylonjs/core/Meshes/Builders/discBuilder.js\");\n/* harmony import */ var _Builders_boxBuilder__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Builders/boxBuilder */ \"./node_modules/@babylonjs/core/Meshes/Builders/boxBuilder.js\");\n/* harmony import */ var _Builders_sphereBuilder__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Builders/sphereBuilder */ \"./node_modules/@babylonjs/core/Meshes/Builders/sphereBuilder.js\");\n/* harmony import */ var _Builders_cylinderBuilder__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Builders/cylinderBuilder */ \"./node_modules/@babylonjs/core/Meshes/Builders/cylinderBuilder.js\");\n/* harmony import */ var _Builders_torusBuilder__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Builders/torusBuilder */ \"./node_modules/@babylonjs/core/Meshes/Builders/torusBuilder.js\");\n/* harmony import */ var _Builders_torusKnotBuilder__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Builders/torusKnotBuilder */ \"./node_modules/@babylonjs/core/Meshes/Builders/torusKnotBuilder.js\");\n/* harmony import */ var _Builders_linesBuilder__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Builders/linesBuilder */ \"./node_modules/@babylonjs/core/Meshes/Builders/linesBuilder.js\");\n/* harmony import */ var _Builders_polygonBuilder__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Builders/polygonBuilder */ \"./node_modules/@babylonjs/core/Meshes/Builders/polygonBuilder.js\");\n/* harmony import */ var _Builders_shapeBuilder__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Builders/shapeBuilder */ \"./node_modules/@babylonjs/core/Meshes/Builders/shapeBuilder.js\");\n/* harmony import */ var _Builders_latheBuilder__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./Builders/latheBuilder */ \"./node_modules/@babylonjs/core/Meshes/Builders/latheBuilder.js\");\n/* harmony import */ var _Builders_planeBuilder__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./Builders/planeBuilder */ \"./node_modules/@babylonjs/core/Meshes/Builders/planeBuilder.js\");\n/* harmony import */ var _Builders_groundBuilder__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./Builders/groundBuilder */ \"./node_modules/@babylonjs/core/Meshes/Builders/groundBuilder.js\");\n/* harmony import */ var _Builders_tubeBuilder__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./Builders/tubeBuilder */ \"./node_modules/@babylonjs/core/Meshes/Builders/tubeBuilder.js\");\n/* harmony import */ var _Builders_polyhedronBuilder__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./Builders/polyhedronBuilder */ \"./node_modules/@babylonjs/core/Meshes/Builders/polyhedronBuilder.js\");\n/* harmony import */ var _Builders_icoSphereBuilder__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./Builders/icoSphereBuilder */ \"./node_modules/@babylonjs/core/Meshes/Builders/icoSphereBuilder.js\");\n/* harmony import */ var _Builders_decalBuilder__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./Builders/decalBuilder */ \"./node_modules/@babylonjs/core/Meshes/Builders/decalBuilder.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n */\r\nvar MeshBuilder = /** @class */ (function () {\r\n    function MeshBuilder() {\r\n    }\r\n    /**\r\n     * Creates a box mesh\r\n     * * The parameter `size` sets the size (float) of each box side (default 1)\r\n     * * You can set some different box dimensions by using the parameters `width`, `height` and `depth` (all by default have the same value of `size`)\r\n     * * You can set different colors and different images to each box side by using the parameters `faceColors` (an array of 6 Color3 elements) and `faceUV` (an array of 6 Vector4 elements)\r\n     * * Please read this tutorial : https://doc.babylonjs.com/how_to/createbox_per_face_textures_and_colors\r\n     * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n     * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\r\n     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n     * @see https://doc.babylonjs.com/how_to/set_shapes#box\r\n     * @param name defines the name of the mesh\r\n     * @param options defines the options used to create the mesh\r\n     * @param scene defines the hosting scene\r\n     * @returns the box mesh\r\n     */\r\n    MeshBuilder.CreateBox = function (name, options, scene) {\r\n        if (scene === void 0) { scene = null; }\r\n        return _Builders_boxBuilder__WEBPACK_IMPORTED_MODULE_2__[\"BoxBuilder\"].CreateBox(name, options, scene);\r\n    };\r\n    /**\r\n     * Creates a sphere mesh\r\n     * * The parameter `diameter` sets the diameter size (float) of the sphere (default 1)\r\n     * * You can set some different sphere dimensions, for instance to build an ellipsoid, by using the parameters `diameterX`, `diameterY` and `diameterZ` (all by default have the same value of `diameter`)\r\n     * * The parameter `segments` sets the sphere number of horizontal stripes (positive integer, default 32)\r\n     * * You can create an unclosed sphere with the parameter `arc` (positive float, default 1), valued between 0 and 1, what is the ratio of the circumference (latitude) : 2 x PI x ratio\r\n     * * You can create an unclosed sphere on its height with the parameter `slice` (positive float, default1), valued between 0 and 1, what is the height ratio (longitude)\r\n     * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n     * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\r\n     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n     * @param name defines the name of the mesh\r\n     * @param options defines the options used to create the mesh\r\n     * @param scene defines the hosting scene\r\n     * @returns the sphere mesh\r\n     * @see https://doc.babylonjs.com/how_to/set_shapes#sphere\r\n     */\r\n    MeshBuilder.CreateSphere = function (name, options, scene) {\r\n        if (scene === void 0) { scene = null; }\r\n        return _Builders_sphereBuilder__WEBPACK_IMPORTED_MODULE_3__[\"SphereBuilder\"].CreateSphere(name, options, scene);\r\n    };\r\n    /**\r\n     * Creates a plane polygonal mesh.  By default, this is a disc\r\n     * * The parameter `radius` sets the radius size (float) of the polygon (default 0.5)\r\n     * * The parameter `tessellation` sets the number of polygon sides (positive integer, default 64). So a tessellation valued to 3 will build a triangle, to 4 a square, etc\r\n     * * You can create an unclosed polygon with the parameter `arc` (positive float, default 1), valued between 0 and 1, what is the ratio of the circumference : 2 x PI x ratio\r\n     * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n     * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\r\n     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n     * @param name defines the name of the mesh\r\n     * @param options defines the options used to create the mesh\r\n     * @param scene defines the hosting scene\r\n     * @returns the plane polygonal mesh\r\n     * @see https://doc.babylonjs.com/how_to/set_shapes#disc-or-regular-polygon\r\n     */\r\n    MeshBuilder.CreateDisc = function (name, options, scene) {\r\n        if (scene === void 0) { scene = null; }\r\n        return _Builders_discBuilder__WEBPACK_IMPORTED_MODULE_1__[\"DiscBuilder\"].CreateDisc(name, options, scene);\r\n    };\r\n    /**\r\n     * Creates a sphere based upon an icosahedron with 20 triangular faces which can be subdivided\r\n     * * The parameter `radius` sets the radius size (float) of the icosphere (default 1)\r\n     * * You can set some different icosphere dimensions, for instance to build an ellipsoid, by using the parameters `radiusX`, `radiusY` and `radiusZ` (all by default have the same value of `radius`)\r\n     * * The parameter `subdivisions` sets the number of subdivisions (postive integer, default 4). The more subdivisions, the more faces on the icosphere whatever its size\r\n     * * The parameter `flat` (boolean, default true) gives each side its own normals. Set it to false to get a smooth continuous light reflection on the surface\r\n     * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n     * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\r\n     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n     * @param name defines the name of the mesh\r\n     * @param options defines the options used to create the mesh\r\n     * @param scene defines the hosting scene\r\n     * @returns the icosahedron mesh\r\n     * @see https://doc.babylonjs.com/how_to/polyhedra_shapes#icosphere\r\n     */\r\n    MeshBuilder.CreateIcoSphere = function (name, options, scene) {\r\n        if (scene === void 0) { scene = null; }\r\n        return _Builders_icoSphereBuilder__WEBPACK_IMPORTED_MODULE_15__[\"IcoSphereBuilder\"].CreateIcoSphere(name, options, scene);\r\n    };\r\n    /**\r\n     * Creates a ribbon mesh. The ribbon is a parametric shape.  It has no predefined shape. Its final shape will depend on the input parameters\r\n     * * The parameter `pathArray` is a required array of paths, what are each an array of successive Vector3. The pathArray parameter depicts the ribbon geometry\r\n     * * The parameter `closeArray` (boolean, default false) creates a seam between the first and the last paths of the path array\r\n     * * The parameter `closePath` (boolean, default false) creates a seam between the first and the last points of each path of the path array\r\n     * * The parameter `offset` (positive integer, default : rounded half size of the pathArray length), is taken in account only if the `pathArray` is containing a single path\r\n     * * It's the offset to join the points from the same path. Ex : offset = 10 means the point 1 is joined to the point 11\r\n     * * The optional parameter `instance` is an instance of an existing Ribbon object to be updated with the passed `pathArray` parameter : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#ribbon\r\n     * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n     * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\r\n     * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture\r\n     * * The parameter `uvs` is an optional flat array of `Vector2` to update/set each ribbon vertex with its own custom UV values instead of the computed ones\r\n     * * The parameters `colors` is an optional flat array of `Color4` to set/update each ribbon vertex with its own custom color values\r\n     * * Note that if you use the parameters `uvs` or `colors`, the passed arrays must be populated with the right number of elements, it is to say the number of ribbon vertices. Remember that if you set `closePath` to `true`, there's one extra vertex per path in the geometry\r\n     * * Moreover, you can use the parameter `color` with `instance` (to update the ribbon), only if you previously used it at creation time\r\n     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n     * @param name defines the name of the mesh\r\n     * @param options defines the options used to create the mesh\r\n     * @param scene defines the hosting scene\r\n     * @returns the ribbon mesh\r\n     * @see https://doc.babylonjs.com/how_to/ribbon_tutorial\r\n     * @see https://doc.babylonjs.com/how_to/parametric_shapes\r\n     */\r\n    MeshBuilder.CreateRibbon = function (name, options, scene) {\r\n        if (scene === void 0) { scene = null; }\r\n        return _Builders_ribbonBuilder__WEBPACK_IMPORTED_MODULE_0__[\"RibbonBuilder\"].CreateRibbon(name, options, scene);\r\n    };\r\n    /**\r\n     * Creates a cylinder or a cone mesh\r\n     * * The parameter `height` sets the height size (float) of the cylinder/cone (float, default 2).\r\n     * * The parameter `diameter` sets the diameter of the top and bottom cap at once (float, default 1).\r\n     * * The parameters `diameterTop` and `diameterBottom` overwrite the parameter `diameter` and set respectively the top cap and bottom cap diameter (floats, default 1). The parameter \"diameterBottom\" can't be zero.\r\n     * * The parameter `tessellation` sets the number of cylinder sides (positive integer, default 24). Set it to 3 to get a prism for instance.\r\n     * * The parameter `subdivisions` sets the number of rings along the cylinder height (positive integer, default 1).\r\n     * * The parameter `hasRings` (boolean, default false) makes the subdivisions independent from each other, so they become different faces.\r\n     * * The parameter `enclose`  (boolean, default false) adds two extra faces per subdivision to a sliced cylinder to close it around its height axis.\r\n     * * The parameter `arc` (float, default 1) is the ratio (max 1) to apply to the circumference to slice the cylinder.\r\n     * * You can set different colors and different images to each box side by using the parameters `faceColors` (an array of n Color3 elements) and `faceUV` (an array of n Vector4 elements).\r\n     * * The value of n is the number of cylinder faces. If the cylinder has only 1 subdivisions, n equals : top face + cylinder surface + bottom face = 3\r\n     * * Now, if the cylinder has 5 independent subdivisions (hasRings = true), n equals : top face + 5 stripe surfaces + bottom face = 2 + 5 = 7\r\n     * * Finally, if the cylinder has 5 independent subdivisions and is enclose, n equals : top face + 5 x (stripe surface + 2 closing faces) + bottom face = 2 + 5 * 3 = 17\r\n     * * Each array (color or UVs) is always ordered the same way : the first element is the bottom cap, the last element is the top cap. The other elements are each a ring surface.\r\n     * * If `enclose` is false, a ring surface is one element.\r\n     * * If `enclose` is true, a ring surface is 3 successive elements in the array : the tubular surface, then the two closing faces.\r\n     * * Example how to set colors and textures on a sliced cylinder : https://www.html5gamedevs.com/topic/17945-creating-a-closed-slice-of-a-cylinder/#comment-106379\r\n     * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n     * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\r\n     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\r\n     * @param name defines the name of the mesh\r\n     * @param options defines the options used to create the mesh\r\n     * @param scene defines the hosting scene\r\n     * @returns the cylinder mesh\r\n     * @see https://doc.babylonjs.com/how_to/set_shapes#cylinder-or-cone\r\n     */\r\n    MeshBuilder.CreateCylinder = function (name, options, scene) {\r\n        if (scene === void 0) { scene = null; }\r\n        return _Builders_cylinderBuilder__WEBPACK_IMPORTED_MODULE_4__[\"CylinderBuilder\"].CreateCylinder(name, options, scene);\r\n    };\r\n    /**\r\n     * Creates a torus mesh\r\n     * * The parameter `diameter` sets the diameter size (float) of the torus (default 1)\r\n     * * The parameter `thickness` sets the diameter size of the tube of the torus (float, default 0.5)\r\n     * * The parameter `tessellation` sets the number of torus sides (postive integer, default 16)\r\n     * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n     * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\r\n     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\r\n     * @param name defines the name of the mesh\r\n     * @param options defines the options used to create the mesh\r\n     * @param scene defines the hosting scene\r\n     * @returns the torus mesh\r\n     * @see https://doc.babylonjs.com/how_to/set_shapes#torus\r\n     */\r\n    MeshBuilder.CreateTorus = function (name, options, scene) {\r\n        if (scene === void 0) { scene = null; }\r\n        return _Builders_torusBuilder__WEBPACK_IMPORTED_MODULE_5__[\"TorusBuilder\"].CreateTorus(name, options, scene);\r\n    };\r\n    /**\r\n     * Creates a torus knot mesh\r\n     * * The parameter `radius` sets the global radius size (float) of the torus knot (default 2)\r\n     * * The parameter `radialSegments` sets the number of sides on each tube segments (positive integer, default 32)\r\n     * * The parameter `tubularSegments` sets the number of tubes to decompose the knot into (positive integer, default 32)\r\n     * * The parameters `p` and `q` are the number of windings on each axis (positive integers, default 2 and 3)\r\n     * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n     * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\r\n     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\r\n     * @param name defines the name of the mesh\r\n     * @param options defines the options used to create the mesh\r\n     * @param scene defines the hosting scene\r\n     * @returns the torus knot mesh\r\n     * @see  https://doc.babylonjs.com/how_to/set_shapes#torus-knot\r\n     */\r\n    MeshBuilder.CreateTorusKnot = function (name, options, scene) {\r\n        if (scene === void 0) { scene = null; }\r\n        return _Builders_torusKnotBuilder__WEBPACK_IMPORTED_MODULE_6__[\"TorusKnotBuilder\"].CreateTorusKnot(name, options, scene);\r\n    };\r\n    /**\r\n     * Creates a line system mesh. A line system is a pool of many lines gathered in a single mesh\r\n     * * A line system mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of lines as an input parameter\r\n     * * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineSystem to this static function\r\n     * * The parameter `lines` is an array of lines, each line being an array of successive Vector3\r\n     * * The optional parameter `instance` is an instance of an existing LineSystem object to be updated with the passed `lines` parameter\r\n     * * The optional parameter `colors` is an array of line colors, each line colors being an array of successive Color4, one per line point\r\n     * * The optional parameter `useVertexAlpha` is to be set to `false` (default `true`) when you don't need the alpha blending (faster)\r\n     * * Updating a simple Line mesh, you just need to update every line in the `lines` array : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#lines-and-dashedlines\r\n     * * When updating an instance, remember that only line point positions can change, not the number of points, neither the number of lines\r\n     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n     * @see https://doc.babylonjs.com/how_to/parametric_shapes#line-system\r\n     * @param name defines the name of the new line system\r\n     * @param options defines the options used to create the line system\r\n     * @param scene defines the hosting scene\r\n     * @returns a new line system mesh\r\n     */\r\n    MeshBuilder.CreateLineSystem = function (name, options, scene) {\r\n        return _Builders_linesBuilder__WEBPACK_IMPORTED_MODULE_7__[\"LinesBuilder\"].CreateLineSystem(name, options, scene);\r\n    };\r\n    /**\r\n     * Creates a line mesh\r\n     * A line mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of points as an input parameter\r\n     * * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineMesh to this static function\r\n     * * The parameter `points` is an array successive Vector3\r\n     * * The optional parameter `instance` is an instance of an existing LineMesh object to be updated with the passed `points` parameter : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#lines-and-dashedlines\r\n     * * The optional parameter `colors` is an array of successive Color4, one per line point\r\n     * * The optional parameter `useVertexAlpha` is to be set to `false` (default `true`) when you don't need alpha blending (faster)\r\n     * * When updating an instance, remember that only point positions can change, not the number of points\r\n     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n     * @see https://doc.babylonjs.com/how_to/parametric_shapes#lines\r\n     * @param name defines the name of the new line system\r\n     * @param options defines the options used to create the line system\r\n     * @param scene defines the hosting scene\r\n     * @returns a new line mesh\r\n     */\r\n    MeshBuilder.CreateLines = function (name, options, scene) {\r\n        if (scene === void 0) { scene = null; }\r\n        return _Builders_linesBuilder__WEBPACK_IMPORTED_MODULE_7__[\"LinesBuilder\"].CreateLines(name, options, scene);\r\n    };\r\n    /**\r\n     * Creates a dashed line mesh\r\n     * * A dashed line mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of points as an input parameter\r\n     * * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineMesh to this static function\r\n     * * The parameter `points` is an array successive Vector3\r\n     * * The parameter `dashNb` is the intended total number of dashes (positive integer, default 200)\r\n     * * The parameter `dashSize` is the size of the dashes relatively the dash number (positive float, default 3)\r\n     * * The parameter `gapSize` is the size of the gap between two successive dashes relatively the dash number (positive float, default 1)\r\n     * * The optional parameter `instance` is an instance of an existing LineMesh object to be updated with the passed `points` parameter : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#lines-and-dashedlines\r\n     * * When updating an instance, remember that only point positions can change, not the number of points\r\n     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n     * @param name defines the name of the mesh\r\n     * @param options defines the options used to create the mesh\r\n     * @param scene defines the hosting scene\r\n     * @returns the dashed line mesh\r\n     * @see https://doc.babylonjs.com/how_to/parametric_shapes#dashed-lines\r\n     */\r\n    MeshBuilder.CreateDashedLines = function (name, options, scene) {\r\n        if (scene === void 0) { scene = null; }\r\n        return _Builders_linesBuilder__WEBPACK_IMPORTED_MODULE_7__[\"LinesBuilder\"].CreateDashedLines(name, options, scene);\r\n    };\r\n    /**\r\n     * Creates an extruded shape mesh. The extrusion is a parametric shape. It has no predefined shape. Its final shape will depend on the input parameters.\r\n     * * The parameter `shape` is a required array of successive Vector3. This array depicts the shape to be extruded in its local space : the shape must be designed in the xOy plane and will be extruded along the Z axis.\r\n     * * The parameter `path` is a required array of successive Vector3. This is the axis curve the shape is extruded along.\r\n     * * The parameter `rotation` (float, default 0 radians) is the angle value to rotate the shape each step (each path point), from the former step (so rotation added each step) along the curve.\r\n     * * The parameter `scale` (float, default 1) is the value to scale the shape.\r\n     * * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL\r\n     * * The optional parameter `instance` is an instance of an existing ExtrudedShape object to be updated with the passed `shape`, `path`, `scale` or `rotation` parameters : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#extruded-shape\r\n     * * Remember you can only change the shape or path point positions, not their number when updating an extruded shape.\r\n     * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n     * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\r\n     * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture.\r\n     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\r\n     * @param name defines the name of the mesh\r\n     * @param options defines the options used to create the mesh\r\n     * @param scene defines the hosting scene\r\n     * @returns the extruded shape mesh\r\n     * @see https://doc.babylonjs.com/how_to/parametric_shapes\r\n     * @see https://doc.babylonjs.com/how_to/parametric_shapes#extruded-shapes\r\n     */\r\n    MeshBuilder.ExtrudeShape = function (name, options, scene) {\r\n        if (scene === void 0) { scene = null; }\r\n        return _Builders_shapeBuilder__WEBPACK_IMPORTED_MODULE_9__[\"ShapeBuilder\"].ExtrudeShape(name, options, scene);\r\n    };\r\n    /**\r\n     * Creates an custom extruded shape mesh.\r\n     * The custom extrusion is a parametric shape. It has no predefined shape. Its final shape will depend on the input parameters.\r\n     * * The parameter `shape` is a required array of successive Vector3. This array depicts the shape to be extruded in its local space : the shape must be designed in the xOy plane and will be extruded along the Z axis.\r\n     * * The parameter `path` is a required array of successive Vector3. This is the axis curve the shape is extruded along.\r\n     * * The parameter `rotationFunction` (JS function) is a custom Javascript function called on each path point. This function is passed the position i of the point in the path and the distance of this point from the begining of the path\r\n     * * It must returns a float value that will be the rotation in radians applied to the shape on each path point.\r\n     * * The parameter `scaleFunction` (JS function) is a custom Javascript function called on each path point. This function is passed the position i of the point in the path and the distance of this point from the begining of the path\r\n     * * It must returns a float value that will be the scale value applied to the shape on each path point\r\n     * * The parameter `ribbonClosePath` (boolean, default false) forces the extrusion underlying ribbon to close all the paths in its `pathArray`\r\n     * * The parameter `ribbonCloseArray` (boolean, default false) forces the extrusion underlying ribbon to close its `pathArray`\r\n     * * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL\r\n     * * The optional parameter `instance` is an instance of an existing ExtrudedShape object to be updated with the passed `shape`, `path`, `scale` or `rotation` parameters : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#extruded-shape\r\n     * * Remember you can only change the shape or path point positions, not their number when updating an extruded shape\r\n     * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n     * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\r\n     * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture\r\n     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n     * @param name defines the name of the mesh\r\n     * @param options defines the options used to create the mesh\r\n     * @param scene defines the hosting scene\r\n     * @returns the custom extruded shape mesh\r\n     * @see https://doc.babylonjs.com/how_to/parametric_shapes#custom-extruded-shapes\r\n     * @see https://doc.babylonjs.com/how_to/parametric_shapes\r\n     * @see https://doc.babylonjs.com/how_to/parametric_shapes#extruded-shapes\r\n     */\r\n    MeshBuilder.ExtrudeShapeCustom = function (name, options, scene) {\r\n        if (scene === void 0) { scene = null; }\r\n        return _Builders_shapeBuilder__WEBPACK_IMPORTED_MODULE_9__[\"ShapeBuilder\"].ExtrudeShapeCustom(name, options, scene);\r\n    };\r\n    /**\r\n     * Creates lathe mesh.\r\n     * The lathe is a shape with a symetry axis : a 2D model shape is rotated around this axis to design the lathe\r\n     * * The parameter `shape` is a required array of successive Vector3. This array depicts the shape to be rotated in its local space : the shape must be designed in the xOy plane and will be rotated around the Y axis. It's usually a 2D shape, so the Vector3 z coordinates are often set to zero\r\n     * * The parameter `radius` (positive float, default 1) is the radius value of the lathe\r\n     * * The parameter `tessellation` (positive integer, default 64) is the side number of the lathe\r\n     * * The parameter `clip` (positive integer, default 0) is the number of sides to not create without effecting the general shape of the sides\r\n     * * The parameter `arc` (positive float, default 1) is the ratio of the lathe. 0.5 builds for instance half a lathe, so an opened shape\r\n     * * The parameter `closed` (boolean, default true) opens/closes the lathe circumference. This should be set to false when used with the parameter \"arc\"\r\n     * * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL\r\n     * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n     * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\r\n     * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture\r\n     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n     * @param name defines the name of the mesh\r\n     * @param options defines the options used to create the mesh\r\n     * @param scene defines the hosting scene\r\n     * @returns the lathe mesh\r\n     * @see https://doc.babylonjs.com/how_to/parametric_shapes#lathe\r\n     */\r\n    MeshBuilder.CreateLathe = function (name, options, scene) {\r\n        if (scene === void 0) { scene = null; }\r\n        return _Builders_latheBuilder__WEBPACK_IMPORTED_MODULE_10__[\"LatheBuilder\"].CreateLathe(name, options, scene);\r\n    };\r\n    /**\r\n     * Creates a plane mesh\r\n     * * The parameter `size` sets the size (float) of both sides of the plane at once (default 1)\r\n     * * You can set some different plane dimensions by using the parameters `width` and `height` (both by default have the same value of `size`)\r\n     * * The parameter `sourcePlane` is a Plane instance. It builds a mesh plane from a Math plane\r\n     * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n     * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\r\n     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n     * @param name defines the name of the mesh\r\n     * @param options defines the options used to create the mesh\r\n     * @param scene defines the hosting scene\r\n     * @returns the plane mesh\r\n     * @see https://doc.babylonjs.com/how_to/set_shapes#plane\r\n     */\r\n    MeshBuilder.CreatePlane = function (name, options, scene) {\r\n        if (scene === void 0) { scene = null; }\r\n        return _Builders_planeBuilder__WEBPACK_IMPORTED_MODULE_11__[\"PlaneBuilder\"].CreatePlane(name, options, scene);\r\n    };\r\n    /**\r\n     * Creates a ground mesh\r\n     * * The parameters `width` and `height` (floats, default 1) set the width and height sizes of the ground\r\n     * * The parameter `subdivisions` (positive integer) sets the number of subdivisions per side\r\n     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n     * @param name defines the name of the mesh\r\n     * @param options defines the options used to create the mesh\r\n     * @param scene defines the hosting scene\r\n     * @returns the ground mesh\r\n     * @see https://doc.babylonjs.com/how_to/set_shapes#ground\r\n     */\r\n    MeshBuilder.CreateGround = function (name, options, scene) {\r\n        if (scene === void 0) { scene = null; }\r\n        return _Builders_groundBuilder__WEBPACK_IMPORTED_MODULE_12__[\"GroundBuilder\"].CreateGround(name, options, scene);\r\n    };\r\n    /**\r\n     * Creates a tiled ground mesh\r\n     * * The parameters `xmin` and `xmax` (floats, default -1 and 1) set the ground minimum and maximum X coordinates\r\n     * * The parameters `zmin` and `zmax` (floats, default -1 and 1) set the ground minimum and maximum Z coordinates\r\n     * * The parameter `subdivisions` is a javascript object `{w: positive integer, h: positive integer}` (default `{w: 6, h: 6}`). `w` and `h` are the numbers of subdivisions on the ground width and height. Each subdivision is called a tile\r\n     * * The parameter `precision` is a javascript object `{w: positive integer, h: positive integer}` (default `{w: 2, h: 2}`). `w` and `h` are the numbers of subdivisions on the ground width and height of each tile\r\n     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\r\n     * @param name defines the name of the mesh\r\n     * @param options defines the options used to create the mesh\r\n     * @param scene defines the hosting scene\r\n     * @returns the tiled ground mesh\r\n     * @see https://doc.babylonjs.com/how_to/set_shapes#tiled-ground\r\n     */\r\n    MeshBuilder.CreateTiledGround = function (name, options, scene) {\r\n        if (scene === void 0) { scene = null; }\r\n        return _Builders_groundBuilder__WEBPACK_IMPORTED_MODULE_12__[\"GroundBuilder\"].CreateTiledGround(name, options, scene);\r\n    };\r\n    /**\r\n     * Creates a ground mesh from a height map\r\n     * * The parameter `url` sets the URL of the height map image resource.\r\n     * * The parameters `width` and `height` (positive floats, default 10) set the ground width and height sizes.\r\n     * * The parameter `subdivisions` (positive integer, default 1) sets the number of subdivision per side.\r\n     * * The parameter `minHeight` (float, default 0) is the minimum altitude on the ground.\r\n     * * The parameter `maxHeight` (float, default 1) is the maximum altitude on the ground.\r\n     * * The parameter `colorFilter` (optional Color3, default (0.3, 0.59, 0.11) ) is the filter to apply to the image pixel colors to compute the height.\r\n     * * The parameter `onReady` is a javascript callback function that will be called  once the mesh is just built (the height map download can last some time).\r\n     * * The parameter `alphaFilter` will filter any data where the alpha channel is below this value, defaults 0 (all data visible)\r\n     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.\r\n     * @param name defines the name of the mesh\r\n     * @param url defines the url to the height map\r\n     * @param options defines the options used to create the mesh\r\n     * @param scene defines the hosting scene\r\n     * @returns the ground mesh\r\n     * @see https://doc.babylonjs.com/babylon101/height_map\r\n     * @see https://doc.babylonjs.com/how_to/set_shapes#ground-from-a-height-map\r\n     */\r\n    MeshBuilder.CreateGroundFromHeightMap = function (name, url, options, scene) {\r\n        if (scene === void 0) { scene = null; }\r\n        return _Builders_groundBuilder__WEBPACK_IMPORTED_MODULE_12__[\"GroundBuilder\"].CreateGroundFromHeightMap(name, url, options, scene);\r\n    };\r\n    /**\r\n     * Creates a polygon mesh\r\n     * The polygon's shape will depend on the input parameters and is constructed parallel to a ground mesh\r\n     * * The parameter `shape` is a required array of successive Vector3 representing the corners of the polygon in th XoZ plane, that is y = 0 for all vectors\r\n     * * You can set the mesh side orientation with the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n     * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4)\r\n     * * Remember you can only change the shape positions, not their number when updating a polygon\r\n     * @param name defines the name of the mesh\r\n     * @param options defines the options used to create the mesh\r\n     * @param scene defines the hosting scene\r\n     * @param earcutInjection can be used to inject your own earcut reference\r\n     * @returns the polygon mesh\r\n     */\r\n    MeshBuilder.CreatePolygon = function (name, options, scene, earcutInjection) {\r\n        if (scene === void 0) { scene = null; }\r\n        if (earcutInjection === void 0) { earcutInjection = earcut; }\r\n        return _Builders_polygonBuilder__WEBPACK_IMPORTED_MODULE_8__[\"PolygonBuilder\"].CreatePolygon(name, options, scene, earcutInjection);\r\n    };\r\n    /**\r\n     * Creates an extruded polygon mesh, with depth in the Y direction.\r\n     * * You can set different colors and different images to the top, bottom and extruded side by using the parameters `faceColors` (an array of 3 Color3 elements) and `faceUV` (an array of 3 Vector4 elements)\r\n     * @see https://doc.babylonjs.com/how_to/createbox_per_face_textures_and_colors\r\n     * @param name defines the name of the mesh\r\n     * @param options defines the options used to create the mesh\r\n     * @param scene defines the hosting scene\r\n     * @param earcutInjection can be used to inject your own earcut reference\r\n     * @returns the polygon mesh\r\n     */\r\n    MeshBuilder.ExtrudePolygon = function (name, options, scene, earcutInjection) {\r\n        if (scene === void 0) { scene = null; }\r\n        if (earcutInjection === void 0) { earcutInjection = earcut; }\r\n        return _Builders_polygonBuilder__WEBPACK_IMPORTED_MODULE_8__[\"PolygonBuilder\"].ExtrudePolygon(name, options, scene, earcutInjection);\r\n    };\r\n    /**\r\n     * Creates a tube mesh.\r\n     * The tube is a parametric shape. It has no predefined shape. Its final shape will depend on the input parameters\r\n     * * The parameter `path` is a required array of successive Vector3. It is the curve used as the axis of the tube\r\n     * * The parameter `radius` (positive float, default 1) sets the tube radius size\r\n     * * The parameter `tessellation` (positive float, default 64) is the number of sides on the tubular surface\r\n     * * The parameter `radiusFunction` (javascript function, default null) is a vanilla javascript function. If it is not null, it overwrittes the parameter `radius`\r\n     * * This function is called on each point of the tube path and is passed the index `i` of the i-th point and the distance of this point from the first point of the path. It must return a radius value (positive float)\r\n     * * The parameter `arc` (positive float, maximum 1, default 1) is the ratio to apply to the tube circumference : 2 x PI x arc\r\n     * * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL\r\n     * * The optional parameter `instance` is an instance of an existing Tube object to be updated with the passed `pathArray` parameter : https://doc.babylonjs.com/how_to/how_to_dynamically_morph_a_mesh#tube\r\n     * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n     * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\r\n     * * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture\r\n     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n     * @param name defines the name of the mesh\r\n     * @param options defines the options used to create the mesh\r\n     * @param scene defines the hosting scene\r\n     * @returns the tube mesh\r\n     * @see https://doc.babylonjs.com/how_to/parametric_shapes\r\n     * @see https://doc.babylonjs.com/how_to/set_shapes#tube\r\n     */\r\n    MeshBuilder.CreateTube = function (name, options, scene) {\r\n        if (scene === void 0) { scene = null; }\r\n        return _Builders_tubeBuilder__WEBPACK_IMPORTED_MODULE_13__[\"TubeBuilder\"].CreateTube(name, options, scene);\r\n    };\r\n    /**\r\n     * Creates a polyhedron mesh\r\n     * * The parameter `type` (positive integer, max 14, default 0) sets the polyhedron type to build among the 15 embbeded types. Please refer to the type sheet in the tutorial to choose the wanted type\r\n     * * The parameter `size` (positive float, default 1) sets the polygon size\r\n     * * You can overwrite the `size` on each dimension bu using the parameters `sizeX`, `sizeY` or `sizeZ` (positive floats, default to `size` value)\r\n     * * You can build other polyhedron types than the 15 embbeded ones by setting the parameter `custom` (`polyhedronObject`, default null). If you set the parameter `custom`, this overwrittes the parameter `type`\r\n     * * A `polyhedronObject` is a formatted javascript object. You'll find a full file with pre-set polyhedra here : https://github.com/BabylonJS/Extensions/tree/master/Polyhedron\r\n     * * You can set the color and the UV of each side of the polyhedron with the parameters `faceColors` (Color4, default `(1, 1, 1, 1)`) and faceUV (Vector4, default `(0, 0, 1, 1)`)\r\n     * * To understand how to set `faceUV` or `faceColors`, please read this by considering the right number of faces of your polyhedron, instead of only 6 for the box : https://doc.babylonjs.com/how_to/createbox_per_face_textures_and_colors\r\n     * * The parameter `flat` (boolean, default true). If set to false, it gives the polyhedron a single global face, so less vertices and shared normals. In this case, `faceColors` and `faceUV` are ignored\r\n     * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n     * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/babylon101/discover_basic_elements#side-orientation\r\n     * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n     * @param name defines the name of the mesh\r\n     * @param options defines the options used to create the mesh\r\n     * @param scene defines the hosting scene\r\n     * @returns the polyhedron mesh\r\n     * @see https://doc.babylonjs.com/how_to/polyhedra_shapes\r\n     */\r\n    MeshBuilder.CreatePolyhedron = function (name, options, scene) {\r\n        if (scene === void 0) { scene = null; }\r\n        return _Builders_polyhedronBuilder__WEBPACK_IMPORTED_MODULE_14__[\"PolyhedronBuilder\"].CreatePolyhedron(name, options, scene);\r\n    };\r\n    /**\r\n     * Creates a decal mesh.\r\n     * A decal is a mesh usually applied as a model onto the surface of another mesh. So don't forget the parameter `sourceMesh` depicting the decal\r\n     * * The parameter `position` (Vector3, default `(0, 0, 0)`) sets the position of the decal in World coordinates\r\n     * * The parameter `normal` (Vector3, default `Vector3.Up`) sets the normal of the mesh where the decal is applied onto in World coordinates\r\n     * * The parameter `size` (Vector3, default `(1, 1, 1)`) sets the decal scaling\r\n     * * The parameter `angle` (float in radian, default 0) sets the angle to rotate the decal\r\n     * @param name defines the name of the mesh\r\n     * @param sourceMesh defines the mesh where the decal must be applied\r\n     * @param options defines the options used to create the mesh\r\n     * @param scene defines the hosting scene\r\n     * @returns the decal mesh\r\n     * @see https://doc.babylonjs.com/how_to/decals\r\n     */\r\n    MeshBuilder.CreateDecal = function (name, sourceMesh, options) {\r\n        return _Builders_decalBuilder__WEBPACK_IMPORTED_MODULE_16__[\"DecalBuilder\"].CreateDecal(name, sourceMesh, options);\r\n    };\r\n    return MeshBuilder;\r\n}());\r\n\r\n//# sourceMappingURL=meshBuilder.js.map\n\n//# sourceURL=webpack:///./node_modules/@babylonjs/core/Meshes/meshBuilder.js?");

/***/ }),

/***/ "./node_modules/@babylonjs/core/Shaders/color.fragment.js":
/*!****************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Shaders/color.fragment.js ***!
  \****************************************************************/
/*! exports provided: colorPixelShader */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"colorPixelShader\", function() { return colorPixelShader; });\n/* harmony import */ var _Materials_effect__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Materials/effect */ \"./node_modules/@babylonjs/core/Materials/effect.js\");\n/* harmony import */ var _ShadersInclude_clipPlaneFragmentDeclaration__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ShadersInclude/clipPlaneFragmentDeclaration */ \"./node_modules/@babylonjs/core/Shaders/ShadersInclude/clipPlaneFragmentDeclaration.js\");\n/* harmony import */ var _ShadersInclude_clipPlaneFragment__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ShadersInclude/clipPlaneFragment */ \"./node_modules/@babylonjs/core/Shaders/ShadersInclude/clipPlaneFragment.js\");\n\r\n\r\n\r\nvar name = 'colorPixelShader';\r\nvar shader = \"#ifdef VERTEXCOLOR\\nvarying vec4 vColor;\\n#else\\nuniform vec4 color;\\n#endif\\n#include<clipPlaneFragmentDeclaration>\\nvoid main(void) {\\n#include<clipPlaneFragment>\\n#ifdef VERTEXCOLOR\\ngl_FragColor=vColor;\\n#else\\ngl_FragColor=color;\\n#endif\\n}\";\r\n_Materials_effect__WEBPACK_IMPORTED_MODULE_0__[\"Effect\"].ShadersStore[name] = shader;\r\n/** @hidden */\r\nvar colorPixelShader = { name: name, shader: shader };\r\n//# sourceMappingURL=color.fragment.js.map\n\n//# sourceURL=webpack:///./node_modules/@babylonjs/core/Shaders/color.fragment.js?");

/***/ }),

/***/ "./node_modules/@babylonjs/core/Shaders/color.vertex.js":
/*!**************************************************************!*\
  !*** ./node_modules/@babylonjs/core/Shaders/color.vertex.js ***!
  \**************************************************************/
/*! exports provided: colorVertexShader */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"colorVertexShader\", function() { return colorVertexShader; });\n/* harmony import */ var _Materials_effect__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Materials/effect */ \"./node_modules/@babylonjs/core/Materials/effect.js\");\n/* harmony import */ var _ShadersInclude_bonesDeclaration__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ShadersInclude/bonesDeclaration */ \"./node_modules/@babylonjs/core/Shaders/ShadersInclude/bonesDeclaration.js\");\n/* harmony import */ var _ShadersInclude_clipPlaneVertexDeclaration__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ShadersInclude/clipPlaneVertexDeclaration */ \"./node_modules/@babylonjs/core/Shaders/ShadersInclude/clipPlaneVertexDeclaration.js\");\n/* harmony import */ var _ShadersInclude_instancesDeclaration__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ShadersInclude/instancesDeclaration */ \"./node_modules/@babylonjs/core/Shaders/ShadersInclude/instancesDeclaration.js\");\n/* harmony import */ var _ShadersInclude_instancesVertex__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ShadersInclude/instancesVertex */ \"./node_modules/@babylonjs/core/Shaders/ShadersInclude/instancesVertex.js\");\n/* harmony import */ var _ShadersInclude_bonesVertex__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ShadersInclude/bonesVertex */ \"./node_modules/@babylonjs/core/Shaders/ShadersInclude/bonesVertex.js\");\n/* harmony import */ var _ShadersInclude_clipPlaneVertex__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ShadersInclude/clipPlaneVertex */ \"./node_modules/@babylonjs/core/Shaders/ShadersInclude/clipPlaneVertex.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nvar name = 'colorVertexShader';\r\nvar shader = \"\\nattribute vec3 position;\\n#ifdef VERTEXCOLOR\\nattribute vec4 color;\\n#endif\\n#include<bonesDeclaration>\\n#include<clipPlaneVertexDeclaration>\\n\\n#include<instancesDeclaration>\\nuniform mat4 viewProjection;\\n\\n#ifdef VERTEXCOLOR\\nvarying vec4 vColor;\\n#endif\\nvoid main(void) {\\n#include<instancesVertex>\\n#include<bonesVertex>\\nvec4 worldPos=finalWorld*vec4(position,1.0);\\ngl_Position=viewProjection*worldPos;\\n#include<clipPlaneVertex>\\n#ifdef VERTEXCOLOR\\n\\nvColor=color;\\n#endif\\n}\";\r\n_Materials_effect__WEBPACK_IMPORTED_MODULE_0__[\"Effect\"].ShadersStore[name] = shader;\r\n/** @hidden */\r\nvar colorVertexShader = { name: name, shader: shader };\r\n//# sourceMappingURL=color.vertex.js.map\n\n//# sourceURL=webpack:///./node_modules/@babylonjs/core/Shaders/color.vertex.js?");

/***/ }),

/***/ "./node_modules/@babylonjs/materials/grid/grid.fragment.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@babylonjs/materials/grid/grid.fragment.js ***!
  \*****************************************************************/
/*! exports provided: gridPixelShader */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"gridPixelShader\", function() { return gridPixelShader; });\n/* harmony import */ var _babylonjs_core_Materials_effect__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babylonjs/core/Materials/effect */ \"./node_modules/@babylonjs/core/Materials/effect.js\");\n/* harmony import */ var _babylonjs_core_Shaders_ShadersInclude_fogFragmentDeclaration__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babylonjs/core/Shaders/ShadersInclude/fogFragmentDeclaration */ \"./node_modules/@babylonjs/core/Shaders/ShadersInclude/fogFragmentDeclaration.js\");\n/* harmony import */ var _babylonjs_core_Shaders_ShadersInclude_fogFragment__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babylonjs/core/Shaders/ShadersInclude/fogFragment */ \"./node_modules/@babylonjs/core/Shaders/ShadersInclude/fogFragment.js\");\n\r\n\r\n\r\nvar name = 'gridPixelShader';\r\nvar shader = \"#extension GL_OES_standard_derivatives : enable\\n#define SQRT2 1.41421356\\n#define PI 3.14159\\nprecision highp float;\\nuniform vec3 mainColor;\\nuniform vec3 lineColor;\\nuniform vec4 gridControl;\\nuniform vec3 gridOffset;\\n\\nvarying vec3 vPosition;\\nvarying vec3 vNormal;\\n#include<fogFragmentDeclaration>\\n\\n#ifdef OPACITY\\nvarying vec2 vOpacityUV;\\nuniform sampler2D opacitySampler;\\nuniform vec2 vOpacityInfos;\\n#endif\\nfloat getVisibility(float position) {\\n\\nfloat majorGridFrequency=gridControl.y;\\nif (floor(position+0.5) == floor(position/majorGridFrequency+0.5)*majorGridFrequency)\\n{\\nreturn 1.0;\\n}\\nreturn gridControl.z;\\n}\\nfloat getAnisotropicAttenuation(float differentialLength) {\\nconst float maxNumberOfLines=10.0;\\nreturn clamp(1.0/(differentialLength+1.0)-1.0/maxNumberOfLines,0.0,1.0);\\n}\\nfloat isPointOnLine(float position,float differentialLength) {\\nfloat fractionPartOfPosition=position-floor(position+0.5);\\nfractionPartOfPosition/=differentialLength;\\nfractionPartOfPosition=clamp(fractionPartOfPosition,-1.,1.);\\nfloat result=0.5+0.5*cos(fractionPartOfPosition*PI);\\nreturn result;\\n}\\nfloat contributionOnAxis(float position) {\\nfloat differentialLength=length(vec2(dFdx(position),dFdy(position)));\\ndifferentialLength*=SQRT2;\\n\\nfloat result=isPointOnLine(position,differentialLength);\\n\\nfloat visibility=getVisibility(position);\\nresult*=visibility;\\n\\nfloat anisotropicAttenuation=getAnisotropicAttenuation(differentialLength);\\nresult*=anisotropicAttenuation;\\nreturn result;\\n}\\nfloat normalImpactOnAxis(float x) {\\nfloat normalImpact=clamp(1.0-3.0*abs(x*x*x),0.0,1.0);\\nreturn normalImpact;\\n}\\nvoid main(void) {\\n\\nfloat gridRatio=gridControl.x;\\nvec3 gridPos=(vPosition+gridOffset.xyz)/gridRatio;\\n\\nfloat x=contributionOnAxis(gridPos.x);\\nfloat y=contributionOnAxis(gridPos.y);\\nfloat z=contributionOnAxis(gridPos.z);\\n\\nvec3 normal=normalize(vNormal);\\nx*=normalImpactOnAxis(normal.x);\\ny*=normalImpactOnAxis(normal.y);\\nz*=normalImpactOnAxis(normal.z);\\n\\nfloat grid=clamp(x+y+z,0.,1.);\\n\\nvec3 color=mix(mainColor,lineColor,grid);\\n#ifdef FOG\\n#include<fogFragment>\\n#endif\\nfloat opacity=1.0;\\n#ifdef TRANSPARENT\\nopacity=clamp(grid,0.08,gridControl.w*grid);\\n#endif\\n#ifdef OPACITY\\nopacity*=texture2D(opacitySampler,vOpacityUV).a;\\n#endif\\n\\ngl_FragColor=vec4(color.rgb,opacity);\\n#ifdef TRANSPARENT\\n#ifdef PREMULTIPLYALPHA\\ngl_FragColor.rgb*=opacity;\\n#endif\\n#else\\n#endif\\n}\";\r\n_babylonjs_core_Materials_effect__WEBPACK_IMPORTED_MODULE_0__[\"Effect\"].ShadersStore[name] = shader;\r\n/** @hidden */\r\nvar gridPixelShader = { name: name, shader: shader };\r\n//# sourceMappingURL=grid.fragment.js.map\n\n//# sourceURL=webpack:///./node_modules/@babylonjs/materials/grid/grid.fragment.js?");

/***/ }),

/***/ "./node_modules/@babylonjs/materials/grid/grid.vertex.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babylonjs/materials/grid/grid.vertex.js ***!
  \***************************************************************/
/*! exports provided: gridVertexShader */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"gridVertexShader\", function() { return gridVertexShader; });\n/* harmony import */ var _babylonjs_core_Materials_effect__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babylonjs/core/Materials/effect */ \"./node_modules/@babylonjs/core/Materials/effect.js\");\n/* harmony import */ var _babylonjs_core_Shaders_ShadersInclude_fogVertexDeclaration__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babylonjs/core/Shaders/ShadersInclude/fogVertexDeclaration */ \"./node_modules/@babylonjs/core/Shaders/ShadersInclude/fogVertexDeclaration.js\");\n/* harmony import */ var _babylonjs_core_Shaders_ShadersInclude_fogVertex__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babylonjs/core/Shaders/ShadersInclude/fogVertex */ \"./node_modules/@babylonjs/core/Shaders/ShadersInclude/fogVertex.js\");\n\r\n\r\n\r\nvar name = 'gridVertexShader';\r\nvar shader = \"precision highp float;\\n\\nattribute vec3 position;\\nattribute vec3 normal;\\n#ifdef UV1\\nattribute vec2 uv;\\n#endif\\n#ifdef UV2\\nattribute vec2 uv2;\\n#endif\\n\\nuniform mat4 projection;\\nuniform mat4 world;\\nuniform mat4 view;\\nuniform mat4 worldView;\\n\\nvarying vec3 vPosition;\\nvarying vec3 vNormal;\\n#include<fogVertexDeclaration>\\n#ifdef OPACITY\\nvarying vec2 vOpacityUV;\\nuniform mat4 opacityMatrix;\\nuniform vec2 vOpacityInfos;\\n#endif\\nvoid main(void) {\\n#ifdef FOG\\nvec4 worldPos=world*vec4(position,1.0);\\n#endif\\n#include<fogVertex>\\nvec4 cameraSpacePosition=worldView*vec4(position,1.0);\\ngl_Position=projection*cameraSpacePosition;\\n#ifdef OPACITY\\n#ifndef UV1\\nvec2 uv=vec2(0.,0.);\\n#endif\\n#ifndef UV2\\nvec2 uv2=vec2(0.,0.);\\n#endif\\nif (vOpacityInfos.x == 0.)\\n{\\nvOpacityUV=vec2(opacityMatrix*vec4(uv,1.0,0.0));\\n}\\nelse\\n{\\nvOpacityUV=vec2(opacityMatrix*vec4(uv2,1.0,0.0));\\n}\\n#endif\\nvPosition=position;\\nvNormal=normal;\\n}\";\r\n_babylonjs_core_Materials_effect__WEBPACK_IMPORTED_MODULE_0__[\"Effect\"].ShadersStore[name] = shader;\r\n/** @hidden */\r\nvar gridVertexShader = { name: name, shader: shader };\r\n//# sourceMappingURL=grid.vertex.js.map\n\n//# sourceURL=webpack:///./node_modules/@babylonjs/materials/grid/grid.vertex.js?");

/***/ }),

/***/ "./node_modules/@babylonjs/materials/grid/gridMaterial.js":
/*!****************************************************************!*\
  !*** ./node_modules/@babylonjs/materials/grid/gridMaterial.js ***!
  \****************************************************************/
/*! exports provided: GridMaterial */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GridMaterial\", function() { return GridMaterial; });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.js\");\n/* harmony import */ var _babylonjs_core_Misc_decorators__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babylonjs/core/Misc/decorators */ \"./node_modules/@babylonjs/core/Misc/decorators.js\");\n/* harmony import */ var _babylonjs_core_Maths_math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babylonjs/core/Maths/math */ \"./node_modules/@babylonjs/core/Maths/math.js\");\n/* harmony import */ var _babylonjs_core_Materials_materialDefines__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babylonjs/core/Materials/materialDefines */ \"./node_modules/@babylonjs/core/Materials/materialDefines.js\");\n/* harmony import */ var _babylonjs_core_Materials_materialHelper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babylonjs/core/Materials/materialHelper */ \"./node_modules/@babylonjs/core/Materials/materialHelper.js\");\n/* harmony import */ var _babylonjs_core_Materials_pushMaterial__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babylonjs/core/Materials/pushMaterial */ \"./node_modules/@babylonjs/core/Materials/pushMaterial.js\");\n/* harmony import */ var _babylonjs_core_Materials_materialFlags__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babylonjs/core/Materials/materialFlags */ \"./node_modules/@babylonjs/core/Materials/materialFlags.js\");\n/* harmony import */ var _babylonjs_core_Meshes_buffer__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @babylonjs/core/Meshes/buffer */ \"./node_modules/@babylonjs/core/Meshes/buffer.js\");\n/* harmony import */ var _babylonjs_core_Misc_typeStore__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @babylonjs/core/Misc/typeStore */ \"./node_modules/@babylonjs/core/Misc/typeStore.js\");\n/* harmony import */ var _grid_fragment__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./grid.fragment */ \"./node_modules/@babylonjs/materials/grid/grid.fragment.js\");\n/* harmony import */ var _grid_vertex__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./grid.vertex */ \"./node_modules/@babylonjs/materials/grid/grid.vertex.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nvar GridMaterialDefines = /** @class */ (function (_super) {\r\n    tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"](GridMaterialDefines, _super);\r\n    function GridMaterialDefines() {\r\n        var _this = _super.call(this) || this;\r\n        _this.OPACITY = false;\r\n        _this.TRANSPARENT = false;\r\n        _this.FOG = false;\r\n        _this.PREMULTIPLYALPHA = false;\r\n        _this.UV1 = false;\r\n        _this.UV2 = false;\r\n        _this.rebuild();\r\n        return _this;\r\n    }\r\n    return GridMaterialDefines;\r\n}(_babylonjs_core_Materials_materialDefines__WEBPACK_IMPORTED_MODULE_3__[\"MaterialDefines\"]));\r\n/**\r\n * The grid materials allows you to wrap any shape with a grid.\r\n * Colors are customizable.\r\n */\r\nvar GridMaterial = /** @class */ (function (_super) {\r\n    tslib__WEBPACK_IMPORTED_MODULE_0__[\"__extends\"](GridMaterial, _super);\r\n    /**\r\n     * constructor\r\n     * @param name The name given to the material in order to identify it afterwards.\r\n     * @param scene The scene the material is used in.\r\n     */\r\n    function GridMaterial(name, scene) {\r\n        var _this = _super.call(this, name, scene) || this;\r\n        /**\r\n         * Main color of the grid (e.g. between lines)\r\n         */\r\n        _this.mainColor = _babylonjs_core_Maths_math__WEBPACK_IMPORTED_MODULE_2__[\"Color3\"].Black();\r\n        /**\r\n         * Color of the grid lines.\r\n         */\r\n        _this.lineColor = _babylonjs_core_Maths_math__WEBPACK_IMPORTED_MODULE_2__[\"Color3\"].Teal();\r\n        /**\r\n         * The scale of the grid compared to unit.\r\n         */\r\n        _this.gridRatio = 1.0;\r\n        /**\r\n         * Allows setting an offset for the grid lines.\r\n         */\r\n        _this.gridOffset = _babylonjs_core_Maths_math__WEBPACK_IMPORTED_MODULE_2__[\"Vector3\"].Zero();\r\n        /**\r\n         * The frequency of thicker lines.\r\n         */\r\n        _this.majorUnitFrequency = 10;\r\n        /**\r\n         * The visibility of minor units in the grid.\r\n         */\r\n        _this.minorUnitVisibility = 0.33;\r\n        /**\r\n         * The grid opacity outside of the lines.\r\n         */\r\n        _this.opacity = 1.0;\r\n        /**\r\n         * Determine RBG output is premultiplied by alpha value.\r\n         */\r\n        _this.preMultiplyAlpha = false;\r\n        _this._gridControl = new _babylonjs_core_Maths_math__WEBPACK_IMPORTED_MODULE_2__[\"Vector4\"](_this.gridRatio, _this.majorUnitFrequency, _this.minorUnitVisibility, _this.opacity);\r\n        return _this;\r\n    }\r\n    /**\r\n     * Returns wehter or not the grid requires alpha blending.\r\n     */\r\n    GridMaterial.prototype.needAlphaBlending = function () {\r\n        return this.opacity < 1.0 || this._opacityTexture && this._opacityTexture.isReady();\r\n    };\r\n    GridMaterial.prototype.needAlphaBlendingForMesh = function (mesh) {\r\n        return this.needAlphaBlending();\r\n    };\r\n    GridMaterial.prototype.isReadyForSubMesh = function (mesh, subMesh, useInstances) {\r\n        if (this.isFrozen) {\r\n            if (this._wasPreviouslyReady && subMesh.effect) {\r\n                return true;\r\n            }\r\n        }\r\n        if (!subMesh._materialDefines) {\r\n            subMesh._materialDefines = new GridMaterialDefines();\r\n        }\r\n        var defines = subMesh._materialDefines;\r\n        var scene = this.getScene();\r\n        if (!this.checkReadyOnEveryCall && subMesh.effect) {\r\n            if (this._renderId === scene.getRenderId()) {\r\n                return true;\r\n            }\r\n        }\r\n        if (defines.TRANSPARENT !== (this.opacity < 1.0)) {\r\n            defines.TRANSPARENT = !defines.TRANSPARENT;\r\n            defines.markAsUnprocessed();\r\n        }\r\n        if (defines.PREMULTIPLYALPHA != this.preMultiplyAlpha) {\r\n            defines.PREMULTIPLYALPHA = !defines.PREMULTIPLYALPHA;\r\n            defines.markAsUnprocessed();\r\n        }\r\n        // Textures\r\n        if (defines._areTexturesDirty) {\r\n            defines._needUVs = false;\r\n            if (scene.texturesEnabled) {\r\n                if (this._opacityTexture && _babylonjs_core_Materials_materialFlags__WEBPACK_IMPORTED_MODULE_6__[\"MaterialFlags\"].OpacityTextureEnabled) {\r\n                    if (!this._opacityTexture.isReady()) {\r\n                        return false;\r\n                    }\r\n                    else {\r\n                        defines._needUVs = true;\r\n                        defines.OPACITY = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        _babylonjs_core_Materials_materialHelper__WEBPACK_IMPORTED_MODULE_4__[\"MaterialHelper\"].PrepareDefinesForMisc(mesh, scene, false, false, this.fogEnabled, false, defines);\r\n        // Get correct effect\r\n        if (defines.isDirty) {\r\n            defines.markAsProcessed();\r\n            scene.resetCachedMaterial();\r\n            // Attributes\r\n            _babylonjs_core_Materials_materialHelper__WEBPACK_IMPORTED_MODULE_4__[\"MaterialHelper\"].PrepareDefinesForAttributes(mesh, defines, false, false);\r\n            var attribs = [_babylonjs_core_Meshes_buffer__WEBPACK_IMPORTED_MODULE_7__[\"VertexBuffer\"].PositionKind, _babylonjs_core_Meshes_buffer__WEBPACK_IMPORTED_MODULE_7__[\"VertexBuffer\"].NormalKind];\r\n            if (defines.UV1) {\r\n                attribs.push(_babylonjs_core_Meshes_buffer__WEBPACK_IMPORTED_MODULE_7__[\"VertexBuffer\"].UVKind);\r\n            }\r\n            if (defines.UV2) {\r\n                attribs.push(_babylonjs_core_Meshes_buffer__WEBPACK_IMPORTED_MODULE_7__[\"VertexBuffer\"].UV2Kind);\r\n            }\r\n            // Defines\r\n            var join = defines.toString();\r\n            subMesh.setEffect(scene.getEngine().createEffect(\"grid\", attribs, [\"projection\", \"worldView\", \"mainColor\", \"lineColor\", \"gridControl\", \"gridOffset\", \"vFogInfos\", \"vFogColor\", \"world\", \"view\",\r\n                \"opacityMatrix\", \"vOpacityInfos\"], [\"opacitySampler\"], join, undefined, this.onCompiled, this.onError), defines);\r\n        }\r\n        if (!subMesh.effect || !subMesh.effect.isReady()) {\r\n            return false;\r\n        }\r\n        this._renderId = scene.getRenderId();\r\n        this._wasPreviouslyReady = true;\r\n        return true;\r\n    };\r\n    GridMaterial.prototype.bindForSubMesh = function (world, mesh, subMesh) {\r\n        var scene = this.getScene();\r\n        var defines = subMesh._materialDefines;\r\n        if (!defines) {\r\n            return;\r\n        }\r\n        var effect = subMesh.effect;\r\n        if (!effect) {\r\n            return;\r\n        }\r\n        this._activeEffect = effect;\r\n        // Matrices\r\n        this.bindOnlyWorldMatrix(world);\r\n        this._activeEffect.setMatrix(\"worldView\", world.multiply(scene.getViewMatrix()));\r\n        this._activeEffect.setMatrix(\"view\", scene.getViewMatrix());\r\n        this._activeEffect.setMatrix(\"projection\", scene.getProjectionMatrix());\r\n        // Uniforms\r\n        if (this._mustRebind(scene, effect)) {\r\n            this._activeEffect.setColor3(\"mainColor\", this.mainColor);\r\n            this._activeEffect.setColor3(\"lineColor\", this.lineColor);\r\n            this._activeEffect.setVector3(\"gridOffset\", this.gridOffset);\r\n            this._gridControl.x = this.gridRatio;\r\n            this._gridControl.y = Math.round(this.majorUnitFrequency);\r\n            this._gridControl.z = this.minorUnitVisibility;\r\n            this._gridControl.w = this.opacity;\r\n            this._activeEffect.setVector4(\"gridControl\", this._gridControl);\r\n            if (this._opacityTexture && _babylonjs_core_Materials_materialFlags__WEBPACK_IMPORTED_MODULE_6__[\"MaterialFlags\"].OpacityTextureEnabled) {\r\n                this._activeEffect.setTexture(\"opacitySampler\", this._opacityTexture);\r\n                this._activeEffect.setFloat2(\"vOpacityInfos\", this._opacityTexture.coordinatesIndex, this._opacityTexture.level);\r\n                this._activeEffect.setMatrix(\"opacityMatrix\", this._opacityTexture.getTextureMatrix());\r\n            }\r\n        }\r\n        // Fog\r\n        _babylonjs_core_Materials_materialHelper__WEBPACK_IMPORTED_MODULE_4__[\"MaterialHelper\"].BindFogParameters(scene, mesh, this._activeEffect);\r\n        this._afterBind(mesh, this._activeEffect);\r\n    };\r\n    /**\r\n     * Dispose the material and its associated resources.\r\n     * @param forceDisposeEffect will also dispose the used effect when true\r\n     */\r\n    GridMaterial.prototype.dispose = function (forceDisposeEffect) {\r\n        _super.prototype.dispose.call(this, forceDisposeEffect);\r\n    };\r\n    GridMaterial.prototype.clone = function (name) {\r\n        var _this = this;\r\n        return _babylonjs_core_Misc_decorators__WEBPACK_IMPORTED_MODULE_1__[\"SerializationHelper\"].Clone(function () { return new GridMaterial(name, _this.getScene()); }, this);\r\n    };\r\n    GridMaterial.prototype.serialize = function () {\r\n        var serializationObject = _babylonjs_core_Misc_decorators__WEBPACK_IMPORTED_MODULE_1__[\"SerializationHelper\"].Serialize(this);\r\n        serializationObject.customType = \"BABYLON.GridMaterial\";\r\n        return serializationObject;\r\n    };\r\n    GridMaterial.prototype.getClassName = function () {\r\n        return \"GridMaterial\";\r\n    };\r\n    GridMaterial.Parse = function (source, scene, rootUrl) {\r\n        return _babylonjs_core_Misc_decorators__WEBPACK_IMPORTED_MODULE_1__[\"SerializationHelper\"].Parse(function () { return new GridMaterial(source.name, scene); }, source, scene, rootUrl);\r\n    };\r\n    tslib__WEBPACK_IMPORTED_MODULE_0__[\"__decorate\"]([\r\n        Object(_babylonjs_core_Misc_decorators__WEBPACK_IMPORTED_MODULE_1__[\"serializeAsColor3\"])()\r\n    ], GridMaterial.prototype, \"mainColor\", void 0);\r\n    tslib__WEBPACK_IMPORTED_MODULE_0__[\"__decorate\"]([\r\n        Object(_babylonjs_core_Misc_decorators__WEBPACK_IMPORTED_MODULE_1__[\"serializeAsColor3\"])()\r\n    ], GridMaterial.prototype, \"lineColor\", void 0);\r\n    tslib__WEBPACK_IMPORTED_MODULE_0__[\"__decorate\"]([\r\n        Object(_babylonjs_core_Misc_decorators__WEBPACK_IMPORTED_MODULE_1__[\"serialize\"])()\r\n    ], GridMaterial.prototype, \"gridRatio\", void 0);\r\n    tslib__WEBPACK_IMPORTED_MODULE_0__[\"__decorate\"]([\r\n        Object(_babylonjs_core_Misc_decorators__WEBPACK_IMPORTED_MODULE_1__[\"serializeAsColor3\"])()\r\n    ], GridMaterial.prototype, \"gridOffset\", void 0);\r\n    tslib__WEBPACK_IMPORTED_MODULE_0__[\"__decorate\"]([\r\n        Object(_babylonjs_core_Misc_decorators__WEBPACK_IMPORTED_MODULE_1__[\"serialize\"])()\r\n    ], GridMaterial.prototype, \"majorUnitFrequency\", void 0);\r\n    tslib__WEBPACK_IMPORTED_MODULE_0__[\"__decorate\"]([\r\n        Object(_babylonjs_core_Misc_decorators__WEBPACK_IMPORTED_MODULE_1__[\"serialize\"])()\r\n    ], GridMaterial.prototype, \"minorUnitVisibility\", void 0);\r\n    tslib__WEBPACK_IMPORTED_MODULE_0__[\"__decorate\"]([\r\n        Object(_babylonjs_core_Misc_decorators__WEBPACK_IMPORTED_MODULE_1__[\"serialize\"])()\r\n    ], GridMaterial.prototype, \"opacity\", void 0);\r\n    tslib__WEBPACK_IMPORTED_MODULE_0__[\"__decorate\"]([\r\n        Object(_babylonjs_core_Misc_decorators__WEBPACK_IMPORTED_MODULE_1__[\"serialize\"])()\r\n    ], GridMaterial.prototype, \"preMultiplyAlpha\", void 0);\r\n    tslib__WEBPACK_IMPORTED_MODULE_0__[\"__decorate\"]([\r\n        Object(_babylonjs_core_Misc_decorators__WEBPACK_IMPORTED_MODULE_1__[\"serializeAsTexture\"])(\"opacityTexture\")\r\n    ], GridMaterial.prototype, \"_opacityTexture\", void 0);\r\n    tslib__WEBPACK_IMPORTED_MODULE_0__[\"__decorate\"]([\r\n        Object(_babylonjs_core_Misc_decorators__WEBPACK_IMPORTED_MODULE_1__[\"expandToProperty\"])(\"_markAllSubMeshesAsTexturesDirty\")\r\n    ], GridMaterial.prototype, \"opacityTexture\", void 0);\r\n    return GridMaterial;\r\n}(_babylonjs_core_Materials_pushMaterial__WEBPACK_IMPORTED_MODULE_5__[\"PushMaterial\"]));\r\n\r\n_babylonjs_core_Misc_typeStore__WEBPACK_IMPORTED_MODULE_8__[\"_TypeStore\"].RegisteredTypes[\"BABYLON.GridMaterial\"] = GridMaterial;\r\n//# sourceMappingURL=gridMaterial.js.map\n\n//# sourceURL=webpack:///./node_modules/@babylonjs/materials/grid/gridMaterial.js?");

/***/ }),

/***/ "./node_modules/@babylonjs/materials/grid/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@babylonjs/materials/grid/index.js ***!
  \*********************************************************/
/*! exports provided: GridMaterial */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _gridMaterial__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./gridMaterial */ \"./node_modules/@babylonjs/materials/grid/gridMaterial.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"GridMaterial\", function() { return _gridMaterial__WEBPACK_IMPORTED_MODULE_0__[\"GridMaterial\"]; });\n\n\r\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///./node_modules/@babylonjs/materials/grid/index.js?");

/***/ })

}]);
(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[1],{

/***/ "./src/Joint.js":
/*!**********************!*\
  !*** ./src/Joint.js ***!
  \**********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Joint; });\n/* harmony import */ var _babylonjs_core_Maths_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babylonjs/core/Maths/math */ \"./node_modules/@babylonjs/core/Maths/math.js\");\n\n\nclass Joint {\n    constructor(part, node_name) {\n        this.part = part;\n        this.node_name = node_name;\n    }\n\n    get node() {\n        return this.part[this.node_name];\n    }\n\n    get matrix() {\n        return this.node.getWorldMatrix();\n    }\n\n    get inverse_matrix() {\n        return _babylonjs_core_Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Matrix\"].Invert(this.matrix);\n    }\n\n    get position() {\n        return _babylonjs_core_Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"].TransformCoordinates(_babylonjs_core_Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"].Zero(), this.matrix);\n    }\n}\n\n\n//# sourceURL=webpack:///./src/Joint.js?");

/***/ }),

/***/ "./src/machines/AverageBox.js":
/*!************************************!*\
  !*** ./src/machines/AverageBox.js ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return AverageBox; });\n/* harmony import */ var _babylonjs_core_Maths_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babylonjs/core/Maths/math */ \"./node_modules/@babylonjs/core/Maths/math.js\");\n/* harmony import */ var _Machine__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Machine */ \"./src/machines/Machine.js\");\n/* harmony import */ var _parts_Point__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../parts/Point */ \"./src/parts/Point.js\");\n/* harmony import */ var _parts_Oscillator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../parts/Oscillator */ \"./src/parts/Oscillator.js\");\n/* harmony import */ var _parts_Centroid__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../parts/Centroid */ \"./src/parts/Centroid.js\");\n/* harmony import */ var _parts_Trace__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../parts/Trace */ \"./src/parts/Trace.js\");\n\n\n\n\n\n\n\n\n/**\n * 12 points oscillating on the edges of a cuboid. The curve is defined to be\n * the centroid of all 12 positions.\n */\nclass AverageBox extends _Machine__WEBPACK_IMPORTED_MODULE_1__[\"default\"] {\n    get default_parameters() {\n        return { \n            parent: undefined,\n            // Dimensions of the scale of the box in each dimension. These\n            // will also be the amplitudes of the oscillation\n            size: new _babylonjs_core_Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](3, 3, 3),\n            // Frequencies of each point's oscillation in cycles/sec\n            frequencies: [\n                0.1, \n                0.2, \n                0.3, \n                0.4, \n                0.5, \n                0.6, \n                0.7, \n                0.8, \n                0.9, \n                1.0, \n                1.1, \n                1.2\n            ],\n            // Weights of each point since the centroid is a weighted avverage\n            weights: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n            // Phases of oscillation to tweak things further\n            phases: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            // How many points in the trace\n            trace_length: 10000,\n        }\n    }\n\n    static get NUM_OSCILATORS() {\n        return 12;\n    }\n\n    static get DIRECTIONS() {\n        const right = new _babylonjs_core_Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](1, 0, 0);\n        const up = new _babylonjs_core_Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0, 1, 0);\n        const back = new _babylonjs_core_Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0, 0, 1);\n        const left = new _babylonjs_core_Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](-1, 0, 0);\n        const down = new _babylonjs_core_Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0, -1, 0);\n        const front = new _babylonjs_core_Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0, 0, -1);\n        return {\n            up,\n            down,\n            left,\n            right,\n            front,\n            back\n        };\n    }\n\n    static get OSCILATION_DIRECTIONS() {\n        const dirs = this.DIRECTIONS;\n        return [\n            dirs.right, \n            dirs.right, \n            dirs.right, \n            dirs.right,\n            dirs.up, \n            dirs.up, \n            dirs.up, \n            dirs.up,\n            dirs.back, \n            dirs.back, \n            dirs.back, \n            dirs.back\n        ];\n    }\n\n    get_offsets(parameters) {\n        const size = parameters.size;\n        const dirs = AverageBox.DIRECTIONS;\n        const front = dirs.front.scale(size.z);\n        const back = dirs.back.scale(size.z);\n        const left = dirs.left.scale(size.x);\n        const right = dirs.right.scale(size.x);\n        const up = dirs.up.scale(size.y);\n        const down = dirs.down.scale(size.y);\n        return [\n            front.add(up),\n            front.add(down),\n            back.add(up),\n            back.add(down),\n            front.add(left),\n            front.add(right),\n            back.add(left),\n            back.add(right),\n            left.add(up),\n            left.add(down),\n            right.add(up),\n            right.add(down)\n        ];\n    }\n\n    get_amplitudes(parameters) {\n        const size = parameters.size;        \n        return [\n            size.x,\n            size.x,\n            size.x,\n            size.x,\n            size.y,\n            size.y,\n            size.y,\n            size.y,\n            size.z,\n            size.z,\n            size.z,\n            size.z\n        ];\n    } \n    \n    make_oscillators(parameters, origin) {\n        const oscillators = [];\n        const size = parameters.size;\n        const phases = parameters.phases;\n        const frequencies = parameters.frequencies;\n        const dirs = AverageBox.OSCILATION_DIRECTIONS;\n        const offsets = this.get_offsets(parameters);\n        const amplitudes = this.get_amplitudes(parameters);\n        const origin_joint = origin.to_joint('translate');\n        const radius = 0.2;\n\n        for (let i = 0; i < AverageBox.NUM_OSCILATORS; i++) {\n            const osc = new _parts_Oscillator__WEBPACK_IMPORTED_MODULE_3__[\"default\"]({\n                parent: origin_joint,\n                offset: offsets[i],\n                direction: dirs[i],\n                amplitude: amplitudes[i],\n                frequency: frequencies[i],\n                phase: phases[i],\n                radius: radius\n            });\n            oscillators.push(osc);\n        }\n        return oscillators;\n    }\n\n    init(parameters) {\n        const origin = new _parts_Point__WEBPACK_IMPORTED_MODULE_2__[\"default\"]({\n            parent: parameters.parent,\n            offset: _babylonjs_core_Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"].Zero(),\n            show_offset: false\n        });\n        const oscs = this.make_oscillators(parameters, origin);\n        const centroid = new _parts_Centroid__WEBPACK_IMPORTED_MODULE_4__[\"default\"]({\n            points: oscs.map(x => x.to_joint('translate_wave')),\n            origin: origin.to_joint('translate'),\n            weights: parameters.weights\n        });\n        const trace = new _parts_Trace__WEBPACK_IMPORTED_MODULE_5__[\"default\"]({ \n            source: centroid.to_joint('translate'),\n            origin: origin.to_joint('translate'),\n            num_points: parameters.trace_length\n        });\n\n        this.add_part(origin);\n        this.add_parts(oscs);\n        this.add_part(centroid, 'centroid');\n        this.add_part(trace);\n\n        return origin;\n    }\n}\n\n\n//# sourceURL=webpack:///./src/machines/AverageBox.js?");

/***/ }),

/***/ "./src/machines/CentroidViewer.js":
/*!****************************************!*\
  !*** ./src/machines/CentroidViewer.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return CentroidViewer; });\n/* harmony import */ var _babylonjs_core_Maths_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babylonjs/core/Maths/math */ \"./node_modules/@babylonjs/core/Maths/math.js\");\n/* harmony import */ var _Machine__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Machine */ \"./src/machines/Machine.js\");\n/* harmony import */ var _parts_Point__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../parts/Point */ \"./src/parts/Point.js\");\n/* harmony import */ var _parts_Centroid__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../parts/Centroid */ \"./src/parts/Centroid.js\");\n/* harmony import */ var _parts_Trace__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../parts/Trace */ \"./src/parts/Trace.js\");\n/* harmony import */ var _palettes_ColorStops__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../palettes/ColorStops */ \"./src/palettes/ColorStops.js\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../util */ \"./src/util.js\");\n\n\n\n\n\n\n\n\n\n/**\n * A CentroidViewer is like a PartViewer, except it allows for multiple\n * parts and adds a centroid to combine the results\n */\nclass CentroidViewer extends _Machine__WEBPACK_IMPORTED_MODULE_1__[\"default\"] {\n    get default_parameters() {\n        return {\n            parts: [],\n            joint_names: [],\n            offsets: [],\n            weights: [],\n            trace_length: 1000,\n            palette: new _palettes_ColorStops__WEBPACK_IMPORTED_MODULE_5__[\"default\"]({\n                colors: [\n                    new _babylonjs_core_Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Color4\"](0, 1, 1, 1),\n                    new _babylonjs_core_Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Color4\"](1, 0.5, 0, 1),\n                    new _babylonjs_core_Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Color4\"](1, 0.5, 0, 1),\n                    new _babylonjs_core_Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Color4\"](1, 0.5, 0, 1),\n                    new _babylonjs_core_Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Color4\"](0, 1, 1, 1),\n                ],\n                stops: [0, 1/4, 1/2, 3/4, 1]\n            }),\n            palette_freq: 20\n        };\n    }\n\n    make_offsets(parameters, origin) {\n        const points = [];\n        for (let offset of parameters.offsets) {\n            const point = new _parts_Point__WEBPACK_IMPORTED_MODULE_2__[\"default\"]({\n                parent: origin.to_joint('translate'),\n                offset: offset,\n            });\n            points.push(point);\n        }\n        return points;\n    }\n\n    make_parts(parameters, offsets) {\n        const parts = [];\n        for (let i = 0; i < parameters.parts.length; i++) {\n            const part = parameters.parts[i];\n            part.change_parent(offsets[i].to_joint('translate'));\n            parts.push(part);\n        }\n        return parts;\n    }\n\n    make_centroid(parameters, parts, origin) {\n        const names = parameters.joint_names;\n        const joints = parts.map((part, i) => part.to_joint(names[i]));\n        return new _parts_Centroid__WEBPACK_IMPORTED_MODULE_3__[\"default\"]({\n            points: joints,\n            weights: parameters.weights,\n            origin: origin.to_joint('translate'),\n        });\n    }\n\n    init(parameters) {\n        const origin = new _parts_Point__WEBPACK_IMPORTED_MODULE_2__[\"default\"]({\n            show_offset: true\n        });\n        const offsets = this.make_offsets(parameters, origin);\n        const parts = this.make_parts(parameters, offsets);\n        const centroid = this.make_centroid(parameters, parts, origin);\n        const trace = new _parts_Trace__WEBPACK_IMPORTED_MODULE_4__[\"default\"]({ \n            source: centroid.to_joint('translate'),\n            origin: origin.to_joint('translate'),\n            num_points: parameters.trace_length,\n            palette: parameters.palette,\n            palette_freq: parameters.palette_freq\n        });\n\n        this.add_part(origin);\n        this.add_parts(offsets);\n        this.add_parts(parts);\n        this.add_part(centroid);\n        this.add_part(trace);\n\n        return origin;\n    }\n}\n\n\n//# sourceURL=webpack:///./src/machines/CentroidViewer.js?");

/***/ }),

/***/ "./src/machines/FourierSeries3D.js":
/*!*****************************************!*\
  !*** ./src/machines/FourierSeries3D.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return FourierSeries3D; });\n/* harmony import */ var _babylonjs_core_Maths_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babylonjs/core/Maths/math */ \"./node_modules/@babylonjs/core/Maths/math.js\");\n/* harmony import */ var _Machine__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Machine */ \"./src/machines/Machine.js\");\n/* harmony import */ var _parts_Point__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../parts/Point */ \"./src/parts/Point.js\");\n/* harmony import */ var _parts_RotatingSphere__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../parts/RotatingSphere */ \"./src/parts/RotatingSphere.js\");\n/* harmony import */ var _parts_Trace__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../parts/Trace */ \"./src/parts/Trace.js\");\n/* harmony import */ var _palettes_WavePalette__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../palettes/WavePalette */ \"./src/palettes/WavePalette.js\");\n\n\n\n\n\n\n\n\nclass FourierSeries3D extends _Machine__WEBPACK_IMPORTED_MODULE_1__[\"default\"] {\n    get default_parameters() {\n        return {\n            parent: undefined,\n            amplitudes: [4, 3, 2, 1],\n            angular_frequencies: [1, 1.25, 3.25, 4.5].map(x => x * Math.PI / 4),\n            phases: [0, 0, 0, 0],\n            axes: [\n                new _babylonjs_core_Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0, 1, 0),\n                new _babylonjs_core_Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0, 1, 0),\n                new _babylonjs_core_Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0, 1, 0),\n                new _babylonjs_core_Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0, 1, 0),\n            ],\n            trace_length: 1000,\n            time_step: 1/100,\n            palette: new _palettes_WavePalette__WEBPACK_IMPORTED_MODULE_5__[\"default\"](),\n            palette_freq: 2,\n        }\n    }\n\n    get time_step() {\n        return this._time_step;\n    }\n\n    make_spheres(parameters, origin) {\n        const spheres = [];\n        let current_parent = origin;\n        for (let i = 0; i < parameters.amplitudes.length; i++) {\n            const sphere = new _parts_RotatingSphere__WEBPACK_IMPORTED_MODULE_3__[\"default\"]({\n                radius: parameters.amplitudes[i],\n                axes: [parameters.axes[i]],\n                angular_frequencies: [parameters.angular_frequencies[i]],\n                phases: [parameters.phases[i]],\n                parent: current_parent.to_joint('translate')\n            });\n            spheres.push(sphere);\n            current_parent = sphere;\n        }\n        return spheres;\n    }\n\n    init(parameters) { \n        this._time_step = parameters.time_step;\n        const origin = new _parts_Point__WEBPACK_IMPORTED_MODULE_2__[\"default\"]({\n            parent: parameters.parent,\n            offset: _babylonjs_core_Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"].Zero(),\n            show_offset: false\n        });\n        const spheres = this.make_spheres(parameters, origin);\n        const last_sphere = spheres[spheres.length - 1];\n\n        const trace = new _parts_Trace__WEBPACK_IMPORTED_MODULE_4__[\"default\"]({ \n            source: last_sphere.to_joint('translate'),\n            origin: origin.to_joint('translate'),\n            num_points: parameters.trace_length,\n            palette: parameters.palette,\n            palette_freq: parameters.palette_freq\n        });\n\n        this.add_part(origin);\n        this.add_parts(spheres);\n        this.add_part(trace);\n\n        return origin;\n    }\n}\n\n\n//# sourceURL=webpack:///./src/machines/FourierSeries3D.js?");

/***/ }),

/***/ "./src/machines/Machine.js":
/*!*********************************!*\
  !*** ./src/machines/Machine.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Machine; });\nclass Machine {\n    constructor(parameters) {\n        // map of part id -> part\n        this.part_table = new Map();\n\n        // part ids, the ver\n        this.vertices = [];\n        // Map of parent id -> [child id]\n        this.edges = new Map();\n        // Optional map of label -> id\n        this.labels = new Map();\n\n        // True if vertices are in topologically sorted order.\n        this.is_sorted = true;\n\n        // Initialize the machine based on parameters\n        this.root_part = this.init({...this.default_parameters, ...parameters});\n    }\n\n    get machine_type() {\n        return 'machine';\n    }\n    \n    // Return some default parameters to set an example to the user \n    get default_parameters() {\n        return {\n            parent: undefined,\n        };\n    }\n\n    get time_step() {\n        return 1 / 60;\n    }\n\n    add_edge(parent_id, child_id) {\n        if (!this.edges.has(parent_id)) {\n            this.edges.set(parent_id, []);\n        }\n\n        this.edges.get(parent_id).push(child_id);\n    }\n\n    add_part(part, label) {\n        // Add the part to a lookup table and add a vertex to the DAG\n        const id = part.id;\n        this.vertices.push(id);\n        this.part_table.set(id, part);\n        this.labels.set(label, id);\n\n        // Mark the topological sorting as invalid\n        this.is_sorted = false;\n\n        // Add edges to the DAG\n        for (let parent of part.parents) {\n            const parent_id = parent.id;\n            this.add_edge(parent_id, id);\n        }\n    }\n\n    add_parts(parts) {\n        for (let part of parts) {\n            this.add_part(part);\n        }\n    }\n\n    get_part(part_id) {\n        return this.part_table.get(part_id);\n    }\n    \n    find_part(label) {\n        const part_id = this.labels.get(label);\n        return this.get_part(part_id);\n    }\n\n    postorder(vertex, visited, results) {\n        // Skip if we've already seen this node\n        if (visited.has(vertex)) {\n            return;\n        }\n\n        // Add this to the visited list\n        visited.add(vertex);\n\n        // Recurse\n        const children = this.edges.get(vertex) || [];\n        for (let child_id of children) {\n            this.postorder(child_id, visited, results);\n        }\n\n        // Finally, add our vertex at the end\n        results.push(vertex);\n    }\n\n    get is_empty() {\n        return this.vertices.length == 0;\n    }\n\n    /**\n     * sort this.nodes\n     */\n    topological_sort() {\n        // Empty DAG is always sorted!\n        if (this.is_empty) {\n            return;\n        }\n\n        // do a DFS on the DAG to order the nodes in reverse topological sort \n        // order\n        const visited = new Set();\n        const path = [];\n        for (let vertex of this.vertices) {\n            this.postorder(vertex, visited, path);\n        }\n\n        // Reversing the path gives the topological sort order, i.e. the\n        // order in which we will update the parts respecting dependencies\n        path.reverse();\n        this.vertices = path;\n    }\n\n    /**\n     * Iterate over the parts in topologically sorted order. If not\n     * already sorted, the DAG will be sorted automatically.\n     * This is O(n) where n is the number of nodes.\n     */\n    * parts() {\n        if (!this.is_sorted) {\n            this.topological_sort();\n            this.is_sorted = true;\n        }\n\n        for (let vertex of this.vertices) {\n            yield this.part_table.get(vertex);\n        }\n    }\n    \n    init(parameters) {\n        // Subclasses will initialize the parts\n        return undefined;\n    }\n\n    build(scene) {\n        let root_primitive = undefined;\n        for (let part of this.parts()) {\n            const primitive = part.build(scene);\n            if (root_primitive === undefined) {\n                root_primitive = primitive;\n            }\n        }\n        return root_primitive;\n    }\n\n    update(t) {\n        for (let part of this.parts()) {\n            part.update(t);\n        }\n    }\n}\n\n\n//# sourceURL=webpack:///./src/machines/Machine.js?");

/***/ }),

/***/ "./src/machines/PartViewer.js":
/*!************************************!*\
  !*** ./src/machines/PartViewer.js ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return PartViewer; });\n/* harmony import */ var _babylonjs_core_Maths_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babylonjs/core/Maths/math */ \"./node_modules/@babylonjs/core/Maths/math.js\");\n/* harmony import */ var _Machine__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Machine */ \"./src/machines/Machine.js\");\n/* harmony import */ var _parts_Point__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../parts/Point */ \"./src/parts/Point.js\");\n/* harmony import */ var _parts_Trace__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../parts/Trace */ \"./src/parts/Trace.js\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util */ \"./src/util.js\");\n\n\n\n\n\n\n\nclass PartViewer extends _Machine__WEBPACK_IMPORTED_MODULE_1__[\"default\"] {\n    get default_parameters() {\n        return {\n            // Translation for the origin\n            origin_offset: _babylonjs_core_Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"].Zero(),\n            // How many points to store in the trace\n            trace_length: 1000,\n            // Part object to store (required)\n            part: undefined,\n            // What joint of the part to connect the trace to\n            trace_joint: 'translate',\n            // Time step\n            time_step: 1 / 60,\n        };\n    }\n\n    get time_step() {\n        return this._time_step;\n    }\n\n    init(parameters) {\n        this._time_step = parameters.time_step;\n\n        const origin = new _parts_Point__WEBPACK_IMPORTED_MODULE_2__[\"default\"]({\n            offset: parameters.origin_offset,\n            show_offset: false\n        });\n\n        const part = Object(_util__WEBPACK_IMPORTED_MODULE_4__[\"required\"])(parameters, 'part');\n        part.parent = origin.to_joint('translate');\n        \n        const trace = new _parts_Trace__WEBPACK_IMPORTED_MODULE_3__[\"default\"]({ \n            source: part.to_joint(parameters.trace_joint),\n            origin: origin.to_joint('translate'),\n            num_points: parameters.trace_length\n        });\n\n        this.add_part(origin);\n        this.add_part(part, 'part');\n        this.add_part(trace);\n\n        return origin;\n    } \n}\n\n\n//# sourceURL=webpack:///./src/machines/PartViewer.js?");

/***/ }),

/***/ "./src/palettes/ColorStops.js":
/*!************************************!*\
  !*** ./src/palettes/ColorStops.js ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return ColorStops; });\n/* harmony import */ var _babylonjs_core_Maths_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babylonjs/core/Maths/math */ \"./node_modules/@babylonjs/core/Maths/math.js\");\n/* harmony import */ var _Palette__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Palette */ \"./src/palettes/Palette.js\");\n\n\n\n\nfunction lerp(a, b, t) {\n    return a * (1.0 - t) + b * t;\n}\n\nfunction lerp_colors(color_a, color_b, t) {\n    const r = lerp(color_a.r, color_b.r, t);\n    const g = lerp(color_a.g, color_b.g, t);\n    const b = lerp(color_a.b, color_b.b, t);\n    const a = lerp(color_a.a, color_b.a, t);\n    return new _babylonjs_core_Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Color4\"](r, g, b, a);\n}\n\nfunction smoothstep(a, b, t) {\n    if (t < a) {\n        return 0;\n    } \n\n    if (b < t) {\n        return 1;\n    }\n\n    return 3 * t * t - 2 * t * t * t;\n}\n\nclass ColorStops extends _Palette__WEBPACK_IMPORTED_MODULE_1__[\"default\"] {\n    get default_parameters() {\n        return {\n            stops: [0, 1/3, 2/3, 1],\n            colors: [\n                new _babylonjs_core_Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Color4\"](0, 0, 0, 1),\n                new _babylonjs_core_Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Color4\"](1, 0, 0, 1),\n                new _babylonjs_core_Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Color4\"](0, 0, 0, 1),\n                new _babylonjs_core_Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Color4\"](0, 0, 1, 1),\n            ]\n        }\n    }\n\n    init(parameters) {\n        this.stops = parameters.stops;\n        this.colors = parameters.colors;\n    }\n\n    get_color(t) {\n        let result = this.colors[0];\n        for (let i = 1; i < this.colors.length; i++) {\n            const prev_stop = this.stops[i - 1];\n            const stop = this.stops[i];\n            const color = this.colors[i];\n            const blend_factor = smoothstep(prev_stop, stop, t);\n            result = lerp_colors(result, color, blend_factor);\n        }\n        return result;\n    }\n}\n\n\n//# sourceURL=webpack:///./src/palettes/ColorStops.js?");

/***/ }),

/***/ "./src/palettes/Palette.js":
/*!*********************************!*\
  !*** ./src/palettes/Palette.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Palette; });\n/* harmony import */ var _babylonjs_core_Maths_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babylonjs/core/Maths/math */ \"./node_modules/@babylonjs/core/Maths/math.js\");\n\n\nclass Palette {\n    get default_parameters() {\n        return {};\n    }\n\n    constructor(parameters) {\n        this.init({...this.default_parameters, ...parameters});\n    }\n\n    init(parameters) {\n\n    }\n\n    get_color(t) {\n        // Subclasses can return a color for an input\n        // t from [0, 1]\n        return new _babylonjs_core_Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Color4\"](0, 0, 0, 0);\n    }\n\n    get_palette(n, freq) {\n        const results = [];\n        for (let i = 0; i < n; i++) {\n            const t = i / (n - 1);\n            const effective_t = (t * freq) % 1.0;\n            results.push(this.get_color(effective_t));\n        }\n        return results;\n    }\n}\n\n\n//# sourceURL=webpack:///./src/palettes/Palette.js?");

/***/ }),

/***/ "./src/palettes/WavePalette.js":
/*!*************************************!*\
  !*** ./src/palettes/WavePalette.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return WavePalette; });\n/* harmony import */ var _babylonjs_core_Maths_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babylonjs/core/Maths/math */ \"./node_modules/@babylonjs/core/Maths/math.js\");\n/* harmony import */ var _Palette__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Palette */ \"./src/palettes/Palette.js\");\n/* harmony import */ var _waves_Sine__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../waves/Sine */ \"./src/waves/Sine.js\");\n\n\n\n\n\nclass WavePalette extends _Palette__WEBPACK_IMPORTED_MODULE_1__[\"default\"] {\n    get default_parameters() {\n        return {\n            waves: [new _waves_Sine__WEBPACK_IMPORTED_MODULE_2__[\"default\"](), new _waves_Sine__WEBPACK_IMPORTED_MODULE_2__[\"default\"](), new _waves_Sine__WEBPACK_IMPORTED_MODULE_2__[\"default\"](), new _waves_Sine__WEBPACK_IMPORTED_MODULE_2__[\"default\"]()],\n            biases: [0.3, 0.5, 0.6, 1.0],\n            amplitudes: [0.5, 0.7, 0.5, 0],            \n            frequencies: [1, 4, 10, 0],\n            phases: [0.6, 0.1, 0.4, 0]\n        }\n    }\n\n    constructor(parameters) {\n        super();\n        this.init({...this.default_parameters, ...parameters});\n    }\n\n    init(parameters) {\n        this.waves = parameters.waves;\n        this.biases = parameters.biases;\n        this.amplitudes = parameters.amplitudes;\n        this.frequencies = parameters.frequencies;\n        this.phases = parameters.phases;\n    }\n\n    get_color(t) { \n        const components = [];\n        for (let i = 0; i < 4; i++) {\n            const wave = this.waves[i];\n            const bias = this.biases[i];\n            const amp = this.amplitudes[i];\n            const freq = this.frequencies[i];\n            const phase = this.phases[i];\n\n            const angle = 2 * Math.PI * (freq * t + phase);\n            const component = bias + amp * wave.compute(angle);\n            components.push(component);\n        }\n\n        return new _babylonjs_core_Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Color4\"](...components);\n    }\n}\n\n\n//# sourceURL=webpack:///./src/palettes/WavePalette.js?");

/***/ }),

/***/ "./src/parts/Centroid.js":
/*!*******************************!*\
  !*** ./src/parts/Centroid.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Centroid; });\n/* harmony import */ var _babylonjs_core_Maths_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babylonjs/core/Maths/math */ \"./node_modules/@babylonjs/core/Maths/math.js\");\n/* harmony import */ var _babylonjs_core_Meshes_transformNode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babylonjs/core/Meshes/transformNode */ \"./node_modules/@babylonjs/core/Meshes/transformNode.js\");\n/* harmony import */ var _babylonjs_core_Meshes_meshBuilder__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babylonjs/core/Meshes/meshBuilder */ \"./node_modules/@babylonjs/core/Meshes/meshBuilder.js\");\n/* harmony import */ var _babylonjs_materials_grid__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babylonjs/materials/grid */ \"./node_modules/@babylonjs/materials/grid/index.js\");\n/* harmony import */ var _Part__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Part */ \"./src/parts/Part.js\");\n\n\n\n\n\n\n\n\nclass Centroid extends _Part__WEBPACK_IMPORTED_MODULE_4__[\"default\"] {\n    get default_parameters() {\n        return {\n            points: [],\n        }\n    }\n\n    constructor(parameters) {\n        super(parameters);\n\n        this.points = parameters.points;\n        this.origin = parameters.origin;\n        this.weights = parameters.weights;\n\n        this.translate = undefined;\n        this.sphere_primitive = undefined;\n    }\n\n    get part_type() {\n        return 'centroid';\n    }\n\n    get parents() {\n        const parent_points = this.points.map(x => x.part);\n        parent_points.push(this.origin.part);\n        return parent_points;\n    }\n\n    /**\n     * Compute the point relative to the origin's coordinate system\n     */\n    static compute_point(joint, inv_origin_matrix) {\n        const pos_world = joint.position;\n        return _babylonjs_core_Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"].TransformCoordinates(pos_world, inv_origin_matrix);\n    }\n\n    get centroid() {\n        const M = this.origin.inverse_matrix; \n        const points = this.points.map(x => Centroid.compute_point(x, M));\n        const weights = this.weights;\n        const sum = _babylonjs_core_Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"].Zero(); \n        let weight_sum = 0;\n        for (let i = 0; i < points.length; i++) {\n            const w = weights[i];\n            sum.addInPlace(points[i].scale(w));\n            weight_sum += w;\n        }\n        return sum.scale(1.0 / weight_sum);\n    }\n\n    build(scene) {\n        const translate = new _babylonjs_core_Meshes_transformNode__WEBPACK_IMPORTED_MODULE_1__[\"TransformNode\"](`${this.id}-translate`, scene);\n        translate.position = _babylonjs_core_Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"].Zero();\n        translate.parent = this.origin.node;\n        this.translate = translate;\n\n        const sphere = _babylonjs_core_Meshes_meshBuilder__WEBPACK_IMPORTED_MODULE_2__[\"MeshBuilder\"].CreateSphere(`${this.id}-sphere`, {\n            diameter: 0.2,\n        }, scene);\n        sphere.material = new _babylonjs_materials_grid__WEBPACK_IMPORTED_MODULE_3__[\"GridMaterial\"](`${this.id}-mat-grid`, scene);\n        sphere.parent = translate;\n        this.sphere_primitive = sphere;\n    }\n\n    update(t) {\n        const centroid = this.centroid;\n        this.translate.position = centroid;\n    }\n}\n\n\n//# sourceURL=webpack:///./src/parts/Centroid.js?");

/***/ }),

/***/ "./src/parts/Oscillator.js":
/*!*********************************!*\
  !*** ./src/parts/Oscillator.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Oscillator; });\n/* harmony import */ var _babylonjs_core_Maths_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babylonjs/core/Maths/math */ \"./node_modules/@babylonjs/core/Maths/math.js\");\n/* harmony import */ var _babylonjs_core_Meshes_transformNode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babylonjs/core/Meshes/transformNode */ \"./node_modules/@babylonjs/core/Meshes/transformNode.js\");\n/* harmony import */ var _babylonjs_core_Meshes_meshBuilder__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babylonjs/core/Meshes/meshBuilder */ \"./node_modules/@babylonjs/core/Meshes/meshBuilder.js\");\n/* harmony import */ var _babylonjs_materials_grid__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babylonjs/materials/grid */ \"./node_modules/@babylonjs/materials/grid/index.js\");\n/* harmony import */ var _Part__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Part */ \"./src/parts/Part.js\");\n/* harmony import */ var _waves_Sine__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../waves/Sine */ \"./src/waves/Sine.js\");\n\n\n\n\n\n\n\n\n\nclass Oscillator extends _Part__WEBPACK_IMPORTED_MODULE_4__[\"default\"] {\n    get default_parameters() {\n        return {\n            parent: undefined,\n            offset: _babylonjs_core_Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"].Zero(),\n            amplitude: 1,\n            phase: 0,\n            direction: new _babylonjs_core_Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0, 1, 0),\n            frequency: 1,\n            radius: 0.1,\n            wave: new _waves_Sine__WEBPACK_IMPORTED_MODULE_5__[\"default\"](),\n        }\n    }\n    init(parameters) {\n        super.init(parameters);\n\n        // extract the parameters\n        this.offset = parameters.offset;\n        this.amplitude = parameters.amplitude;\n        this.phase = parameters.phase;\n        this.direction = parameters.direction;\n        this.frequency = parameters.frequency;\n        this.radius = parameters.radius;\n        this.wave = parameters.wave;\n    }\n\n    get transform_names() {\n        return ['translate', 'translate_wave', 'scale'];\n    }\n\n    get primitive_names() {\n        return ['line_primitive', 'sphere_primitive'];\n    }\n\n    get part_type() {\n        return 'osc';\n    }\n\n    build(scene) {\n        const translate = new _babylonjs_core_Meshes_transformNode__WEBPACK_IMPORTED_MODULE_1__[\"TransformNode\"](`${this.id}-translate`, scene);\n        translate.position = this.offset;\n        if (this.parent !== undefined) {\n            translate.parent = this.parent.node;\n        }\n        this.translate = translate;\n\n        const translate_wave = new _babylonjs_core_Meshes_transformNode__WEBPACK_IMPORTED_MODULE_1__[\"TransformNode\"](\n            `${this.id}-translate-wave`, scene);\n        translate_wave.position = _babylonjs_core_Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"].Zero();\n        translate_wave.parent = translate;\n        this.translate_wave = translate_wave;\n\n        const sphere = _babylonjs_core_Meshes_meshBuilder__WEBPACK_IMPORTED_MODULE_2__[\"MeshBuilder\"].CreateSphere(`${this.id}-sphere`, {\n            diameter: 2 * this.radius,\n        }, scene);\n        sphere.material = new _babylonjs_materials_grid__WEBPACK_IMPORTED_MODULE_3__[\"GridMaterial\"](`${this.id}-mat-grid`, scene);\n        sphere.parent = translate_wave;\n        this.sphere_primitive = sphere;\n\n        const line = _babylonjs_core_Meshes_meshBuilder__WEBPACK_IMPORTED_MODULE_2__[\"MeshBuilder\"].CreateLines(`${this.id}-line`, {\n            points: [\n                this.direction.scale(this.amplitude),\n                this.direction.scale(-this.amplitude)\n            ]\n        }, scene);\n        line.parent = translate;\n        this.line_primitive = line;\n    }\n\n    update(t) { \n        const wave = this.amplitude * this.wave.compute(\n            2.0 * Math.PI * this.frequency * t + this.phase);\n        const wave_offset = this.direction.scale(wave);\n        this.translate_wave.position = wave_offset;\n    }\n}\n\n\n//# sourceURL=webpack:///./src/parts/Oscillator.js?");

/***/ }),

/***/ "./src/parts/Part.js":
/*!***************************!*\
  !*** ./src/parts/Part.js ***!
  \***************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Part; });\n/* harmony import */ var _Joint__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Joint */ \"./src/Joint.js\");\n\n\nlet part_count = 0;\n\nclass Part {\n    static make_id() {\n        const id = part_count;\n        part_count++;\n        return id;\n    } \n\n    constructor(parameters) {\n        this.init({...this.default_parameters, ...parameters});\n        this.id = `${this.part_type}-${Part.make_id()}`;\n    }\n\n    get part_type() {\n        return 'part';\n    }\n\n    /**\n     * Subclasses must list the property names that contain BabylonJS\n     * transform nodes. This is for documentation purposes\n     */\n    get transform_names() {\n        return [];\n    }\n\n    /**\n     * Subclasses must list the property names that contain BabylonJS\n     * primitives\n     */\n    get primitive_names() {\n        return [];\n    }\n\n    get default_parameters() {\n        return {\n            parent: undefined\n        };\n    }\n\n    change_parent(parent) {\n        this.parent = parent;\n    }\n\n    init(parameters) {\n        // Most often there is a single parent\n        this.parent = parameters.parent;\n    }\n\n    get parents() {\n        // Most often, there is a single parent\n        if (this.parent !== undefined) {\n            return [this.parent.part];\n        }\n        return [];\n    }\n\n    update(t) {\n\n    }\n\n    build(scene) {\n\n    }\n\n    to_joint(node_name) {\n        return new _Joint__WEBPACK_IMPORTED_MODULE_0__[\"default\"](this, node_name);\n    }\n}\n\n\n//# sourceURL=webpack:///./src/parts/Part.js?");

/***/ }),

/***/ "./src/parts/Point.js":
/*!****************************!*\
  !*** ./src/parts/Point.js ***!
  \****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Point; });\n/* harmony import */ var _babylonjs_core_Maths_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babylonjs/core/Maths/math */ \"./node_modules/@babylonjs/core/Maths/math.js\");\n/* harmony import */ var _babylonjs_core_Meshes_transformNode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babylonjs/core/Meshes/transformNode */ \"./node_modules/@babylonjs/core/Meshes/transformNode.js\");\n/* harmony import */ var _babylonjs_core_Meshes_meshBuilder__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babylonjs/core/Meshes/meshBuilder */ \"./node_modules/@babylonjs/core/Meshes/meshBuilder.js\");\n/* harmony import */ var _Part__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Part */ \"./src/parts/Part.js\");\n\n\n\n\n\n\n\nclass Point extends _Part__WEBPACK_IMPORTED_MODULE_3__[\"default\"] {\n    get default_parameters() {\n        return {\n            offset: _babylonjs_core_Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"].Zero(),\n            parent: undefined,\n            show_offset: false\n        };\n    }\n\n    init(parameters) {\n        super.init(parameters);\n        this.offset = parameters.offset;\n        this.show_offset = parameters.show_offset;\n    }\n\n    get part_type() {\n        return 'point';\n    }\n\n    get transform_names() {\n        return ['translate'];\n    }\n\n    get primitive_names() {\n        return ['line'];\n    }\n\n    make_line(scene) {\n        return _babylonjs_core_Meshes_meshBuilder__WEBPACK_IMPORTED_MODULE_2__[\"MeshBuilder\"].CreateLines(`${this.id}-line`, {\n            points: [\n                _babylonjs_core_Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"].Zero(),\n                this.offset.negate()\n            ]\n        }, scene);\n    }\n\n    build(scene) {\n        const translate = new _babylonjs_core_Meshes_transformNode__WEBPACK_IMPORTED_MODULE_1__[\"TransformNode\"](`${this.id}-translate`, scene);\n        translate.position = this.offset;\n        if (this.parent !== undefined) {\n            translate.parent = this.parent.node;\n        }\n        this.translate = translate;\n\n        if (this.show_offset) {\n            const line = this.make_line(scene);\n            line.parent = translate;\n            this.line = line;\n        }\n\n        return translate;\n    }\n}\n\n\n//# sourceURL=webpack:///./src/parts/Point.js?");

/***/ }),

/***/ "./src/parts/Prefab.js":
/*!*****************************!*\
  !*** ./src/parts/Prefab.js ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Prefab; });\n/* harmony import */ var _babylonjs_core_Maths_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babylonjs/core/Maths/math */ \"./node_modules/@babylonjs/core/Maths/math.js\");\n/* harmony import */ var _babylonjs_core_Meshes_transformNode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babylonjs/core/Meshes/transformNode */ \"./node_modules/@babylonjs/core/Meshes/transformNode.js\");\n/* harmony import */ var _babylonjs_core_Meshes_meshBuilder__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babylonjs/core/Meshes/meshBuilder */ \"./node_modules/@babylonjs/core/Meshes/meshBuilder.js\");\n/* harmony import */ var _babylonjs_materials_grid__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babylonjs/materials/grid */ \"./node_modules/@babylonjs/materials/grid/index.js\");\n/* harmony import */ var _Part__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Part */ \"./src/parts/Part.js\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util */ \"./src/util.js\");\n\n\n\n\n\n\n\n\n\nclass Prefab extends _Part__WEBPACK_IMPORTED_MODULE_4__[\"default\"] {\n    get default_parameters() {\n        return {\n            // The parent part\n            parent: undefined,\n            // Machine class that this prefab represents (required)\n            machine: undefined,\n        }\n    }\n\n    init(parameters) {\n        super.init(parameters);\n        this.machine = Object(_util__WEBPACK_IMPORTED_MODULE_5__[\"required\"])(parameters, 'machine');\n        this.machine.root_part.parent = parameters.parent;\n    }\n\n    change_parent(parent) {\n        this.parent = parent;\n        this.machine.root_part.parent = parent;\n    }\n\n    get part_type() {\n        return `prefab-${this.machine.machine_type}`;\n    }\n\n    build(scene) {\n        const root_primitive = this.machine.build(scene);\n    }\n\n    update(t) {\n        this.machine.update(t);\n    }\n\n    to_joint(node_name) {\n        const [part_label, ...rest]  = node_name.split('.');\n        const part_node = rest.join('.');\n\n        const part = this.machine.find_part(part_label);\n        return part.to_joint(part_node);\n    }\n}\n\n\n//# sourceURL=webpack:///./src/parts/Prefab.js?");

/***/ }),

/***/ "./src/parts/RotatingSphere.js":
/*!*************************************!*\
  !*** ./src/parts/RotatingSphere.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return RotatingSphere; });\n/* harmony import */ var _babylonjs_core_Maths_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babylonjs/core/Maths/math */ \"./node_modules/@babylonjs/core/Maths/math.js\");\n/* harmony import */ var _babylonjs_core_Meshes_transformNode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babylonjs/core/Meshes/transformNode */ \"./node_modules/@babylonjs/core/Meshes/transformNode.js\");\n/* harmony import */ var _babylonjs_core_Meshes_meshBuilder__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babylonjs/core/Meshes/meshBuilder */ \"./node_modules/@babylonjs/core/Meshes/meshBuilder.js\");\n/* harmony import */ var _babylonjs_materials_grid__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babylonjs/materials/grid */ \"./node_modules/@babylonjs/materials/grid/index.js\");\n/* harmony import */ var _Part__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Part */ \"./src/parts/Part.js\");\n\n\n\n\n\n\n\n\nclass RotatingSphere extends _Part__WEBPACK_IMPORTED_MODULE_4__[\"default\"] {\n    get default_parameters() {\n        return {\n            parent: undefined,\n            radius: 2,\n            axes: [\n                new _babylonjs_core_Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0, 1, 0),\n                new _babylonjs_core_Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0, 0, 1)\n            ],\n            angular_frequencies: [\n                0.1,\n                2,\n            ],\n            phases: [\n                0,\n                0\n            ],\n            show_offset: true,\n        }\n    }\n\n    init(parameters) {\n        super.init(parameters);\n        this.radius = parameters.radius;\n        this.angular_frequencies = parameters.angular_frequencies;\n        this.axes = parameters.axes;\n        this.phases = parameters.phases;\n        this.show_offset = parameters.show_offset;\n    }\n\n    get transform_names() {\n        return ['rotate', 'translate'];\n    }\n\n    get primitive_names() {\n        return ['sphere_primitive', 'radius_primitive'];\n    }\n\n    get parents() {\n        return [this.parent.part]\n    }\n\n    build(scene) {\n        const rotate = new _babylonjs_core_Meshes_transformNode__WEBPACK_IMPORTED_MODULE_1__[\"TransformNode\"](`${this.id}-rotate`, scene);\n        rotate.rotationQuaternion = _babylonjs_core_Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Quaternion\"].Identity();\n        rotate.parent = this.parent.node;\n        this.rotate = rotate;\n\n        const translate = new _babylonjs_core_Meshes_transformNode__WEBPACK_IMPORTED_MODULE_1__[\"TransformNode\"](`${this.id}-translate`, scene);\n        translate.position = new _babylonjs_core_Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](this.radius, 0, 0);\n        translate.parent = rotate;\n        this.translate = translate;\n\n        if (!this.show_offset) {\n            return;\n        }\n\n        const sphere = _babylonjs_core_Meshes_meshBuilder__WEBPACK_IMPORTED_MODULE_2__[\"MeshBuilder\"].CreateSphere(`${this.id}-sphere`, {\n            diameter: 0.2,\n        }, scene);\n        sphere.material = new _babylonjs_materials_grid__WEBPACK_IMPORTED_MODULE_3__[\"GridMaterial\"](`${this.id}-mat-grid`, scene);\n        sphere.parent = translate;\n        this.sphere_primitive = sphere;\n\n        const line = _babylonjs_core_Meshes_meshBuilder__WEBPACK_IMPORTED_MODULE_2__[\"MeshBuilder\"].CreateLines(`${this.id}-line`, {\n            points: [\n                _babylonjs_core_Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"].Zero(),\n                translate.position.negate()\n            ]\n        }, scene);\n        line.parent = translate;\n        this.line_primitive = line;\n    }\n\n    compute_angles(t) {\n        const angles = [];\n        for (let i = 0; i < this.phases.length; i++) {\n            const phase = this.phases[i];\n            const angular_freq = this.angular_frequencies[i];\n            const angle = angular_freq * t + phase;\n            angles.push(angle);\n        }\n        return angles;\n    }\n\n    compose_rotations(angles) {\n        let total_rotation = _babylonjs_core_Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Quaternion\"].Identity();\n        for (let i = 0; i < this.axes.length; i++) {\n            const quat = _babylonjs_core_Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Quaternion\"].RotationAxis(this.axes[i], angles[i]);\n            total_rotation = quat.multiply(total_rotation); \n        }\n        return total_rotation;\n    } \n\n    update(t) {\n        const angles = this.compute_angles(t);  \n        const quat = this.compose_rotations(angles);\n        this.rotate.rotationQuaternion = quat;\n    }\n}\n\n\n//# sourceURL=webpack:///./src/parts/RotatingSphere.js?");

/***/ }),

/***/ "./src/parts/Trace.js":
/*!****************************!*\
  !*** ./src/parts/Trace.js ***!
  \****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Trace; });\n/* harmony import */ var _babylonjs_core_Maths_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babylonjs/core/Maths/math */ \"./node_modules/@babylonjs/core/Maths/math.js\");\n/* harmony import */ var _babylonjs_core_Meshes_transformNode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babylonjs/core/Meshes/transformNode */ \"./node_modules/@babylonjs/core/Meshes/transformNode.js\");\n/* harmony import */ var _babylonjs_core_Meshes_meshBuilder__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babylonjs/core/Meshes/meshBuilder */ \"./node_modules/@babylonjs/core/Meshes/meshBuilder.js\");\n/* harmony import */ var _Part__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Part */ \"./src/parts/Part.js\");\n/* harmony import */ var _palettes_WavePalette__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../palettes/WavePalette */ \"./src/palettes/WavePalette.js\");\n/* harmony import */ var _palettes_ColorStops__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../palettes/ColorStops */ \"./src/palettes/ColorStops.js\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../util */ \"./src/util.js\");\n\n\n\n\n\n\n\n\n\n\nclass Trace extends _Part__WEBPACK_IMPORTED_MODULE_3__[\"default\"] {\n    get default_parameters() {\n        return {\n            // The joint to trace (the pen) (required)\n            source: undefined,\n            // The reference frame to draw on (the 3D paper) (optional)\n            target: undefined,\n            // The reference frame to use as the origin\n            origin: undefined,\n            // Number of points in the polyline\n            num_points: 1000,\n            // Palette to use for coloring the trace\n            palette: new _palettes_WavePalette__WEBPACK_IMPORTED_MODULE_4__[\"default\"](),\n            palette_freq: 2\n        };\n    }\n\n    init(parameters) {\n        this.source = Object(_util__WEBPACK_IMPORTED_MODULE_6__[\"required\"])(parameters, 'source');\n        this.target = parameters.target;\n        this.origin = Object(_util__WEBPACK_IMPORTED_MODULE_6__[\"required\"])(parameters, 'origin');\n\n        this.points = [];\n        this.num_points = parameters.num_points;\n        this.palette = parameters.palette;\n        this.palette_freq = parameters.palette_freq;\n    }\n\n    get primitive_names() {\n        return ['polyline_primitive'];\n    }\n\n    init_points() {\n        const points = [];\n        const initial_pos = this.compute_point();\n        for (let i = 0; i < this.num_points; i++) {\n            points.push(initial_pos);\n        }\n        return points;\n    }\n\n    get part_type() {\n        return 'trace';\n    }\n\n    get parents() {\n        const parent_list = [this.source.part, this.origin.part];\n\n        if (this.target !== undefined) {\n            parent_list.push(this.target.part);\n        }\n\n        return parent_list; \n    }\n\n    build(scene) {\n        const points = this.init_points();\n        const colors = this.palette.get_palette(points.length, this.palette_freq);\n        const polyline = _babylonjs_core_Meshes_meshBuilder__WEBPACK_IMPORTED_MODULE_2__[\"MeshBuilder\"].CreateLines(`${this.id}-polyline`, {\n            colors: colors,\n            updatable: true,\n            points: points\n        }, scene);\n        \n        polyline.parent = this.origin.node;\n\n        this.polyline_primitive = polyline;\n        this.points = points;\n    }\n\n    compute_point() {\n        // Compute the position of the pen in world space\n        let position = this.source.position;\n\n        if (this.target !== undefined) {\n            // Transform things into the \"paper\" coordinate frame. For a turntable\n            // drawing machine, this could be a rotating reference frame.\n            const M_paper = this.target.inverse_matrix; \n            position = _babylonjs_core_Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"].TransformCoordinates(position, M_paper); \n        } else {\n            // Transform into the origin's coordinate frame. If a target is\n            // specified, this doesn't need to be done\n            const M_origin = this.origin.inverse_matrix;\n            position = _babylonjs_core_Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"].TransformCoordinates(position, M_origin);\n        }\n\n        return position;\n    }\n\n    update(t) {\n        const points = this.points;\n        const point = this.compute_point();\n        points.push(point);\n        points.shift();\n\n        this.polyline_primitive = _babylonjs_core_Meshes_meshBuilder__WEBPACK_IMPORTED_MODULE_2__[\"MeshBuilder\"].CreateLines(`${this.id}-polyline`, {\n            instance: this.polyline_primitive,\n            points: points\n        });\n    }\n}\n\n\n//# sourceURL=webpack:///./src/parts/Trace.js?");

/***/ }),

/***/ "./src/parts/XYZOscillator.js":
/*!************************************!*\
  !*** ./src/parts/XYZOscillator.js ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return XYZOscillator; });\n/* harmony import */ var _babylonjs_core_Maths_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babylonjs/core/Maths/math */ \"./node_modules/@babylonjs/core/Maths/math.js\");\n/* harmony import */ var _babylonjs_core_Meshes_transformNode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babylonjs/core/Meshes/transformNode */ \"./node_modules/@babylonjs/core/Meshes/transformNode.js\");\n/* harmony import */ var _babylonjs_core_Meshes_meshBuilder__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babylonjs/core/Meshes/meshBuilder */ \"./node_modules/@babylonjs/core/Meshes/meshBuilder.js\");\n/* harmony import */ var _babylonjs_materials_grid__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babylonjs/materials/grid */ \"./node_modules/@babylonjs/materials/grid/index.js\");\n/* harmony import */ var _Part__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Part */ \"./src/parts/Part.js\");\n/* harmony import */ var _waves_Sine__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../waves/Sine */ \"./src/waves/Sine.js\");\n\n\n\n\n\n\n\n\n\nclass XYZOscillator extends _Part__WEBPACK_IMPORTED_MODULE_4__[\"default\"] {\n    get default_parameters() {\n        return {\n            parent: undefined,\n            amplitudes: new _babylonjs_core_Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](1, 1, 1),\n            frequencies: new _babylonjs_core_Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](1, 0.1, 1),\n            phases: new _babylonjs_core_Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0, 0, Math.PI / 2),\n            waves: [new _waves_Sine__WEBPACK_IMPORTED_MODULE_5__[\"default\"](), new _waves_Sine__WEBPACK_IMPORTED_MODULE_5__[\"default\"](), new _waves_Sine__WEBPACK_IMPORTED_MODULE_5__[\"default\"]()]\n        }\n    }\n\n    init(parameters) {\n        super.init(parameters);\n        this.frequencies = parameters.frequencies;\n        this.phases = parameters.phases;\n        this.amplitudes = parameters.amplitudes;\n        this.waves = parameters.waves;\n    }\n\n    get transform_names() {\n        return ['translate', 'translate_wave'];\n    }\n\n    get primitive_names() {\n        return ['sphere_primitive'];\n    }\n\n    get part_type() {\n        return 'xyzosc';\n    }\n\n    get parents() {\n        if (this.parent !== undefined) {\n            return [this.parent.part];\n        }\n\n        return [];\n    }\n\n    build(scene) {\n        const translate_wave = new _babylonjs_core_Meshes_transformNode__WEBPACK_IMPORTED_MODULE_1__[\"TransformNode\"](\n            `${this.id}-translate-wave`, scene);\n        translate_wave.position = this.compute_wave(0);\n        if (this.parent !== undefined) {\n            translate_wave.parent = this.parent.node;\n        }\n        this.translate_wave = translate_wave;\n\n        const sphere = _babylonjs_core_Meshes_meshBuilder__WEBPACK_IMPORTED_MODULE_2__[\"MeshBuilder\"].CreateSphere(`${this.id}-sphere`, {\n            diameter: 0.2,\n        }, scene);\n        sphere.material = new _babylonjs_materials_grid__WEBPACK_IMPORTED_MODULE_3__[\"GridMaterial\"](`${this.id}-mat-grid`, scene);\n        sphere.parent = translate_wave;\n        this.sphere_primitive = sphere;\n    }\n\n    compute_wave(t) {\n        const theta_x = 2.0 * Math.PI * this.frequencies.x * t + this.phases.x;\n        const theta_y = 2.0 * Math.PI * this.frequencies.y * t + this.phases.y;\n        const theta_z = 2.0 * Math.PI * this.frequencies.z * t + this.phases.z;\n        const [wave_x, wave_y, wave_z] = this.waves;\n        const val_x = this.amplitudes.x * wave_x.compute(theta_x);\n        const val_y = this.amplitudes.y * wave_y.compute(theta_y);\n        const val_z = this.amplitudes.z * wave_z.compute(theta_z);\n        return new _babylonjs_core_Maths_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](val_x, val_y, val_z);\n    }\n\n    update(t) {\n        this.translate_wave.position = this.compute_wave(t);\n    }\n}\n\n\n//# sourceURL=webpack:///./src/parts/XYZOscillator.js?");

/***/ }),

/***/ "./src/util.js":
/*!*********************!*\
  !*** ./src/util.js ***!
  \*********************/
/*! exports provided: required */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"required\", function() { return required; });\nfunction required(parameters, key) {\n    const val = parameters[key];\n    if (val === undefined || val === null) {\n        throw new Error(`${key} is required`);\n    }\n\n    return val;\n};\n\n\n//# sourceURL=webpack:///./src/util.js?");

/***/ }),

/***/ "./src/waves/Fourier.js":
/*!******************************!*\
  !*** ./src/waves/Fourier.js ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Fourier; });\n/* harmony import */ var _Wave__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Wave */ \"./src/waves/Wave.js\");\n\n\nclass Fourier extends _Wave__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    constructor(parameters) {\n        super();\n        this.amplitudes = parameters.amplitudes;\n        this.frequencies = parameters.frequencies;\n    }\n\n    compute(t) {\n        let result = 0.0;\n        let amp_sum = 0.0;\n        for (let i = 0; i < this.amplitudes.length; i++) {\n            const amp = this.amplitudes[i];\n            const freq = this.frequencies[i];\n            result += amp * Math.sin(freq * t);\n            amp_sum += amp;\n        }\n        return result / amp_sum;\n    }\n}\n\n\n//# sourceURL=webpack:///./src/waves/Fourier.js?");

/***/ }),

/***/ "./src/waves/Sine.js":
/*!***************************!*\
  !*** ./src/waves/Sine.js ***!
  \***************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Sine; });\n/* harmony import */ var _Wave__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Wave */ \"./src/waves/Wave.js\");\n\n\nclass Sine extends _Wave__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    compute(t) {\n        return Math.sin(t);\n    }\n}\n\n\n//# sourceURL=webpack:///./src/waves/Sine.js?");

/***/ }),

/***/ "./src/waves/Square.js":
/*!*****************************!*\
  !*** ./src/waves/Square.js ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Square; });\n/* harmony import */ var _Wave__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Wave */ \"./src/waves/Wave.js\");\n\n\nclass Square extends _Wave__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    compute(t) {\n        return Math.sign(Math.sin(t));\n    }\n}\n\n\n//# sourceURL=webpack:///./src/waves/Square.js?");

/***/ }),

/***/ "./src/waves/Wave.js":
/*!***************************!*\
  !*** ./src/waves/Wave.js ***!
  \***************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Wave; });\nclass Wave {\n    compute(t) {\n        // Subclasses will define this. It must be a function that is\n        // 2pi periodic and f(0) = f(2pi) = 0\n    }\n}\n\n\n//# sourceURL=webpack:///./src/waves/Wave.js?");

/***/ })

}]);